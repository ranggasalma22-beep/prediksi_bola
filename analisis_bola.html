<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PRIME SINGULARITY ZERO ∑.REBUILD — Full</title>
<style>
  :root{--bg:#050608;--panel:#131316;--muted:#aaa;--accent:#12b8e3;--mono:monospace;}
  body{background:var(--bg);color:#f5f5f5;font-family:Inter,Arial,sans-serif;padding:18px;}
  h1{color:#7bf7ff;font-size:24px;margin:6px 0 12px;}
  .section{background:var(--panel);border:1px solid #2b2b2b;padding:12px;border-radius:8px;margin-bottom:12px;}
  label{display:block;margin-top:8px;font-size:13px;color:#dcdcdc;}
  input,select,textarea{width:100%;padding:8px;margin-top:6px;border-radius:6px;border:1px solid #444;background:#0b0b0b;color:#cfe;box-sizing:border-box;}
  .triple-input{display:flex;gap:6px}
  .triple-input input{width:33%}
  button{background:var(--accent);border:none;padding:10px 12px;border-radius:8px;color:#000;font-weight:700;cursor:pointer;margin-top:10px}
  button.secondary{background:#444;color:#fff}
  textarea#output{height:280px;background:#050506;color:#00ff88;font-family:monospace;font-size:12px;white-space:pre-wrap;overflow:auto}
  small{color:var(--muted);font-size:12px}
  hr{border:0;border-top:1px solid #222;margin:12px 0}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:880px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<h1>Match Simulation Engine — PRIME SINGULARITY ZERO ∑.REBUILD (Rebuilt)</h1>

<!-- INPUT STATISTIK UTAMA -->
<div class="section">
  <h2>Input Statistik Utama</h2>
  <label>Expected Goals Home (λH)</label><input id="lamH" type="number" step="0.01" min="0.0" placeholder="1.60">
  <label>Expected Goals Away (λA)</label><input id="lamA" type="number" step="0.01" min="0.0" placeholder="1.20">
  <div class="grid">
    <div>
      <label>Tempo (1–10)</label><input id="tempo" type="number" min="1" max="10" step="0.1" placeholder="5">
    </div>
    <div>
      <label>Chaos (1–10)</label><input id="chaos" type="number" min="1" max="10" step="0.1" placeholder="5">
    </div>
  </div>
  <label>Importance (1–10)</label><input id="importance" type="number" min="1" max="10" step="0.1" placeholder="5">
</div>

<!-- DATA TIM -->
<div class="section">
  <h2>Data Tim</h2>
  <div class="grid">
    <div>
      <label>Home Stability (1–10)</label><input id="home_st" type="number" min="1" max="10" placeholder="5">
    </div>
    <div>
      <label>Away Stability (1–10)</label><input id="away_st" type="number" min="1" max="10" placeholder="5">
    </div>
  </div>

  <div class="grid">
    <div>
      <label>Home Momentum (1–10)</label><input id="home_mom" type="number" min="1" max="10" placeholder="5">
    </div>
    <div>
      <label>Away Momentum (1–10)</label><input id="away_mom" type="number" min="1" max="10" placeholder="5">
    </div>
  </div>
</div>

<!-- TAKTIK -->
<div class="section">
  <h2>Taktik & Fleksibilitas</h2>
  <div class="grid">
    <div>
      <label>Home Press Intensity (1–10)</label><input id="home_press" type="number" min="1" max="10" placeholder="5">
    </div>
    <div>
      <label>Away Press Intensity (1–10)</label><input id="away_press" type="number" min="1" max="10" placeholder="5">
    </div>
  </div>
  <div class="grid">
    <div>
      <label>Home Flex (0–1)</label><input id="home_flex" type="number" min="0" max="1" step="0.01" placeholder="0.5">
    </div>
    <div>
      <label>Away Flex (0–1)</label><input id="away_flex" type="number" min="0" max="1" step="0.01" placeholder="0.5">
    </div>
  </div>
  <small>Flex 0.1 = kaku, 0.5 = moderat, 0.8 = sangat fleksibel</small>
</div>

<!-- ADVANCED STATS -->
<div class="section">
  <h2>Advanced Stats (opsional)</h2>
  <label>xG Home (rata-rata 5 laga)</label><input id="adv_xg_home" step="0.01" type="number" placeholder="1.70">
  <label>xG Away</label><input id="adv_xg_away" step="0.01" type="number" placeholder="1.30">
  <label>xGA Home</label><input id="adv_xga_home" step="0.01" type="number" placeholder="1.10">
  <label>xGA Away</label><input id="adv_xga_away" step="0.01" type="number" placeholder="1.40">

  <label>Form Home (W-D-L, 5 laga)</label>
  <div class="triple-input">
    <input id="adv_form_home_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_home_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_home_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>Form Away (W-D-L)</label>
  <div class="triple-input">
    <input id="adv_form_away_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_away_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_away_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>PPDA Home</label><input id="adv_ppda_home" step="0.1" type="number" placeholder="8.0">
  <label>PPDA Away</label><input id="adv_ppda_away" step="0.1" type="number" placeholder="10.5">

  <label>Error Defensif Home per laga</label><input id="adv_err_home" step="0.1" type="number" placeholder="0.8">
  <label>Error Defensif Away</label><input id="adv_err_away" step="0.1" type="number" placeholder="1.2">

  <label>Jumlah Formasi Aktif Home (1–3)</label><input id="adv_formasi_home" type="number" min="1" max="3" placeholder="2">
  <label>Jumlah Formasi Aktif Away (1–3)</label><input id="adv_formasi_away" type="number" min="1" max="3" placeholder="1">

  <label>xG Efficiency Home (0.7–1.3) (opsional)</label><input id="adv_xg_eff_home" type="number" step="0.01" min="0.7" max="1.3" placeholder="1.00">
  <label>xG Efficiency Away</label><input id="adv_xg_eff_away" type="number" step="0.01" min="0.7" max="1.3" placeholder="1.00">

  <label>Formasi Home (opsional)</label>
  <select id="adv_forma_home"><option value="">-- pilih --</option><option value="433">4-3-3</option><option value="4231">4-2-3-1</option><option value="352">3-5-2</option><option value="343">3-4-3</option></select>

  <label>Formasi Away (opsional)</label>
  <select id="adv_forma_away"><option value="">-- pilih --</option><option value="433">4-3-3</option><option value="4231">4-2-3-1</option><option value="352">3-5-2</option><option value="343">3-4-3</option></select>

  <label>Late-game Strength Home (1–10)</label><input id="adv_late_home" type="number" min="1" max="10" placeholder="5">
  <label>Late-game Strength Away (1–10)</label><input id="adv_late_away" type="number" min="1" max="10" placeholder="5">

  <div style="margin-top:8px">
    <button id="btn_auto_ppda">AUTO-ESTIMATE PPDA</button>
    <button id="btn_auto_calc" class="secondary">AUTO-CALC INPUT WAJIB</button>
    <button id="btn_auto_tci" class="secondary">AUTO-FILL TEMPO/CHAOS/IMPORTANCE</button>
  </div>
  <small>Gunakan auto-calc untuk mengisi λ, Momentum, Stability, Press & Flex dari advanced stats.</small>
</div>

<!-- Patch UI + Match Type will be inserted later via scripts or you can add manually -->
<!-- PART 2: CORE ENGINE SCRIPT -->
<script>
// =============================================================
// V20 — Match Simulation Engine Core
// =============================================================
const V20 = {};

// ---------------------------
// Safe number parse
// ---------------------------
V20.num = function(v, fallback = 0){
  const n = Number(v);
  return isFinite(n) ? n : fallback;
};

// ---------------------------
// clamp helper
// ---------------------------
V20.clamp = function(value, min, max){
  if (value < min) return min;
  if (value > max) return max;
  return value;
};

// ---------------------------
// Log factorial cache for Poisson
// ---------------------------
V20._logFactorialCache = [0];
V20._logFactorial = function(n){
  const cache = V20._logFactorialCache;
  if (cache[n] != null) return cache[n];
  let val = cache[cache.length - 1];
  for (let i = cache.length; i <= n; i++){
    val += Math.log(i);
    cache[i] = val;
  }
  return cache[n];
};

// ---------------------------
// Poisson PMF
// ---------------------------
V20.poissonPMF = function(lambda, k){
  lambda = Math.max(lambda, 0.00001);
  if (k < 0) return 0;
  return Math.exp(-lambda + k*Math.log(lambda) - V20._logFactorial(k));
};

// ---------------------------
// Poisson sampler (Knuth)
 // ---------------------------
V20.samplePoisson = function(lambda){
  lambda = Math.max(lambda, 0.00001);
  const L = Math.exp(-lambda);
  let p = 1, k = 0;
  do {
    p *= Math.random();
    k++;
  } while (p > L);
  return k - 1;
};

// ---------------------------
// Normalize array
// ---------------------------
V20.normalize = function(arr){
  let s = 0;
  for (let x of arr) s += x;
  if (!s) return arr.map(() => 1/arr.length);
  return arr.map(x => x/s);
};

// =============================================================
// Pattern Oracle
// =============================================================
V20.patternOracle = function(ctx, home, away, tact){
  ctx  = ctx  || {};
  home = home || {stability:5, momentum:5};
  away = away || {stability:5, momentum:5};
  tact = tact || { home:{pressIntensity:5, flex:0.5}, away:{pressIntensity:5, flex:0.5} };

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;
  const imp   = ctx.importance || 5;

  const stH = home.stability || 5;
  const stA = away.stability || 5;
  const stabAvg = (stH + stA)/2;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const momGap = momH - momA;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;
  const pressGap = pressH - pressA;

  const tempoF = (tempo - 5)/5;
  const chaosF = (chaos - 5)/5;
  const impF   = (imp   - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  let control = 0.35 - chaosF*0.20 + stabF*0.25 + impF*0.05;
  let swing   = 0.25 + Math.abs(momGap)*0.04 + Math.abs(pressGap)*0.05 + tempoF*0.15;
  let stalled = 0.15 + (-tempoF)*0.20 + stabF*0.15;
  let chaotic = 0.25 + chaosF*0.35 + tempoF*0.15 - stabF*0.10;

control = Math.max(control, 0.01);
  swing   = Math.max(swing  , 0.01);
  stalled = Math.max(stalled, 0.01);
  chaotic = Math.max(chaotic, 0.01);

  let sum = control + swing + stalled + chaotic;
  const pattern = {
    control: control/sum,
    swing:   swing/sum,
    stalled: stalled/sum,
    chaotic: chaotic/sum
  };

  let dom = "control";
  let mx  = pattern.control;
  if(pattern.swing   > mx){ dom="swing";   mx=pattern.swing; }
  if(pattern.stalled > mx){ dom="stalled"; mx=pattern.stalled; }
  if(pattern.chaotic > mx){ dom="chaotic"; mx=pattern.chaotic; }

  return { pattern, dominant: dom };
};

// =============================================================
// NEW MODULES: DCI, ACI, MVI, FMA, Late-Game
// =============================================================
V20.computeDCI = function(home, away, adv){
  adv = adv || {};
  const ppdaH = V20.num(adv.ppdaH, 12);
  const ppdaA = V20.num(adv.ppdaA, 12);
  const errH  = V20.num(adv.errH, 1);
  const errA  = V20.num(adv.errA, 1);

  function calc(ppda, err){
    let base = 0.55;
    base -= (ppda - 10) * 0.02;
    base -= err * 0.05;
    return V20.clamp(base, 0.15, 0.85);
  }

  return { home: calc(ppdaH, errH), away: calc(ppdaA, errA) };
};

V20.computeACI = function(eff){
  eff = V20.num(eff, 1.0);
  return V20.clamp(0.85 + (eff - 1.0) * 0.25, 0.70, 1.30);
};

V20.computeMVI = function(W,D,L){
  const total = W+D+L;
  if(total === 0) return 0.5;
  const instability = Math.abs(W - L) / total;
  return V20.clamp(instability, 0, 1);
};

// FMA simple lookup
V20.fmaLookup = function(hForm, aForm){
  if(!hForm || !aForm) return 0;
  const key = hForm + "_vs_" + aForm;
  const map = {
    "433_vs_352": 0.06,
    "352_vs_433": -0.06,
    "4231_vs_433": 0.03,
    "433_vs_4231": -0.03,
    "352_vs_4231": 0.02,
    "4231_vs_352": -0.02
  };
  return V20.num(map[key], 0);
};

V20.lateGameAdjust = function(phase, hLate, aLate){
  if(phase !== "late") return {hAdd:0, aAdd:0};
  hLate = V20.num(hLate,5);
  aLate = V20.num(aLate,5);
  return { hAdd: V20.clamp((hLate - 5) * 0.012, 0, 0.06), aAdd: V20.clamp((aLate - 5) * 0.012, 0, 0.06) };
};

// =============================================================
// Hyper Lambda — modifies lambda based on pattern/tactic/momentum
// =============================================================
V20.hyperLambda = function(lambda, ctx, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || { home:{pressIntensity:5, flex:0.5}, away:{pressIntensity:5, flex:0.5} };

  let lamH = V20.num(lambda.lamH, 1.2);
  let lamA = V20.num(lambda.lamA, 1.0);

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const stH  = home.stability || 5;
  const stA  = away.stability || 5;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;

  const momGap   = momH - momA;
  const pressGap = pressH - pressA;
  const stabAvg  = (stH + stA)/2;

  const PO  = V20.patternOracle(ctx, home, away, tact);
  const pat = PO.pattern;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const stabF  = (stabAvg - 5)/5;

 // Control dampening
  lamH *= (1 - pat.control*0.05);
  lamA *= (1 - pat.control*0.05);

  // Swing effects (momentum/press)
  const swingH = pat.swing*(Math.max(0,momGap)/10 + Math.max(0,pressGap)/10);
  const swingA = pat.swing*(Math.max(0,-momGap)/10 + Math.max(0,-pressGap)/10);
  lamH *= (1 + swingH*0.22);
  lamA *= (1 + swingA*0.22);

  // Stalled slows down
  lamH *= (1 - pat.stalled*0.10);
  lamA *= (1 - pat.stalled*0.10);

  // Chaotic opens chances
  lamH *= (1 + pat.chaotic*0.25);
  lamA *= (1 + pat.chaotic*0.25);

  // raw pressure effect
  lamH *= (1 + (pressH-5)*0.015);
  lamA *= (1 + (pressA-5)*0.015);

  // flexibility
  lamH *= (1 + flexH*0.05);
  lamA *= (1 + flexA*0.05);

  // chaos global
  lamH *= (1 + chaosF*0.10 + tempoF*0.02);
  lamA *= (1 + chaosF*0.10 + tempoF*0.02);

  // --- Apply optional advanced modifiers if available
  try {
    const advG = (typeof window !== "undefined" && window._V20_ADV) ? window._V20_ADV : null;
    if (advG){
      // ACI
      if (advG.ACI_H) lamH *= advG.ACI_H;
      if (advG.ACI_A) lamA *= advG.ACI_A;
      // DCI reduces opponent scoring
      if (advG.DCI){
        lamH *= (1 - advG.DCI.away*0.08);
        lamA *= (1 - advG.DCI.home*0.08);
      }
      // FMA — match-up advantage
      if (advG.fma){
        lamH *= (1 + advG.fma);
        lamA *= (1 - advG.fma);
      }
    }
  } catch(e){
    // ignore
  }

  // Also apply Match Type template if present
  try {
    const mt = (typeof window !== "undefined" && window._V20_MATCH_TEMPLATE) ? window._V20_MATCH_TEMPLATE : null;
    if(mt && mt.finishingBias){
      lamH *= V20.num(mt.finishingBias,1);
      lamA *= V20.num(mt.finishingBias,1);
    }
  } catch(e){}

  lamH = V20.clamp(lamH, 0.20, 6.00);
  lamA = V20.clamp(lamA, 0.20, 6.00);

  return {
    lamH,
    lamA,
    pattern: pat,
    dominantPattern: PO.dominant
  };
};

// =============================================================
// Deterministic Poisson Analytic
// =============================================================
V20.detSim = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);

  let pH=0, pD=0, pA=0;
  const maxG = 8;

  let ou = {
    "0.5":{over:0, under:0},
    "1.5":{over:0, under:0},
    "2.5":{over:0, under:0},
    "3.5":{over:0, under:0}
  };

  let total = 0;

  for (let h=0; h<=maxG; h++){
    let pPH = V20.poissonPMF(lamH, h);
    for (let a=0; a<=maxG; a++){
      let pPA = V20.poissonPMF(lamA, a);
      let p   = pPH*pPA;
      total += p;

      if(h > a)      pH += p;
      else if(h==a)  pD += p;
      else           pA += p;

      const sum = h+a;
      if(sum > 0) ou["0.5"].over += p; else ou["0.5"].under += p;
      if(sum > 1) ou["1.5"].over += p; else ou["1.5"].under += p;
      if(sum > 2) ou["2.5"].over += p; else ou["2.5"].under += p;
      if(sum > 3) ou["3.5"].over += p; else ou["3.5"].under += p;
    }
  }

  if(total>0){
    pH/=total; pD/=total; pA/=total;
    Object.values(ou).forEach(x=>{
      x.over/=total; x.under/=total;
    });
  }

  return {pH,pD,pA,ou};
};

// =============================================================
// Chaos Model (adjust lambda by chaos factor)
// =============================================================
V20.chaosModel = function(lambda, ctx){
  lambda = lambda || {};
  ctx    = ctx || {};

  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);
  const chaos = ctx.chaos || 5;

  const chaosF = (chaos - 5)/5;
  const factor = 1 + V20.clamp(chaosF*0.24, -0.22, 0.32);

  return {
    lamH: V20.clamp(lamH*factor, 0.20, 6.00),
    lamA: V20.clamp(lamA*factor, 0.20, 6.00)
  };
};

// =============================================================
// Monte Carlo — Multi-Reality Divine Engine
// =============================================================
V20.monteCarlo = function(lambda, ctx, simCount, scoreCap, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || { home:{pressIntensity:5, flex:0.5}, away:{pressIntensity:5, flex:0.5} };

  // Hyper Lambda
  const HL = V20.hyperLambda(lambda, ctx, home, away, tact);
  const lamH_base = HL.lamH;
  const lamA_base = HL.lamA;
  const totalLam = lamH_base + lamA_base || 0.0001;

  const pat = HL.pattern;

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;
  const imp   = ctx.importance || 5;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const impF   = (imp   - 5)/5;

  // base simCount
  const baseSim = simCount ? V20.num(simCount, 50000) : 50000;

  // adjust simCount using pattern + globalAdj
  let patternScale =
      1.00
    + pat.swing   * 0.30
    + pat.chaotic * 0.35
    - pat.stalled * 0.25;

  const globalAdj =
      chaosF*0.35 +
      tempoF*0.25 +
      impF  *0.15;

  let simScaled = baseSim * (1 + globalAdj*0.7) * patternScale;
  simScaled = V20.clamp(simScaled, 30000, 250000);
  simCount  = Math.round(simScaled);

  // allow Match Type variance multiplier
  try {
    const mt = (typeof window !== "undefined" && window._V20_MATCH_TEMPLATE) ? window._V20_MATCH_TEMPLATE : null;
    if(mt && mt.variance){
      simCount = Math.round(V20.clamp(simCount * V20.num(mt.variance,1), 20000, 350000));
      // expose multiplier
      window._V20_MC_VARIANCE_MULT = V20.num(mt.variance,1);
    }
  } catch(e){}

  // Score cap
  const autoCap = totalLam > 3.4 ? 6 : 5;
  scoreCap = V20.clamp(scoreCap || autoCap, 3, 8);

  // Phases
  const phases = [
    {name:"early", w:0.25},
    {name:"mid",   w:0.50},
    {name:"late",  w:0.25}
  ];
  let acc=0;
  phases.forEach(p=>{ acc+=p.w; p.cum=acc; });

  function pickPhase(){
    const r = Math.random();
    for(let p of phases){
      if(r <= p.cum) return p;
    }
    return phases[phases.length-1];
  }

  // Realities A/B/C
  const realityWeights = {
    A: 0.40 + pat.control*0.20,
    B: 0.30 + pat.chaotic*0.30,
    C: 0.30 + pat.swing*0.30
  };
  let wSum = realityWeights.A + realityWeights.B + realityWeights.C;
  realityWeights.A/=wSum;
  realityWeights.B/=wSum;
  realityWeights.C/=wSum;

  function pickReality(){
    const r = Math.random();
    if(r <= realityWeights.A) return "A";
    if(r <= realityWeights.A + realityWeights.B) return "B";
    return "C";
  }

  function realityParams(type){
    let fH=1, fA=1, spread=0.6;
    if(type==="A"){
      fH=1.00; fA=1.00; spread=0.45;
    } else if(type==="B"){
      fH=1.00 + Math.max(0,chaosF)*0.20;
      fA=1.00 + Math.max(0,chaosF)*0.20;
      spread = 0.6 + Math.max(0,chaosF)*0.6;
    } else {
      const swingBoost   = pat.swing*0.10;
      const chaoticBoost = pat.chaotic*0.12;
      fH = 1.00 + swingBoost + chaoticBoost;
      fA = 1.00 + swingBoost + chaoticBoost;
      spread = 0.6 + (pat.chaotic+pat.swing)*0.6;
    }

// allow template to influence spread slightly
    try {
      const mt = (typeof window !== "undefined" && window._V20_MATCH_TEMPLATE) ? window._V20_MATCH_TEMPLATE : null;
      if(mt && mt.variance){
        spread *= V20.num(mt.variance,1);
      }
    } catch(e){}

    return {fH,fA,spread};
  }

  // scenarios
  const ratioH = lamH_base / totalLam;
  const scenarios = [
    {name:"base",      w:0.30, fH:1.00, fA:1.00},
    {name:"control",   w:0.08 + 0.25*pat.control, fH:0.97, fA:0.97},
    {name:"swing",     w:0.08 + 0.25*pat.swing,   fH:1.07, fA:1.07},
    {name:"stalled",   w:0.06 + 0.22*pat.stalled, fH:0.78, fA:0.78},
    {name:"chaotic",   w:0.06 + 0.22*pat.chaotic, fH:1.18, fA:1.18},
    {name:"homeFront", w:0.06 + 0.10*ratioH,      fH:1.08, fA:0.97},
    {name:"awayFront", w:0.06 + 0.10*(1-ratioH),  fH:0.97, fA:1.08},
    {name:"wideOpen",  w:0.04 + 0.12*Math.max(0,tempoF)*Math.max(0,chaosF), fH:1.22, fA:1.22}
  ];

  scenarios.forEach(s=>{
    if(s.name==="wideOpen") s.w*=0.90;
    if(s.name==="chaotic")  s.w*=0.93;
    if(s.name==="stalled")  s.w*=0.95;
  });

  let scSum = 0;
  scenarios.forEach(s=>scSum+=s.w);
  scenarios.forEach(s=>s.p = s.w/scSum);
  let cum = 0;
  scenarios.forEach(s=>{ cum+=s.p; s.cum=cum; });

  function pickScenario(){
    const r = Math.random();
    for(let s of scenarios){
      if(r <= s.cum) return s;
    }
    return scenarios[scenarios.length-1];
  }

  function sampleHybrid(lambdaBase, spreadBase){
    lambdaBase = Math.max(lambdaBase, 0.00001);
    const r = Math.random();
    if(r < 0.55){
      return V20.samplePoisson(lambdaBase);
    } else if(r < 0.85){
      const factor = Math.exp((Math.random()-0.5)*spreadBase);
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.2);
      return V20.samplePoisson(lamVar);
    } else {
      const factor = Math.exp((Math.random()-0.5)*(spreadBase+0.4));
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.8);
      return V20.samplePoisson(lamVar);
    }
  }

  let homeWins=0, draws=0, awayWins=0;
  let total=0, goalsTotal=0;

  const matrix=[];
  for(let h=0;h<=scoreCap;h++){
    matrix[h]=[];
    for(let a=0;a<=scoreCap;a++){
      matrix[h][a]=0;
    }
  }

  const scenarioCount = {};
  scenarios.forEach(s=>scenarioCount[s.name]=0);

  // MAIN LOOP
  for(let i=0;i<simCount;i++){
    const phase   = pickPhase();
    const sc      = pickScenario();
    const reality = pickReality();

    scenarioCount[sc.name]++;

    const rp = realityParams(reality);

    const lamH_sim = lamH_base * sc.fH * rp.fH;
    const lamA_sim = lamA_base * sc.fA * rp.fA;

    let h = sampleHybrid(lamH_sim, rp.spread);
    let a = sampleHybrid(lamA_sim, rp.spread);

    // Late game small adjustments if defined
    try {
      const advG = (typeof window !== "undefined" && window._V20_ADV) ? window._V20_ADV : null;
      if (phase.name === "late" && advG){
        const adj = V20.lateGameAdjust("late", advG.lateH, advG.lateA);
        if (Math.random() < adj.hAdd) h += 1;
        if (Math.random() < adj.aAdd) a += 1;
      }
    } catch(e){}

    total++;
    goalsTotal += (h+a);

    if(h>a) homeWins++;
    else if(h===a) draws++;
    else awayWins++;

    if(h<=scoreCap && a<=scoreCap){
      matrix[h][a]++;
    }
  }
return{
    simCount,
    pH: homeWins/total,
    pD: draws/total,
    pA: awayWins/total,
    avgGoals: goalsTotal/total,
    matrix,
    scoreCap,
    god:{
      hyperLambda:{lamH:lamH_base, lamA:lamA_base},
      pattern: pat
    },
    scenarioStats:{
      scenarios,
      count:scenarioCount
    }
  };
};

// =============================================================
// Risk, Fragility, SDI, Meta, Flow, Momentum Swing
// =============================================================
V20.computeRisk = function(ctx, tact){
  ctx  = ctx  || {};
  tact = tact || {home:{flex:0.5}, away:{flex:0.5}};

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;
  const flexAvg = (flexH + flexA)/2;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;

  let risk = 0.42 + chaosF*0.33 + tempoF*0.18 + flexAvg*0.20;
  return V20.clamp(risk, 0, 1);
};

V20.computeFragility = function(ctx, home, away){
  ctx  = ctx  || {};
  home = home || {stability:5};
  away = away || {stability:5};

  const chaos = ctx.chaos || 5;
  const stH   = home.stability || 5;
  const stA   = away.stability || 5;

  const stabAvg = (stH + stA)/2;
  const chaosF  = (chaos - 5)/5;
  const stabF   = (stabAvg - 5)/5;

  let frag = 0.40 + chaosF*0.30 - stabF*0.25;
  return V20.clamp(frag, 0, 1);
};

V20.computeSDI = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);

  const gap = lamH - lamA;
  return V20.clamp(gap/2.5, -1, 1);
};

V20.computeMeta = function(det, chaosM, sdi){
  if(!det || !chaosM) return 0.5;
  const detGap   = det.pH - det.pA;
  const chaosGap = chaosM.pH - chaosM.pA;
  let meta = 1 - (Math.abs(detGap - chaosGap)*0.45 + Math.abs(sdi)*0.20);
  return V20.clamp(meta, 0, 1);
};

V20.computeFlow = function(ctx, home, away, tact, pat){
  ctx  = ctx  || {};
  home = home || {momentum:5};
  away = away || {momentum:5};
  tact = tact || {home:{pressIntensity:5}, away:{pressIntensity:5}};
  pat  = pat  || {swing:0.25, chaotic:0.25};

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const mg = momH - momA;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;
  const pg = pressH - pressA;

  let flow = mg*0.10 + pg*0.08;
  flow += (pat.swing*0.10 + pat.chaotic*0.06) * (mg/7);

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  flow += chaosF*0.05 + tempoF*0.03;

  return V20.clamp(flow, -1, 1);
};

V20.computeMomentumSwing = function(home, away){
  home = home || {momentum:5};
  away = away || {momentum:5};
  const mH = home.momentum || 5;
  const mA = away.momentum || 5;
  const base = (mH - mA)/10;
  return V20.clamp(base*1.1, -1, 1);
};
// =============================================================
// Singularity Zero — final correction
// =============================================================
V20.singularityZero = function(raw, risk, frag, meta, flow, swing){
  raw = raw || {};
  let pH = raw.pH || 0.33;
  let pD = raw.pD || 0.33;
  let pA = raw.pA || 0.33;

  const riskF = risk;
  const fragF = frag;
  const metaF = meta;

  const lowMeta  = 1 - metaF;
  const highRisk = riskF;
  const highFrag = fragF;

  const compress = 0.50 + lowMeta*0.35 + highRisk*0.30 + highFrag*0.30;
  const comp = V20.clamp(compress, 0, 0.99);

  let center = (pH + pA)/2;
  pH = center + (pH-center)*(1-comp);
  pA = center + (pA-center)*(1-comp);

  pH *= (1 + flow*0.14 + swing*0.10);
  pA *= (1 - flow*0.14 - swing*0.10);

  // incorporate MVI -> increase draw when momentum unstable
  try {
    const advG = (typeof window !== "undefined" && window._V20_ADV) ? window._V20_ADV : null;
    if (advG && advG.MVI){
      const mvi = advG.MVI;
      pD += mvi * 0.12;
      pH *= (1 - mvi*0.06);
      pA *= (1 - mvi*0.06);
    }
  } catch(e){}

  const floor = 0.06;
  const addD  = Math.abs(pH - pA)*0.22;
  pD += addD;

  pH = Math.max(pH - pD*0.10, floor);
  pA = Math.max(pA - pD*0.10, floor);
  pD = Math.max(pD, floor);

  let s = pH + pD + pA;
  pH/=s; pD/=s; pA/=s;

  if(flow > 0 && swing > 0){
    pH *= (1 + 0.07*flow + 0.05*swing);
    pA *= (1 - 0.07*flow - 0.05*swing);
  } else if(flow < 0 && swing < 0){
    pA *= (1 + 0.07*(-flow) + 0.05*(-swing));
    pH *= (1 - 0.07*(-flow) - 0.05*(-swing));
  }

  let s2 = pH + pD + pA;
  pH/=s2; pD/=s2; pA/=s2;

  return {pH,pD,pA};
};

// =============================================================
// Fuse outputs
// =============================================================
V20.fuseOutputs = function(det, chaosM, mc, zero){
  return {
    raw:{
      deterministic: det,
      chaos: chaosM,
      mc: mc
    },
    final:{
      pH: zero.pH,
      pD: zero.pD,
      pA: zero.pA
    }
  };
};

// =============================================================
// AUTO-CALC / AUTO-ESTIMATE-PPDA / AUTO-FILL-TCI
// =============================================================
V20.autoCalcRequired = function(){
  const outEl = document.getElementById('output');
const xgH   = V20.num(document.getElementById('adv_xg_home').value, NaN);
  const xgA   = V20.num(document.getElementById('adv_xg_away').value, NaN);
  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);

  const fHw = V20.num(document.getElementById('adv_form_home_w').value, 0);
  const fHd = V20.num(document.getElementById('adv_form_home_d').value, 0);
  const fHl = V20.num(document.getElementById('adv_form_home_l').value, 0);

  const fAw = V20.num(document.getElementById('adv_form_away_w').value, 0);
  const fAd = V20.num(document.getElementById('adv_form_away_d').value, 0);
  const fAl = V20.num(document.getElementById('adv_form_away_l').value, 0);

  const ppdaH = V20.num(document.getElementById('adv_ppda_home').value, NaN);
  const ppdaA = V20.num(document.getElementById('adv_ppda_away').value, NaN);

  const errH  = V20.num(document.getElementById('adv_err_home').value, 0);
  const errA  = V20.num(document.getElementById('adv_err_away').value, 0);

  const formH = V20.num(document.getElementById('adv_formasi_home').value, 1);
  const formA = V20.num(document.getElementById('adv_formasi_away').value, 1);

  // 1) lambda from xG + opponent xGA
  let lamH = 1.20;
  let lamA = 1.00;
  if (isFinite(xgH) && isFinite(xgaA)){
    lamH = 0.60 * xgH + 0.40 * xgaA;
  }
  if (isFinite(xgA) && isFinite(xgaH)){
    lamA = 0.60 * xgA + 0.40 * xgaH;
  }
  lamH = V20.clamp(lamH, 0.20, 4.50);
  lamA = V20.clamp(lamA, 0.20, 4.50);
  document.getElementById('lamH').value = lamH.toFixed(2);
  document.getElementById('lamA').value = lamA.toFixed(2);

  // 2) Momentum from WDL
  function calcMomentum(W,D,L){
    const total = W+D+L;
    if (total <= 0) return 5;
    const rawScore = (3*W + 1*D - 2*L) / (3*5);
    const norm = V20.clamp(0.5 + rawScore, 0, 1);
    return V20.clamp(1 + 9*norm, 1, 10);
  }
  const momH = calcMomentum(fHw,fHd,fHl);
  const momA = calcMomentum(fAw,fAd,fAl);
  document.getElementById('home_mom').value = momH.toFixed(1);
  document.getElementById('away_mom').value = momA.toFixed(1);

  // 3) Stability from xGA + error
  function calcStability(xga, err){
    if (!isFinite(xga)) xga = 1.2;
    const base = 8.0 - (xga-1.0)*2.5 - err*1.2;
    return V20.clamp(base, 1, 10);
  }
  const stH = calcStability(xgaH, errH);
  const stA = calcStability(xgaA, errA);
  document.getElementById('home_st').value = stH.toFixed(1);
  document.getElementById('away_st').value = stA.toFixed(1);

  // 4) Press from PPDA
  function calcPress(ppda){
    if (!isFinite(ppda)) return 5;
    const press = 11 - (ppda-4)*0.6;
    return V20.clamp(press, 1, 10);
  }
  const pressH = calcPress(ppdaH);
  const pressA = calcPress(ppdaA);
  document.getElementById('home_press').value = pressH.toFixed(1);
  document.getElementById('away_press').value = pressA.toFixed(1);

  // 5) Flex from formCount
  function calcFlex(formCount){
    if (formCount <= 1) return 0.20;
    if (formCount >= 3) return 0.80;
    return 0.50;
  }
  const flexH = calcFlex(formH);
  const flexA = calcFlex(formA);
  document.getElementById('home_flex').value = flexH.toFixed(2);
  document.getElementById('away_flex').value = flexA.toFixed(2);

  // --- New computed indices ---
  const adv = { ppdaH: ppdaH, ppdaA: ppdaA, errH: errH, errA: errA };
  const DCI = V20.computeDCI(null,null,adv);
  const ACI_H = V20.computeACI(V20.num(document.getElementById('adv_xg_eff_home').value, 1.0));
  const ACI_A = V20.computeACI(V20.num(document.getElementById('adv_xg_eff_away').value, 1.0));

  const MVI_H = V20.computeMVI(fHw,fHd,fHl);
  const MVI_A = V20.computeMVI(fAw,fAd,fAl);
  const MVI = Math.max(MVI_H, MVI_A);

  const fma = V20.fmaLookup((document.getElementById('adv_forma_home')||{}).value, (document.getElementById('adv_forma_away')||{}).value);

  const lateH = V20.num(document.getElementById('adv_late_home').value, 5);
  const lateA = V20.num(document.getElementById('adv_late_away').value, 5);

  window._V20_ADV = { DCI, ACI_H, ACI_A, MVI, fma, lateH, lateA, MVI_H, MVI_A };
  window._V20_ADV.DCI = DCI; window._V20_ADV.ACI_H = ACI_H; window._V20_ADV.ACI_A = ACI_A; window._V20_ADV.MVI = MVI;
  window._V20_ADV.fma = fma; window._V20_ADV.lateH = lateH; window._V20_ADV.lateA = lateA;
// Log
  if (outEl){
    let log = "";
    log += "[AUTO-CALC INPUT WAJIB — ADVANCED MODE]\n";
    log += `λH : ${lamH.toFixed(3)} | λA : ${lamA.toFixed(3)}\n`;
    log += `Momentum H/A : ${momH.toFixed(1)} / ${momA.toFixed(1)}\n`;
    log += `Stability H/A: ${stH.toFixed(1)} / ${stA.toFixed(1)}\n`;
    log += `Press H/A    : ${pressH.toFixed(1)} / ${pressA.toFixed(1)}\n`;
    log += `Flex H/A     : ${flexH.toFixed(2)} / ${flexA.toFixed(2)}\n`;
    log += `[AUTO-EXTRA] DCI_H:${DCI.home.toFixed(2)} DCI_A:${DCI.away.toFixed(2)} | ACI_H:${ACI_H.toFixed(2)} ACI_A:${ACI_A.toFixed(2)}\n`;
    log += `[AUTO-EXTRA] MVI:${MVI.toFixed(3)} | FMA:${fma.toFixed(3)} | LateH:${lateH} LateA:${lateA}\n\n`;
    outEl.value = log + (outEl.value || "");
  }

  alert("Auto-calc selesai. Input utama sudah terisi.");
};

// -------------------------------------------------------------
// AUTO-ESTIMATE PPDA
// -------------------------------------------------------------
V20.autoEstimatePPDA = function(){
  const outEl = document.getElementById('output');

  const styleH = (document.getElementById('press_style_home') || {}).value || "";
  const styleA = (document.getElementById('press_style_away') || {}).value || "";

  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);
  const errH  = V20.num(document.getElementById('adv_err_home').value, NaN);
  const errA  = V20.num(document.getElementById('adv_err_away').value, NaN);

  function basePPDA(style){
    switch(style){
      case "high":     return 6.5;
      case "mid_high": return 9.0;
      case "mid":      return 12.0;
      case "mid_low":  return 15.0;
      case "low":      return 18.0;
      default:         return 12.0;
    }
  }

  function refine(ppda, xga, err){
    let v = ppda;
    if (isFinite(xga)){
      if (xga < 1.0)      v -= 0.8;
      else if (xga > 1.6) v += 0.8;
    }
    if (isFinite(err)){
      if (err > 1.0) v += 0.8;
      else if (err < 0.5) v -= 0.4;
    }
    return V20.clamp(v, 4.0, 22.0);
  }

  let ppdaH = basePPDA(styleH || "mid");
  let ppdaA = basePPDA(styleA || "mid");

  ppdaH = refine(ppdaH, xgaH, errH);
  ppdaA = refine(ppdaA, xgaA, errA);

  const elH = document.getElementById('adv_ppda_home');
  const elA = document.getElementById('adv_ppda_away');

  if (elH) elH.value = ppdaH.toFixed(2);
  if (elA) elA.value = ppdaA.toFixed(2);

  if (outEl){
    let log = "[AUTO-ESTIMATE PPDA]\n";
    log += `PPDA Home (est) : ${ppdaH.toFixed(2)}\n`;
    log += `PPDA Away (est) : ${ppdaA.toFixed(2)}\n`;
    outEl.value = log + (outEl.value || "");
  }

  alert("Estimasi PPDA selesai. PPDA Home/Away sudah terisi.");
};
// -------------------------------------------------------------
// AUTO-FILL TEMPO/CHAOS/IMPORTANCE
// -------------------------------------------------------------
V20.autoFillTCI = function(){
  const outEl = document.getElementById('output');

  const xgH   = V20.num(document.getElementById('adv_xg_home').value, NaN);
  const xgA   = V20.num(document.getElementById('adv_xg_away').value, NaN);
  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);

  const ppdaH = V20.num(document.getElementById('adv_ppda_home').value, NaN);
  const ppdaA = V20.num(document.getElementById('adv_ppda_away').value, NaN);

  const errH  = V20.num(document.getElementById('adv_err_home').value, NaN);
  const errA  = V20.num(document.getElementById('adv_err_away').value, NaN);

  const matchType  = (document.getElementById('auto_match_type')  || {}).value || "";
  const matchStyle = (document.getElementById('auto_match_style') || {}).value || "";

  let tempo = 5; let chaos = 5; let importance = 5;

  switch (matchType){
    case "friendly": importance = 2.5; tempo -= 0.5; chaos -= 0.5; break;
    case "league_normal": importance = 4.5; break;
    case "big_match": importance = 6.5; tempo += 0.5; break;
    case "derby": importance = 8.0; tempo += 0.8; chaos += 1.0; break;
    case "final": importance = 9.5; tempo += 0.5; chaos += 0.8; break;
    default: importance = 5.0;
  }

  switch (matchStyle){
    case "slow_structured": tempo -= 1.5; chaos -= 1.5; break;
    case "balanced": break;
    case "fast_open": tempo += 1.5; chaos += 1.0; break;
    case "wild": tempo += 2.0; chaos += 2.2; break;
  }

  let avgXg = NaN;
  if (isFinite(xgH) && isFinite(xgA)){
    avgXg = (xgH + xgA)/2;
    tempo += (avgXg - 1.5) * 1.5;
    chaos += (avgXg - 1.5) * 1.0;
  }

  let avgPPDA = NaN;
  if (isFinite(ppdaH) && isFinite(ppdaA)){
    avgPPDA = (ppdaH + ppdaA)/2;
    if (avgPPDA <= 8){ tempo += 1.0; chaos += 1.4; }
    else if (avgPPDA <= 11){ tempo += 0.3; chaos += 0.6; }
    else if (avgPPDA >= 16){ tempo -= 0.7; chaos -= 0.7; }
  }

  let avgErr = NaN;
  if (isFinite(errH) && isFinite(errA)){
    avgErr = (errH + errA)/2;
    chaos += avgErr * 0.5;
  }

  tempo      = V20.clamp(tempo, 1, 10);
  chaos      = V20.clamp(chaos, 1, 10);
  importance = V20.clamp(importance, 1, 10);

  const tempoEl = document.getElementById('tempo');
  const chaosEl = document.getElementById('chaos');
  const impEl   = document.getElementById('importance');

  if (tempoEl) tempoEl.value = tempo.toFixed(1);
  if (chaosEl) chaosEl.value = chaos.toFixed(1);
  if (impEl)   impEl.value   = importance.toFixed(1);

  if (outEl){
    let log = "[AUTO-FILL TEMPO / CHAOS / IMPORTANCE]\n";
    log += `Tempo       : ${tempo.toFixed(1)}\n`;
    log += `Chaos       : ${chaos.toFixed(1)}\n`;
    log += `Importance  : ${importance.toFixed(1)}\n`;
    if (isFinite(avgXg))   log += `avg xG      : ${avgXg.toFixed(2)}\n`;
    if (isFinite(avgPPDA)) log += `avg PPDA    : ${avgPPDA.toFixed(2)}\n`;
    if (isFinite(avgErr))  log += `avg Error   : ${avgErr.toFixed(2)}\n`;
    log += "\n";
    outEl.value = log + (outEl.value || "");
  }

  alert("Auto-fill Tempo / Chaos / Importance selesai.");
};

// =============================================================
// Uncertainty & BTTS
// =============================================================
V20.computeUncertainty = function(pH,pD,pA){
  const probs = [pH,pD,pA];
  let entropy = 0;
  probs.forEach(p=>{
    if (p>0) entropy -= p*Math.log2(p);
  });
  const maxE = Math.log2(3);
  const norm = maxE>0 ? entropy/maxE : 0;
  return { entropy, norm, score: norm*100 };
};

V20.computeBTTS = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.0001);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.0001);

  const pH0 = Math.exp(-lamH);
  const pA0 = Math.exp(-lamA);
  const p00 = Math.exp(-(lamH+lamA));
  const pBTTS = 1 - (pH0 + pA0 - p00);
  return V20.clamp(pBTTS, 0, 1);
};
// =============================================================
// Engine Runner — PRIME SINGULARITY ZERO
// =============================================================
V20.runPrimeZero = function(){
  const outEl = document.getElementById('output');
  if (!outEl) return;

  // read inputs
  const lamH  = V20.num(document.getElementById('lamH').value, 1.20);
  const lamA  = V20.num(document.getElementById('lamA').value, 1.00);

  const tempo = V20.num(document.getElementById('tempo').value, 5);
  const chaos = V20.num(document.getElementById('chaos').value, 5);
  const importance = V20.num(document.getElementById('importance').value, 5);

  const home_st  = V20.num(document.getElementById('home_st').value, 5);
  const away_st  = V20.num(document.getElementById('away_st').value, 5);
  const home_mom = V20.num(document.getElementById('home_mom').value, 5);
  const away_mom = V20.num(document.getElementById('away_mom').value, 5);

  const home_press = V20.num(document.getElementById('home_press').value, 5);
  const away_press = V20.num(document.getElementById('away_press').value, 5);
  const home_flex  = V20.num(document.getElementById('home_flex').value, 0.5);
  const away_flex  = V20.num(document.getElementById('away_flex').value, 0.5);

  let simCount  = V20.num(document.getElementById('simCount') ? document.getElementById('simCount').value : undefined, NaN);
  let scoreCap  = V20.num(document.getElementById('scoreCap') ? document.getElementById('scoreCap').value : undefined, NaN);
  if (!isFinite(simCount)) simCount = undefined;
  if (!isFinite(scoreCap)) scoreCap = undefined;

  const lambda = { lamH, lamA };
  const ctx = { tempo, chaos, importance };
  const home = { stability: home_st, momentum: home_mom };
  const away = { stability: away_st, momentum: away_mom };
  const tact = { home: { pressIntensity: home_press, flex: home_flex }, away: { pressIntensity: away_press, flex: away_flex } };

  // models
  const det       = V20.detSim(lambda);
  const chaosL    = V20.chaosModel(lambda, ctx);
  const detChaos  = V20.detSim(chaosL);
  const mc        = V20.monteCarlo(lambda, ctx, simCount, scoreCap, home, away, tact);

  const godHL  = mc.god && mc.god.hyperLambda ? mc.god.hyperLambda : {lamH, lamA};
  const godPat = mc.god && mc.god.pattern ? mc.god.pattern : {control:0.25,swing:0.25,stalled:0.25,chaotic:0.25};

  const base = {
    pH: (det.pH + detChaos.pH + mc.pH)/3,
    pD: (det.pD + detChaos.pD + mc.pD)/3,
    pA: (det.pA + detChaos.pA + mc.pA)/3
  };

  // advanced metrics
  const risk01   = V20.computeRisk(ctx, tact);
  const frag01   = V20.computeFragility(ctx, home, away);
  const sdi      = V20.computeSDI(godHL);
  const meta01   = V20.computeMeta(det, detChaos, sdi);
  const flowVal  = V20.computeFlow(ctx, home, away, tact, godPat);
  const swingVal = V20.computeMomentumSwing(home, away);

  const zeroProb = V20.singularityZero(base, risk01, frag01, meta01, flowVal, swingVal);
  const fused    = V20.fuseOutputs(det, detChaos, mc, zeroProb);

  const unc   = V20.computeUncertainty(fused.final.pH, fused.final.pD, fused.final.pA);
  const btts  = V20.computeBTTS(godHL);

  const riskScore = risk01*100;
  const fragScore = frag01*100;
  const metaScore = meta01*100;

  let engineStatus = "PRIME STABLE";
  if (metaScore < 40 || riskScore > 70 || fragScore > 70){
    engineStatus = "PRIME CAUTION";
  } else if (metaScore < 60){
    engineStatus = "PRIME NEUTRAL";
  }

  // OU blend analytic + MC
  const totalLamBase = godHL.lamH + godHL.lamA;
  let lamEff = totalLamBase;
  const chaosF_local = (chaos - 5)/5;
  const tempoF_local = (tempo - 5)/5;
  lamEff *= (1 + chaosF_local*0.10 + tempoF_local*0.05);
  lamEff = V20.clamp(lamEff, 0.5, 5.8);

  const lines = [0.5,1.5,2.5,3.5];
  const ouAn = {};
  const ouMC = {};
  const ou   = {};

  lines.forEach(line=>{
    const cut = Math.floor(line);
    let under=0;
    for(let k=0;k<=cut;k++){
      under += V20.poissonPMF(lamEff,k);
    }
    ouAn[line] = {under, over:1-under};
  });
// MC OU from matrix
  const mat = mc.matrix;
  const cap = mc.scoreCap;
  lines.forEach(line=>{
    const cut = Math.floor(line);
    let under=0, over=0;
    for(let h=0;h<=cap;h++){
      for(let a=0;a<=cap;a++){
        const sum = h+a;
        const freq = (mat[h] && mat[h][a]) ? mat[h][a] : 0;
        if(sum<=cut) under += freq;
        else over += freq;
      }
    }
    ouMC[line] = { under: under/mc.simCount, over: over/mc.simCount };
  });

  // blend OU with patternChaos weight
  const patternChaos = godPat.chaotic + godPat.swing*0.6;
  const wMC = 0.40 + 0.40*Math.max(0,patternChaos);
  const wAN = 1 - wMC;

  lines.forEach(line=>{
    ou[line] = { over: ouAn[line].over*wAN + ouMC[line].over*wMC, under: ouAn[line].under*wAN + ouMC[line].under*wMC };
  });

  // Build output text
  let text = "";
  text += "=== MATCH SIMULATION REPORT — PRIME SINGULARITY ZERO ∑.REBUILD ===\n\n";

  text += "[ENGINE STATUS]\n";
  text += `Status  : ${engineStatus}\n\n`;

  text += "[INPUT]\n";
  text += `λH (input) : ${lamH.toFixed(3)}\n`;
  text += `λA (input) : ${lamA.toFixed(3)}\n`;
  text += `Tempo       : ${tempo.toFixed(1)}\n`;
  text += `Chaos       : ${chaos.toFixed(1)}\n`;
  text += `Importance  : ${importance.toFixed(1)}\n`;
  text += `Home Stab   : ${home_st.toFixed(1)} | Mom: ${home_mom.toFixed(1)}\n`;
  text += `Away Stab   : ${away_st.toFixed(1)} | Mom: ${away_mom.toFixed(1)}\n`;
  text += `Press H/A   : ${home_press.toFixed(1)} / ${away_press.toFixed(1)}\n`;
  text += `Flex  H/A   : ${home_flex.toFixed(2)} / ${away_flex.toFixed(2)}\n`;
  text += `SimCount    : ${mc.simCount}\n`;
  text += `Score Cap   : ${mc.scoreCap}\n\n`;

  text += "[GOD HYPER LAMBDA]\n";
  text += `λH (Hyper) : ${mc.god.hyperLambda.lamH.toFixed(3)}\n`;
  text += `λA (Hyper) : ${mc.god.hyperLambda.lamA.toFixed(3)}\n\n`;

  text += "[PATTERN ORACLE]\n";
  text += `Control : ${(mc.god.pattern.control*100).toFixed(1)}%\n`;
  text += `Swing   : ${(mc.god.pattern.swing*100).toFixed(1)}%\n`;
  text += `Stalled : ${(mc.god.pattern.stalled*100).toFixed(1)}%\n`;
  text += `Chaotic : ${(mc.god.pattern.chaotic*100).toFixed(1)}%\n\n`;

  text += "[1X2 PROBABILITIES — PRIME SINGULARITY ZERO]\n";
  text += `Home Win : ${(fused.final.pH*100).toFixed(1)}%\n`;
  text += `Draw     : ${(fused.final.pD*100).toFixed(1)}%\n`;
  text += `Away Win : ${(fused.final.pA*100).toFixed(1)}%\n\n`;

  text += "[RISK / FRAGILITY / META / UNCERTAINTY]\n";
  text += `Risk Index        : ${riskScore.toFixed(1)} / 100\n`;
  text += `Fragility Index   : ${fragScore.toFixed(1)} / 100\n`;
  text += `Meta-Consistency  : ${metaScore.toFixed(1)} / 100\n`;
  text += `Uncertainty (1X2) : ${unc.score.toFixed(1)} / 100\n`;
  text += `Flow Value        : ${flowVal.toFixed(3)}\n`;
  text += `Momentum Swing    : ${swingVal.toFixed(3)}\n\n`;

  text += "[GOAL MODEL]\n";
  text += `Avg Goals (MC)       : ${mc.avgGoals.toFixed(3)}\n`;
  text += `BTTS (kedua tim gol) : ${(btts*100).toFixed(1)}%\n\n`;

  text += "[OVER/UNDER (Blend MC + Analytic)]\n";
  ["0.5","1.5","2.5","3.5"].forEach(k=>{
    const o = ou[k] || {over:0,under:0};
    text += `O/U ${k}  -> Over: ${(o.over*100).toFixed(1)}% | Under: ${(o.under*100).toFixed(1)}%\n`;
  });
  text += "\n";

  text += "[SCENARIO DISTRIBUTION]\n";
  if (mc.scenarioStats && mc.scenarioStats.scenarios){
    mc.scenarioStats.scenarios.forEach(s=>{
      text += ` - ${s.name} : ${(s.p*100).toFixed(1)}%\n`;
    });
    text += "\n";
  }

  // append additional adv info if present
  if (window._V20_ADV){
    const adv = window._V20_ADV;
    text += "[ADVANCED INDICES]\n";
    if (adv.DCI) text += `DCI H/A : ${adv.DCI.home.toFixed(2)} / ${adv.DCI.away.toFixed(2)}\n`;
    if (adv.ACI_H) text += `ACI H/A : ${adv.ACI_H.toFixed(2)} / ${adv.ACI_A.toFixed(2)}\n`;
    if (adv.MVI) text += `MVI : ${adv.MVI.toFixed(3)}\n`;
    if (adv.fma) text += `FMA : ${adv.fma.toFixed(3)}\n\n`;
  }

  outEl.value = text;
}; // end runPrimeZero

// Hook buttons (if present)
document.addEventListener('DOMContentLoaded', function(){
  const btn_auto_calc = document.getElementById('btn_auto_calc');
  if(btn_auto_calc) btn_auto_calc.addEventListener('click', V20.autoCalcRequired);

  const btn_auto_ppda = document.getElementById('btn_auto_ppda');
  if(btn_auto_ppda) btn_auto_ppda.addEventListener('click', V20.autoEstimatePPDA);

  const btn_auto_tci = document.getElementById('btn_auto_tci');
  if(btn_auto_tci) btn_auto_tci.addEventListener('click', V20.autoFillTCI);

  const runBtn = document.getElementById('btn_analyze');
  if(runBtn) runBtn.addEventListener('click', V20.runPrimeZero);
});
</script>
<!-- END PART 2 -->
<!-- ============================================= -->
<!-- PART 3 — MATCH TYPE SYSTEM + FINAL PATCHES -->
<!-- ============================================= -->

<div class="section">
  <h2>Match Type System — Extended</h2>

  <label>Pilih Match Type</label>
  <select id="match_type_expanded">
    <option value="">-- PILIH MATCH TYPE --</option>

    <optgroup label="Top 5 Europe">
      <option value="epl">Premier League</option>
      <option value="laliga">La Liga</option>
      <option value="seriea">Serie A</option>
      <option value="bundesliga">Bundesliga</option>
      <option value="ligue1">Ligue 1</option>
    </optgroup>

    <optgroup label="Mid / Other Leagues">
      <option value="eredivisie">Eredivisie</option>
      <option value="portugal">Liga Portugal</option>
      <option value="mls">MLS</option>
      <option value="kleague">K-League</option>
      <option value="jleague">J1 League</option>
    </optgroup>

    <optgroup label="European Cups">
      <option value="ucl_group">UCL Group Stage</option>
      <option value="ucl_knockout">UCL Knockout</option>
      <option value="uefa_final">UCL Final</option>
      <option value="uel">Europa League</option>
      <option value="uecl">Conference League</option>
    </optgroup>

    <optgroup label="Domestic Cups">
      <option value="domestic_cup_early">Domestic Cup Early</option>
      <option value="domestic_cup_final">Domestic Cup Final</option>
      <option value="supercup">Super Cup</option>
    </optgroup>

    <optgroup label="International Competitions">
      <option value="wc_group">World Cup / Euro Group</option>
      <option value="wc_knockout">World Cup / Euro Knockout</option>
      <option value="wc_quals">World Cup Qualifiers</option>
    </optgroup>

    <optgroup label="Contextual Matches">
      <option value="derby_lvl1">Derby Level 1 (City Rivalry)</option>
      <option value="derby_lvl2">Derby Level 2 (Historical Rivalry)</option>
      <option value="title_decider">Title Decider</option>
      <option value="relegation_fight">Relegation Battle</option>
      <option value="dead_rubber">Dead Rubber</option>
      <option value="friendly">Friendly</option>
    </optgroup>

    <optgroup label="Special Conditions">
      <option value="altitude">High Altitude Match</option>
      <option value="extreme_weather">Extreme Weather</option>
      <option value="long_travel">Long Travel / Jetlag</option>
    </optgroup>

  </select>

  <div style="margin-top:8px">
    <button id="apply_match_type">APPLY MATCH TYPE</button>
    <button id="export_match_config" class="secondary">EXPORT CONFIG</button>
    <button id="stop_error_loop" style="display:none;background:#ff3333;color:white;">STOP ERRORS</button>
  </div>
</div>

<script>
// =============================================================
// MATCH TYPE TEMPLATES
// =============================================================
(function(){
  const templates = {

    // ---------------------------
    // TOP 5 LEAGUES
    // ---------------------------
    epl: { tempo:6, chaos:5.5, importance:5,
      patternBias:{control:0, swing:0.03, stalled:-0.02, chaotic:0.03},
      finishingBias:1.02, pressingBias:0.10, variance:1.05 },

    laliga: { tempo:5.8, chaos:5.2, importance:5,
      patternBias:{control:0.01, swing:0.01, stalled:-0.01, chaotic:0.02},
      finishingBias:1.03, pressingBias:0.05, variance:1.02 },

    seriea: { tempo:5.2, chaos:4.8, importance:5,
      patternBias:{control:0.03, swing:-0.01, stalled:0.01, chaotic:-0.01},
      finishingBias:0.98, pressingBias:-0.05, variance:0.95 },

    bundesliga: { tempo:6.3, chaos:5.8, importance:5,
      patternBias:{control:-0.02, swing:0.03, stalled:-0.02, chaotic:0.04},
      finishingBias:1.04, pressingBias:0.30, variance:1.15 },

    ligue1: { tempo:5.6, chaos:5.0, importance:5,
      patternBias:{control:0, swing:0.02, stalled:-0.01, chaotic:0.02},
      finishingBias:1.00, pressingBias:0.05, variance:1.02 },

    // ---------------------------
    // MID / OTHER
    // ---------------------------
    eredivisie:{ tempo:6.2, chaos:6.1, importance:5,
      patternBias:{control:-0.01, swing:0.04, stalled:-0.02, chaotic:0.05},
      finishingBias:1.05, pressingBias:0.15, variance:1.20 },

    portugal:{ tempo:5.5, chaos:5.3, importance:5,
      patternBias:{control:0.02, swing:0.01, stalled:0, chaotic:0.01},
      finishingBias:1.03, pressingBias:0.08, variance:1.05 },

    kleague:{ tempo:5.7, chaos:5.8, importance:5,
      patternBias:{control:0.01, swing:0.03, stalled:-0.01, chaotic:0.04},
      finishingBias:1.02, pressingBias:0.12, variance:1.15 },

    jleague:{ tempo:6.0, chaos:6.4, importance:5,
      patternBias:{control:0, swing:0.05, stalled:-0.02, chaotic:0.06},
      finishingBias:1.03, pressingBias:0.20, variance:1.20 },

    mls:{ tempo:6.4, chaos:7.0, importance:5,
      patternBias:{control:-0.02, swing:0.06, stalled:-0.03, chaotic:0.10},
      finishingBias:1.04, pressingBias:0.18, variance:1.35 },

    // ---------------------------
    // EUROPEAN CUPS
    // ---------------------------
    ucl_group:{ tempo:6, chaos:5.4, importance:6,
      patternBias:{control:0.01, swing:0.02, stalled:-0.01, chaotic:0.02},
      finishingBias:1.04, pressingBias:0.15, variance:1.06 },

    ucl_knockout:{ tempo:5.4, chaos:5.6, importance:8,
      patternBias:{control:0.05, swing:-0.02, stalled:0.03, chaotic:-0.02},
      finishingBias:1.02, pressingBias:0.10, variance:1.12 },

    uefa_final:{ tempo:5.4, chaos:5.2, importance:9.3,
      patternBias:{control:0.06, swing:-0.04, stalled:0.03, chaotic:-0.02},
      finishingBias:1.03, pressingBias:0.15, variance:1.12 },

    uel:{ tempo:6.1, chaos:6.3, importance:6,
      patternBias:{control:-0.01, swing:0.04, stalled:-0.02, chaotic:0.05},
      finishingBias:1.04, pressingBias:0.10, variance:1.20 },

    uecl:{ tempo:6.3, chaos:6.6, importance:5.5,
      patternBias:{control:-0.02, swing:0.05, stalled:-0.02, chaotic:0.06},
      finishingBias:1.04, pressingBias:0.10, variance:1.25 },

    // ---------------------------
    // DOMESTIC CUPS
    // ---------------------------
    domestic_cup_early:{
      tempo:5.4, chaos:6.2, importance:3.5,
      patternBias:{control:-0.03, swing:0.04, stalled:-0.03, chaotic:0.08},
      finishingBias:0.98, pressingBias:0, variance:1.30 },

    domestic_cup_final:{
      tempo:5.9, chaos:5.5, importance:8.6,
      patternBias:{control:0.03, swing:0.01, stalled:0.03, chaotic:0.02},
      finishingBias:1.03, pressingBias:0.15, variance:1.10 },

    supercup:{
      tempo:6.0, chaos:5.8, importance:6,
      patternBias:{control:0.01, swing:0.02, stalled:-0.01, chaotic:0.03},
      finishingBias:1.03, pressingBias:0.12, variance:1.15 },

    // ---------------------------
    // INTERNATIONAL
    // ---------------------------
    wc_group:{ tempo:5.2, chaos:4.9, importance:7,
      patternBias:{control:0.04, swing:0, stalled:0.02, chaotic:-0.01},
      finishingBias:1.02, pressingBias:0.06, variance:1.05 },

    wc_knockout:{ tempo:5.0, chaos:5.3, importance:9.4,
      patternBias:{control:0.06, swing:-0.02, stalled:0.03, chaotic:-0.02},
      finishingBias:1.02, pressingBias:0.08, variance:1.10 },

    wc_quals:{ tempo:5.8, chaos:6.3, importance:6,
      patternBias:{control:-0.02, swing:0.02, stalled:-0.01, chaotic:0.05},
      finishingBias:1.01, pressingBias:0.05, variance:1.20 },

    // ---------------------------
    // CONTEXT MATCHES
    // ---------------------------
    derby_lvl1:{
      tempo:6.6, chaos:7.2, importance:8.8,
      patternBias:{control:-0.04, swing:0.10, stalled:-0.03, chaotic:0.12},
      finishingBias:1.05, pressingBias:0.35, variance:1.45 },

    derby_lvl2:{
      tempo:6.4, chaos:7.8, importance:9.4,
      patternBias:{control:-0.06, swing:0.14, stalled:-0.04, chaotic:0.15},
      finishingBias:1.07, pressingBias:0.40, variance:1.55 },

    title_decider:{
      tempo:5.5, chaos:5.0, importance:9.6,
      patternBias:{control:0.07, swing:-0.03, stalled:0.04, chaotic:-0.02},
      finishingBias:1.03, pressingBias:0.25, variance:1.20 },

    relegation_fight:{
      tempo:6.1, chaos:6.8, importance:9.7,
      patternBias:{control:-0.03, swing:0.08, stalled:-0.02, chaotic:0.06},
      finishingBias:1.01, pressingBias:0.25, variance:1.40 },

    dead_rubber:{
      tempo:4.4, chaos:4.8, importance:2,
      patternBias:{control:0.03, swing:-0.03, stalled:0.03, chaotic:-0.02},
      finishingBias:0.96, pressingBias:-0.20, variance:0.85 },

    friendly:{
      tempo:4.2, chaos:4.0, importance:2.2,
      patternBias:{control:0.02, swing:-0.02, stalled:0.02, chaotic:-0.02},
      finishingBias:0.95, pressingBias:-0.2, variance:0.9 },

    // ---------------------------
    // SPECIAL CONDITIONS
    // ---------------------------
    altitude:{
      tempo:4.4, chaos:5.8, importance:5,
      patternBias:{control:0, swing:0, stalled:0.1, chaotic:0.05},
      finishingBias:0.94, pressingBias:-0.15, variance:1.20 },

    extreme_weather:{
      tempo:3.8, chaos:6.8, importance:5.8,
      patternBias:{control:-0.03, swing:0.02, stalled:0.04, chaotic:0.12},
      finishingBias:0.92, pressingBias:-0.10, variance:1.30 },

    long_travel:{
      tempo:4.6, chaos:5.3, importance:5,
      patternBias:{control:0.03, swing:-0.02, stalled:0.03, chaotic:-0.01},
      finishingBias:0.97, pressingBias:-0.15, variance:1.12 }
  };

  window._V20_MATCH_TEMPLATES = templates;

  // -------------------------------------------
  // APPLY TEMPLATE
  // -------------------------------------------
  function applyTemplate(key){
    const t = templates[key];
    if(!t) return;

    // Fill TCI
    document.getElementById("tempo").value       = t.tempo.toFixed(1);
    document.getElementById("chaos").value       = t.chaos.toFixed(1);
    document.getElementById("importance").value  = t.importance.toFixed(1);

    window._V20_MATCH_TEMPLATE = t;

    const out = document.getElementById("output");
    if(out){
      out.value = `[MATCH TYPE SET] ${key}\n` + out.value;
    }
  }

  const btn = document.getElementById("apply_match_type");
  if(btn){
    btn.addEventListener("click", ()=>{
      const sel = document.getElementById("match_type_expanded").value;
      if(!sel) return alert("Pilih Match Type dulu.");
      applyTemplate(sel);
    });
  }

  // -------------------------------------------
  // EXPORT CONFIG (with error-loop safety)
  // -------------------------------------------
  let errorLoop = null;

  function stopErrors(){
    if(errorLoop){ clearInterval(errorLoop); errorLoop=null; }
    document.getElementById("stop_error_loop").style.display="none";
  }

  document.getElementById("stop_error_loop").addEventListener("click", stopErrors);

  document.getElementById("export_match_config").addEventListener("click", ()=>{
    try{
      const cfg = {
        matchType: document.getElementById("match_type_expanded").value,
        template: window._V20_MATCH_TEMPLATE || {},
        advanced: window._V20_ADV || {}
      };

      const dataUri = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(cfg,null,2));
      const a = document.createElement("a");
      a.href = dataUri;
      a.download = "match_config.json";
      a.dispatchEvent(new MouseEvent("click"));

      stopErrors();

    } catch(e){
      const out = document.getElementById("output");
      if(out){
        out.value = "[EXPORT ERROR] Download gagal. Mungkin browser memblokir.\n" + out.value;
      }
      document.getElementById("stop_error_loop").style.display="inline-block";

      if(!errorLoop){
        errorLoop = setInterval(()=>{
          const out2 = document.getElementById("output");
          if(out2){
            out2.value = "[EXPORT ERROR LOOP] Download masih gagal...\n" + out2.value;
          }
        },1200);
      }
    }
  });

})(); // end IIFE
</script>

<!-- ============================================= -->
<!-- OUTPUT AREA & RUN BUTTON -->
<!-- ============================================= -->
<div class="section">
  <h2>Output</h2>
  <textarea id="output"></textarea>
  <button id="btn_analyze">RUN ENGINE</button>
</div>

</body>
</html>

<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PSZ MAX v3.4 CLEAN — Final</title>

<!-- Improved, compact and readable UI styles -->
<style>
  :root{
    --bg-1:#04101a;
    --bg-2:#071a27;
    --card:#081827;
    --muted:#98a6b3;
    --accent-1:#06b6d4;
    --accent-2:#8b5cf6;
    --text:#e6eef6;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text); -webkit-font-smoothing:antialiased;}
  .wrap{max-width:1220px;margin:18px auto;padding:16px}
  header{display:flex;gap:12px;align-items:center}
  .logo{width:50px;height:50px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#05232f,#04384a); box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  h1{font-size:18px;margin:0}
  .sub{font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 460px;gap:12px;margin-top:14px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-radius:12px;padding:12px;box-shadow:0 8px 24px rgba(2,6,23,0.55);border:1px solid rgba(255,255,255,0.02)}
  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input,select,textarea,button{font-size:14px;border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);width:100%;box-sizing:border-box}
  textarea{min-height:84px;resize:vertical}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .col{flex:1;min-width:120px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button.primary{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));border:none;color:#021022;padding:10px 12px;cursor:pointer;border-radius:10px}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;cursor:pointer;border-radius:10px}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.025);font-size:12px}
  .prob-bar{height:12px;border-radius:8px;background:var(--glass);position:relative;overflow:hidden}
  .prob-fill{height:100%;position:absolute;left:0;top:0;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));width:0%}
  .cols-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  .muted{color:var(--muted)}
  footer{margin-top:14px;font-size:12px;color:var(--muted)}
  @media(max-width:1000px){ .grid{grid-template-columns:1fr} .cols-3{grid-template-columns:1fr} .logo{width:42px;height:42px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo" aria-hidden="true">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 2l3 6 6 .5-4.5 3.8L18 20l-6-3.5L6 20l1.5-7.7L3 8.5 9 8l3-6z" fill="currentColor"/></svg>
    </div>
    <div>
      <h1>Prime Singularity Zero — MAX v3.4 (FINAL)</h1>
      <div class="sub">Clean • Stable • All modules included • UI enhanced</div>
    </div>
  </header>

  <div class="grid" role="main" aria-label="Main interface">
    <!-- LEFT PANEL (inputs) will be here: MODULE 2 -->
<!-- LEFT PANEL : INPUTS -->
    <div class="card" id="left_panel">

      <!-- ========== BASIC TEAM INPUTS ========== -->
      <h3 style="margin:4px 0 8px 0;font-size:15px;">Team Settings</h3>
      <div class="row">
        <div class="col">
          <label>Home Team</label>
          <input id="home_team" placeholder="Contoh: Barcelona"/>
        </div>
        <div class="col">
          <label>Away Team</label>
          <input id="away_team" placeholder="Contoh: Real Madrid"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>λ Home</label>
          <input id="lamH" type="number" step="0.01" value="1.20"/>
        </div>
        <div class="col">
          <label>λ Away</label>
          <input id="lamA" type="number" step="0.01" value="1.00"/>
        </div>
      </div>

      <!-- ========== MATCH CONTEXT ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Match Context</h3>

      <div class="row">
        <div class="col">
          <label>Tempo</label>
          <input id="tempo" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Chaos</label>
          <input id="chaos" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Importance</label>
          <input id="importance" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <!-- ========== STABILITY & MOMENTUM ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Team Profile</h3>

      <div class="row">
        <div class="col">
          <label>Home Stability</label>
          <input id="home_st" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Stability</label>
          <input id="away_st" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Home Momentum</label>
          <input id="home_mom" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Momentum</label>
          <input id="away_mom" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <!-- ========== TACTICAL INPUTS ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Tactical Settings</h3>

      <div class="row">
        <div class="col">
          <label>Home Press</label>
          <input id="home_press" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Press</label>
          <input id="away_press" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Home Flex</label>
          <input id="home_flex" type="number" step="0.1" min="0" max="1" value="0.5"/>
        </div>
        <div class="col">
          <label>Away Flex</label>
          <input id="away_flex" type="number" step="0.1" min="0" max="1" value="0.5"/>
        </div>
      </div>

      <!-- ========== MATCH TYPE & WEATHER & REFEREE ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Environment</h3>

      <div class="row">
        <div class="col">
          <label>Match Type</label>
          <select id="match_type">
            <option value="normal">Normal Match</option>
            <option value="derby">Derby</option>
            <option value="relegation">Relegation Battle</option>
            <option value="title">Title Decider</option>
            <option value="cup">Cup Knockout</option>
            <option value="ucl">UCL Match</option>
            <option value="ucl_knockout">UCL Knockout</option>
          </select>
        </div>

        <div class="col">
          <label>Weather</label>
          <select id="weather">
            <option value="clear">Clear</option>
            <option value="rain">Rain</option>
            <option value="heavy_rain">Heavy Rain</option>
            <option value="snow">Snow</option>
          </select>
        </div>

        <div class="col">
          <label>Referee Strictness</label>
          <input id="ref_strict" type="number" min="1" max="10" value="5"/>
        </div>
      </div>
 <!-- ========== MONTE CARLO SETTINGS ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Simulation Settings</h3>

      <div class="row">
        <div class="col">
          <label>MC Sim Count</label>
          <input id="simCount" type="number" placeholder="ex: 5000"/>
        </div>
        <div class="col">
          <label>Score Cap</label>
          <input id="scoreCap" type="number" placeholder="ex: 8"/>
        </div>
      </div>

      <!-- ========== JSON CONFIG ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Load JSON Config</h3>
      <textarea id="json_config" placeholder='{"lamH":1.2,"lamA":1.0,...}'></textarea>

      <!-- BUTTONS -->
      <div class="controls">
        <button class="primary" id="btn_auto">AUTO INPUT (FULL)</button>
        <button class="ghost" id="btn_apply_mt">APPLY MATCH TYPE</button>
        <button class="primary" id="btn_run">RUN INTEGRATED</button>
      </div>

    </div>
    <!-- END LEFT PANEL -->
<!-- RIGHT PANEL : OUTPUTS -->
    <div class="card" id="right_panel">

      <h3 style="margin:4px 0 8px 0;font-size:15px;">Prediction Output</h3>

      <!-- OUTPUT TEXT AREA -->
      <label>Engine Report</label>
      <textarea id="output" readonly style="height:200px;"></textarea>

      <!-- PROBABILITY BARS -->
      <h3 style="margin-top:16px;font-size:15px;">Probability Bars</h3>

      <div class="cols-3">
        <div>
          <div class="small muted">Home</div>
          <div class="prob-bar"><div id="bar_home" class="prob-fill"></div></div>
        </div>
        <div>
          <div class="small muted">Draw</div>
          <div class="prob-bar"><div id="bar_draw" class="prob-fill"></div></div>
        </div>
        <div>
          <div class="small muted">Away</div>
          <div class="prob-bar"><div id="bar_away" class="prob-fill"></div></div>
        </div>
      </div>

      <!-- PROBABILITY WHEEL -->
      <h3 style="margin-top:18px;font-size:15px;">Probability Wheel</h3>
      <div id="prob_wheel" style="text-align:center;padding:10px;">
        <!-- Wheel SVG injected by JS (Module 9) -->
        <div class="muted small">No data yet</div>
      </div>

      <!-- EXTRA SPACE FOR NOTES / DNA / FLAGS -->
      <div id="extra_info" style="margin-top:16px;">
        <div class="badge">Engine v3.4 • Stable</div>
      </div>

    </div>
    <!-- END RIGHT PANEL -->
  </div> <!-- end grid -->

  <footer>
    PSZ MAX v3.4 — Clean Final Build • No duplicate modules • Stable Monte Carlo • UI Enhanced
  </footer>

<!-- SCRIPT SECTION STARTS BELOW (MODULES 4–10) -->
<script>
/* ============================================================
   MODULE 4 — CORE UTILITIES (clean, stable, no duplicates)
   ============================================================ */

const V20 = {};

/* ---------- SAFE NUMBER ---------- */
V20._safeNum = function(x, d=0){
  const v = Number(x);
  return isFinite(v) ? v : d;
};

/* ---------- CLAMP ---------- */
V20.clamp = function(v, min, max){
  return v < min ? min : (v > max ? max : v);
};

/* ---------- RANDOM UNIFORM [0,1) ---------- */
V20.rnd = function(){
  return Math.random();
};

/* ---------- POISSON PMF ---------- */
V20.poissonPMF = function(lambda, k){
  lambda = Math.max(lambda, 0.00001);
  if(k < 0) return 0;
  return Math.exp(-lambda) * Math.pow(lambda, k) / V20.factorial(k);
};

/* ---------- FACTORIAL (CACHE) ---------- */
V20._fact_cache = {0:1,1:1};
V20.factorial = function(n){
  n = n|0;
  if(n < 0) return 1;
  if(V20._fact_cache[n]) return V20._fact_cache[n];
  let r = 1;
  for(let i=2;i<=n;i++) r*=i;
  V20._fact_cache[n]=r;
  return r;
};

/* ---------- DETERMINISTIC SIMULATION (matrix-based) ---------- */
V20.detSim = function(lambda){
  const lamH = V20._safeNum(lambda.lamH,1.2);
  const lamA = V20._safeNum(lambda.lamA,1.0);
  let pH=0,pD=0,pA=0;

  for(let h=0;h<=8;h++){
    const pHh = V20.poissonPMF(lamH,h);
    for(let a=0;a<=8;a++){
      const pAa = V20.poissonPMF(lamA,a);
      const p = pHh * pAa;
      if(h>a) pH+=p;
      else if(h==a) pD+=p;
      else pA+=p;
    }
  }
  const s = pH+pD+pA || 1;
  return { pH:pH/s, pD:pD/s, pA:pA/s };
};

/* ---------- BUILD EMPTY MATRIX ---------- */
V20.buildMatrix = function(cap){
  const m = [];
  for(let i=0;i<=cap;i++){
    m[i] = [];
    for(let j=0;j<=cap;j++) m[i][j] = 0;
  }
  return m;
};

/* ---------- ADD TO MATRIX ---------- */
V20.addToMatrix = function(mat, h, a){
  if(mat[h] && typeof mat[h][a] !== "undefined"){
    mat[h][a]++;
  }
};

/* ---------- NORMALIZE MATRIX ---------- */
V20.normalizeMatrix = function(mat, total){
  for(let i=0;i<mat.length;i++){
    for(let j=0;j<mat[i].length;j++){
      mat[i][j] = mat[i][j] / total;
    }
  }
  return mat;
};

/* ---------- BTTS (analytic) ---------- */
V20.computeBTTS = function(lambda){
  const lamH = V20._safeNum(lambda.lamH,1.2);
  const lamA = V20._safeNum(lambda.lamA,1.0);
  const pH0 = V20.poissonPMF(lamH,0);
  const pA0 = V20.poissonPMF(lamA,0);
  return 1 - pH0 - pA0 + (pH0*pA0); // P(H>=1 ∧ A>=1)
};

/* ---------- UNCERTAINTY (entropy-based) ---------- */
V20.computeUncertainty = function(pH,pD,pA){
  const eps = 1e-9;
  const H = -(pH*Math.log(pH+eps) + pD*Math.log(pD+eps) + pA*Math.log(pA+eps));
  const maxH = Math.log(3);
  return { score: (H/maxH)*100 };
};
/* ============================================================
   MODULE 5 — MONTE CARLO + HYPERLAMBDA + FUSE ENGINE
   ============================================================ */

/* ---------- MONTE CARLO SIMULATION ---------- */
V20.monteCarlo = function(lambda, ctx, simCount, scoreCap, home, away, tact){
  const lamH0 = V20._safeNum(lambda.lamH,1.2);
  const lamA0 = V20._safeNum(lambda.lamA,1.0);

  const chaos = V20._safeNum(ctx.chaos,5);
  const tempo = V20._safeNum(ctx.tempo,5);

  simCount = Number(simCount);
  if(!isFinite(simCount) || simCount<=0) simCount = 3000;
  scoreCap = Number(scoreCap);
  if(!isFinite(scoreCap) || scoreCap<=0) scoreCap = 8;

  /* Monte Carlo Result Counters */
  let winH=0, winA=0, draw=0, totalGoals=0;
  const mat = V20.buildMatrix(scoreCap);

  /* Precompute multipliers */
  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;

  const pressH = V20._safeNum(tact?.home?.pressIntensity,5);
  const pressA = V20._safeNum(tact?.away?.pressIntensity,5);
  const flexH  = V20._safeNum(tact?.home?.flex,0.5);
  const flexA  = V20._safeNum(tact?.away?.flex,0.5);

  const stabH  = V20._safeNum(home?.stability,5);
  const stabA  = V20._safeNum(away?.stability,5);

  /* MAIN SIM LOOP */
  for(let i=0;i<simCount;i++){

    /* Lambda adjusted */
    let lamH = lamH0 * (1 + chaosF*0.12 + tempoF*0.05 + (pressA-5)*0.015 - (pressH-5)*0.01);
    let lamA = lamA0 * (1 + chaosF*0.12 + tempoF*0.05 + (pressH-5)*0.015 - (pressA-5)*0.01);

    lamH *= (1 + (flexH-0.5)*0.10 - (stabH-5)*0.01);
    lamA *= (1 + (flexA-0.5)*0.10 - (stabA-5)*0.01);

    lamH = V20.clamp(lamH,0.15,6.5);
    lamA = V20.clamp(lamA,0.15,6.5);

    /* Sample goals using inverse sampling */
    const gH = V20.samplePoisson(lamH);
    const gA = V20.samplePoisson(lamA);

    totalGoals += (gH + gA);

    if(gH > gA) winH++;
    else if(gH < gA) winA++;
    else draw++;

    const h = (gH<=scoreCap)?gH:scoreCap;
    const a = (gA<=scoreCap)?gA:scoreCap;
    V20.addToMatrix(mat, h, a);
  }

  const pH = winH/simCount;
  const pA = winA/simCount;
  const pD = draw/simCount;

  const avgGoals = totalGoals/simCount;

  /* Normalize matrix */
  const matN = V20.normalizeMatrix(mat, simCount);

  /* Return */
  return {
    pH, pD, pA,
    avgGoals,
    matrix: matN,
    scoreCap,
    simCount,
    /* For HyperLambda */
    hyperLambda: { lamH: lamH0, lamA: lamA0 },
    pattern: {
      control: 0.25 + (tempoF*0.10),
      swing: 0.25 + (chaosF*0.15),
      stalled: 0.25 + ((stabH+stabA)/20)*0.1,
      chaotic: 0.25 + (Math.abs(chaosF)*0.2)
    }
  };
};

/* ---------- POISSON SAMPLER (inverse transform) ---------- */
V20.samplePoisson = function(lambda){
  const L = Math.exp(-lambda);
  let k = 0;
  let p = 1;
  do { k++; p *= Math.random(); } while(p > L && k<12);
  return k-1;
};

/* ============================================================
   HYPERLAMBDA — Final stabilizer lambda
   ============================================================ */

V20.hyperLambda = function(lambda, ctx, home, away){
  const lamH0 = V20._safeNum(lambda.lamH,1.2);
  const lamA0 = V20._safeNum(lambda.lamA,1.0);

  const tempo = V20._safeNum(ctx.tempo,5);
  const chaos = V20._safeNum(ctx.chaos,5);

  const tempoF = (tempo - 5)/5;
  const chaosF = (chaos - 5)/5;

  const stH = V20._safeNum(home?.stability,5);
  const stA = V20._safeNum(away?.stability,5);

  const momH = V20._safeNum(home?.momentum,5);
  const momA = V20._safeNum(away?.momentum,5);

  /* Blend base λ with context */
  let lamH = lamH0*(1 + tempoF*0.10 + chaosF*0.08 + (momH-5)*0.02 - (stH-5)*0.01);
  let lamA = lamA0*(1 + tempoF*0.10 + chaosF*0.08 + (momA-5)*0.02 - (stA-5)*0.01);

  lamH = V20.clamp(lamH,0.2,6.5);
  lamA = V20.clamp(lamA,0.2,6.5);

  return { lamH, lamA };
};

/* ============================================================
   FUSE ENGINE — combine deterministic, chaos, MC, zero engine
   ============================================================ */

V20.fuseOutputs = function(det, detChaos, mc, zero){
  const baseH = (det.pH + detChaos.pH + mc.pH)/3;
  const baseD = (det.pD + detChaos.pD + mc.pD)/3;
  const baseA = (det.pA + detChaos.pA + mc.pA)/3;

  const zH = zero.pH, zD = zero.pD, zA = zero.pA;

  const finalH = (baseH*0.55 + zH*0.45);
  const finalD = (baseD*0.55 + zD*0.45);
  const finalA = (baseA*0.55 + zA*0.45);

  let s = finalH + finalD + finalA;
  return {
    final:{
      pH: finalH/s,
      pD: finalD/s,
      pA: finalA/s
    },
    base:{
      pH: baseH, pD: baseD, pA: baseA
    }
  };
};
/* ============================================================
   MODULE 6 — ADVANCED MODELS (Weather, DCM, EMC, GSAL, RII, SQM, Bayes)
   ============================================================ */

V20.Weather = (function(){
  const presets = {
    normal:{chaos:0,tempo:0,finishing:0,error:0},
    rain:{chaos:0.9,tempo:-0.4,finishing:-0.06,error:0.12},
    heavy_rain:{chaos:1.6,tempo:-1.0,finishing:-0.14,error:0.28},
    poor_pitch:{chaos:1.1,tempo:-0.8,finishing:-0.10,error:0.30},
    hot:{chaos:0.2,tempo:-0.4,finishing:-0.02,error:0.06},
    cold:{chaos:0.1,tempo:-0.2,finishing:0,error:0.02},
    snow:{chaos:1.2,tempo:-1.1,finishing:-0.16,error:0.36}
  };
  return {
    presets,
    applyToContext:function(ctx, key){
      const p = presets[key] || presets.normal;
      ctx = ctx || {};
      ctx.chaos = V20._safeNum(ctx.chaos,5) + p.chaos;
      ctx.tempo = V20._safeNum(ctx.tempo,5) + p.tempo;
      ctx.weatherFinishing = p.finishing;
      ctx.weatherError = p.error;
      return ctx;
    }
  };
})();

/* ---------------- DCM (Decompose Chaos & compute multiplier) ---------------- */
V20.DCM = (function(){
  function decompose(ctx, home, away){
    ctx = ctx || {}; home = home || {}; away = away || {};
    const chaos = V20._safeNum(ctx.chaos,5);
    const imp = V20._safeNum(ctx.importance,5);
    const flexAvg = ((home.flex||0.5) + (away.flex||0.5)) / 2;
    const stabilityAvg = ((home.stability||5) + (away.stability||5)) / 2;

    const defensive = 0.18*(chaos/5) + 0.12*(1 - (stabilityAvg/10));
    const structural = 0.12*(chaos/5) + 0.09*(flexAvg);
    const transition = 0.22*(chaos/5) + 0.08*(Math.abs((home.momentum||5)-(away.momentum||5))/5);
    const emotional = 0.28*((imp-5)/10 + ((ctx.isDerby?1:0)*0.9));

    const sum = defensive + structural + transition + emotional || 1;
    return {
      defensive: defensive/sum,
      structural: structural/sum,
      transition: transition/sum,
      emotional: emotional/sum
    };
  }

  function chaosMultiplier(ctx, home, away){
    const parts = decompose(ctx, home, away);
    const mult = 1 + parts.defensive*0.28 + parts.transition*0.20 + parts.emotional*0.30 + parts.structural*0.12;
    return V20.clamp(mult, 0.7, 2.2);
  }

  return { decompose, chaosMultiplier };
})();

/* ---------------- EMC (Estimated Minute Curve) ---------------- */
V20.EMC = (function(){
  function buildCurve(ctx){
    ctx = ctx || {};
    const tempo = V20._safeNum(ctx.tempo,5);
    const chaos = V20._safeNum(ctx.chaos,5);
    const impo = V20._safeNum(ctx.importance,5);
    const curve = new Array(90).fill(1);
    for(let i=0;i<15;i++) curve[i] *= (0.92 + (tempo-5)/30 + (chaos-5)/80);
    for(let i=15;i<35;i++) curve[i] *= (1.02 + (tempo-5)/22 + (chaos-5)/60);
    for(let i=35;i<55;i++) curve[i] *= (1.00 + (tempo-5)/30 + (chaos-5)/90);
    for(let i=55;i<70;i++) curve[i] *= (0.96 + (chaos-5)/45 - (tempo-5)/100);
    for(let i=70;i<90;i++) curve[i] *= (1.08 + (chaos-5)/26 + (impo-5)/40);
    const mean = curve.reduce((a,b)=>a+b,0)/curve.length;
    for(let i=0;i<curve.length;i++) curve[i] = curve[i] / (mean || 1);
    return curve;
  }
  return { buildCurve };
})();

/* ---------------- RII (Referee Impact Index) ---------------- */
V20.RII = (function(){
  function score(profile){
    profile = profile || {};
    const cards = V20._safeNum(profile.cardsPerGame, 2.5);
    const fouls = V20._safeNum(profile.foulsPerGame, 24);
    const pen = V20._safeNum(profile.penaltyFreq, 0.08);
    const homeBias = V20._safeNum(profile.homeBias, 0);
    // scaled 0..1
    const s = ((cards/5)*0.35 + (fouls/40)*0.25 + (pen/0.2)*0.25 + (homeBias)*0.15);
    return V20.clamp(s, 0, 1);
  }
  function applyToCtx(ctx, profile){
    ctx = ctx || {};
    const s = score(profile);
    ctx.chaos = V20._safeNum(ctx.chaos,5) + (s - 0.5) * 0.9;
    ctx.refPenalty = s * 0.18;
    return ctx;
  }
  return { score, applyToCtx };
})();

/* ---------------- SQM (Finishing Quality Model) ---------------- */
V20.SQM = (function(){
  function finishingBias(profile){
    profile = profile || {};
    const xgShot = V20._safeNum(profile.xGperShot, 0.12);
    const postx = V20._safeNum(profile.postxGoffset, 0);
    const form = V20._safeNum(profile.finishingForm, 0);
    const keeper = V20._safeNum(profile.keeperBias, 0);
    let fb = 1 + ((xgShot - 0.12) * 1.8) + postx + form - keeper*0.7;
    return V20.clamp(fb, 0.7, 1.35);
  }
  function applyToLambda(lambda, homeProfile, awayProfile){
    const fh = finishingBias(homeProfile);
    const fa = finishingBias(awayProfile);
    return { lamH: lambda.lamH * fh, lamA: lambda.lamA * fa };
  }
  return { finishingBias, applyToLambda };
})();

/* ---------------- GSAL (Game State Adaptive Lambda) ---------------- */
V20.GSAL = (function(){
  function adaptLambda(baseLam, ctx, state, home, away, tact){
    state = state || {};
    home = home || {}; away = away || {}; tact = tact || {};
    let lamH = V20._safeNum(baseLam.lamH, 1);
    let lamA = V20._safeNum(baseLam.lamA, 1);
    let modH = 1, modA = 1;
    const scoreH = V20._safeNum(state.scoreH,0), scoreA = V20._safeNum(state.scoreA,0);
    if(scoreH > scoreA){ const lead = scoreH - scoreA; modH *= 1 - 0.12*V20.clamp(lead,0,3); modA *= 1 + 0.18*V20.clamp(lead,0,3); }
    else if(scoreA > scoreH){ const lead = scoreA - scoreH; modA *= 1 - 0.12*V20.clamp(lead,0,3); modH *= 1 + 0.18*V20.clamp(lead,0,3); }
    const minute = V20._safeNum(state.minute,0);
    if(minute >= 75){
      if(scoreH < scoreA) modH *= 1.25;
      if(scoreA < scoreH) modA *= 1.25;
      modH *= 1 - 0.06; modA *= 1 - 0.06;
    }
    if(state.redH){ modH *= 1 - 0.18*state.redH; modA *= 1 + 0.12*state.redH; }
    if(state.redA){ modA *= 1 - 0.18*state.redA; modH *= 1 + 0.12*state.redA; }
    const pressDiff = (tact.home?.pressIntensity||5) - (tact.away?.pressIntensity||5);
    if(pressDiff > 0 && minute >= 60){ modH *= 1 + pressDiff*0.02; modA *= 1 - pressDiff*0.01; }
    else if(pressDiff < 0 && minute >= 60){ const pd = Math.abs(pressDiff); modA *= 1 + pd*0.02; modH *= 1 - pd*0.01; }
    const importance = V20._safeNum(ctx.importance,5);
    const chaos = V20._safeNum(ctx.chaos,5);
    const impFactor = 1 - V20.clamp((importance-5)/10, -0.2, 0.2);
    const chaosFactor = 1 + V20.clamp((chaos-5)/10, -0.25, 0.6);
    const outH = V20.clamp(lamH * modH * impFactor * chaosFactor, 0.05, 8.0);
    const outA = V20.clamp(lamA * modA * impFactor * chaosFactor, 0.05, 8.0);
    return { lamH: outH, lamA: outA };
  }
  return { adaptLambda };
})();

/* ---------------- BAYES SIMPLE CALIBRATION ---------------- */
V20.Bayes = (function(){
  function calibrateFromXG(prior, observedGoals, exposureMinutes){
    prior = prior || { alpha:1.5, beta:1.0 };
    observedGoals = V20._safeNum(observedGoals, 0);
    exposureMinutes = V20._safeNum(exposureMinutes, 90);
    const alphaPost = prior.alpha + observedGoals;
    const betaPost = prior.beta + (exposureMinutes/90);
    return { alpha: alphaPost, beta: betaPost, mean: alphaPost / betaPost, variance: alphaPost / (betaPost * betaPost) };
  }
  function calibratePair(priorH, obsH, expH, priorA, obsA, expA){
    const h = calibrateFromXG(priorH, obsH, expH);
    const a = calibrateFromXG(priorA, obsA, expA);
    return { h, a };
  }
  return { calibrateFromXG, calibratePair };
})();

/* ============================================================
   MODULE 6 DONE
   ============================================================ */
/* ============================================================
   MODULE 7 — MATCH TYPE, TEAM DNA, AUTO INPUT ENGINE
   ============================================================ */

/* ---------------- MATCH TYPE PRESETS ---------------- */
V20.MatchType = {
  templates:{
    normal:{ tempo:5, chaos:5, importance:5 },
    derby:{ tempo:6, chaos:7, importance:6, isDerby:true },
    relegation:{ tempo:4, chaos:6, importance:8 },
    title:{ tempo:6, chaos:5, importance:9 },
    cup:{ tempo:5, chaos:6, importance:7 },
    ucl:{ tempo:6, chaos:6, importance:8 },
    ucl_knockout:{ tempo:7, chaos:7, importance:9 }
  },

  apply:function(ctx, typeKey){
    const t = V20.MatchType.templates[typeKey] || V20.MatchType.templates.normal;
    ctx = ctx || {};
    ctx.tempo = t.tempo;
    ctx.chaos = t.chaos;
    ctx.importance = t.importance;
    ctx.isDerby = t.isDerby || false;
    return ctx;
  }
};

/* ---------------- TEAM DNA PRESET (compact example) ---------------- */
V20.TeamDNA = {
  db:{
    "barcelona":{ tempo:7, chaos:4, press:6, momentum:6, stability:7, flex:0.6 },
    "real madrid":{ tempo:6, chaos:5, press:6, momentum:7, stability:6, flex:0.7 },
    "man city":{ tempo:8, chaos:4, press:7, momentum:7, stability:8, flex:0.6 },
    "bayern":{ tempo:7, chaos:5, press:7, momentum:6, stability:7, flex:0.6 }
  },

  get:function(name){
    if(!name) return null;
    const key = name.toLowerCase().trim();
    return V20.TeamDNA.db[key] || null;
  }
};

/* ---------------- AUTO INPUT ENGINE ---------------- */
V20.Auto = {};

V20.Auto.autoTempo = function(teamDNA){
  if(!teamDNA) return 5;
  return V20.clamp(teamDNA.tempo || 5, 1, 10);
};

V20.Auto.autoChaos = function(teamDNA, matchType){
  let c = 5;
  if(teamDNA) c += (teamDNA.chaos - 5)*0.5;
  if(matchType === "derby") c += 1.0;
  if(matchType === "ucl_knockout") c += 1.2;
  return V20.clamp(c, 1, 10);
};

V20.Auto.autoImportance = function(matchType){
  const map = {
    normal:5, derby:6, relegation:8, title:9, cup:7, ucl:8, ucl_knockout:9
  };
  return map[matchType] || 5;
};

V20.Auto.autoStability = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.stability || 5,1,10) : 5;
};

V20.Auto.autoMomentum = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.momentum || 5,1,10) : 5;
};

V20.Auto.autoPress = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.press || 5,1,10) : 5;
};

V20.Auto.autoFlex = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.flex || 0.5,0,1) : 0.5;
};

/* ---------------- TEAM PROFILE MAPPER ---------------- */
V20.Auto.autoTPM = function(name){
  const dna = V20.TeamDNA.get(name);
  if(!dna) return {};
  return {
    stability:dna.stability || 5,
    momentum:dna.momentum || 5,
    press:dna.press || 5,
    flex:dna.flex || 0.5
  };
};

/* ---------------- APPLY ALL AUTO INPUTS ---------------- */
V20.Auto.applyAll = function(homeName, awayName, matchType){
  const hDNA = V20.TeamDNA.get(homeName);
  const aDNA = V20.TeamDNA.get(awayName);

  const ctx = {};
  ctx.tempo = Math.round((V20.Auto.autoTempo(hDNA)+V20.Auto.autoTempo(aDNA))/2);
  ctx.chaos = Math.round((V20.Auto.autoChaos(hDNA,matchType)+V20.Auto.autoChaos(aDNA,matchType))/2);
  ctx.importance = V20.Auto.autoImportance(matchType);

  const home = V20.Auto.autoTPM(homeName);
  const away = V20.Auto.autoTPM(awayName);

  return { ctx, home, away };
};

/* ---------------- AUTO FILL UI ---------------- */
window.autoFill = function(){
  const home = document.getElementById("home_team")?.value || "";
  const away = document.getElementById("away_team")?.value || "";
  const matchType = document.getElementById("match_type")?.value || "normal";

  const result = V20.Auto.applyAll(home, away, matchType);
  const ctx = result.ctx;
  const hm = result.home;
  const aw = result.away;

  document.getElementById("tempo").value = ctx.tempo;
  document.getElementById("chaos").value = ctx.chaos;
  document.getElementById("importance").value = ctx.importance;

  document.getElementById("home_st").value = hm.stability || 5;
  document.getElementById("home_mom").value = hm.momentum || 5;
  document.getElementById("home_press").value = hm.press || 5;
  document.getElementById("home_flex").value = hm.flex || 0.5;

  document.getElementById("away_st").value = aw.stability || 5;
  document.getElementById("away_mom").value = aw.momentum || 5;
  document.getElementById("away_press").value = aw.press || 5;
  document.getElementById("away_flex").value = aw.flex || 0.5;
};

/* ============================================================
   MODULE 7 DONE
   ============================================================ */
  /* ============================================================
   MODULE 12 — ULTRA STAGE1: AUTO TCI + PPDA ESTIMATOR +
                 LEAGUE PRESETS + TIER DETECTION
   Safe, fallback defaults, integrates with V20.Auto and V20.MatchType
   Paste AFTER MODULE 8 (chaos/meta) inside same <script>
   ============================================================ */

(function(){

  // shorthand safe number
  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  V20.Ultra = V20.Ultra || {};

  /* ---------------- LEAGUE PRESETS ----------------
     Basic presets mapping league key -> base tempo/chaos modifiers
     Can be extended later or loaded from external DB
  */
  V20.Ultra.leaguePresets = {
    default: { tempo: 5, chaos: 5, importance: 5 },
    epl:     { tempo: 6.2, chaos: 5.4, importance: 6 },
    laliga:  { tempo: 5.6, chaos: 4.6, importance: 5.5 },
    bundesliga:{ tempo:6.5, chaos:5.6, importance:5.8 },
    seriea:  { tempo: 5.0, chaos: 4.2, importance: 5.2 },
    ligue1:  { tempo:5.2, chaos:4.8, importance:5.1 },
    ucl:     { tempo:6.3, chaos:5.8, importance:8 },
    ucl_knockout:{ tempo:6.8, chaos:6.2, importance:9 },
    asia:    { tempo:5.4, chaos:6.0, importance:4.8 },
    lower:   { tempo:4.2, chaos:6.4, importance:3.8 }
  };

  V20.Ultra.getLeaguePreset = function(key){
    if(!key) return V20.Ultra.leaguePresets.default;
    key = String(key).toLowerCase();
    return V20.Ultra.leaguePresets[key] || V20.Ultra.leaguePresets.default;
  };

  /* ---------------- TIER DETECTION ----------------
     Simple name-based heuristic to detect youth/B-team or low-tier clubs.
     Returns tierHint: "normal"|"youth"|"bteam"|"lowtier"
  */
  V20.Ultra.detectTierFromName = function(name){
    if(!name) return "normal";
    const sname = String(name).toLowerCase();
    // heuristics
    if(/\b(u|u21|u23|u19|u18)\b/.test(sname)) return "youth";
    if(/\b(ii|b team|b-team|reserves|reserva|reserves)\b/.test(sname)) return "bteam";
    // small-country leagues / reserve pattern
    if(/\b(fc )?academy\b/.test(sname)) return "youth";
    // if name includes obvious lower-league word
    if(/\b(academy|ciudad|town|county|uniteds?|rovers?|athletic)\b/.test(sname) && sname.length < 22) {
      // not precise but fallback: treat as normal for major names
    }
    // default normal
    return "normal";
  };

  /* ---------------- PPDA ESTIMATOR (fallback when PPDA missing)
     Simple mapping based on pressIntensity & team style (press high -> low PPDA)
     Output scale: typical PPDA numbers ~ 6..18 (lower => more aggressive press)
  */
  V20.Ultra.estimatePPDA = function(pressIntensity, teamStyle){
    // pressIntensity 1..10
    const p = s(pressIntensity,5);
    // teamStyle: "possession","direct","counter","balanced"
    let base;
    // base by press intensity inverse
    base = 14 - (p - 1) * 1.05; // p=1 -> ~14, p=10 -> ~4.5
    // style modifiers
    if(teamStyle === "possession") base += 1.2;
    else if(teamStyle === "direct") base -= 0.8;
    else if(teamStyle === "counter") base += 0.6;
    // clamp typical PPDA range
    base = V20.clamp(base, 3.5, 18);
    return base;
  };

  /* ---------------- TCI (Tempo/Chaos/Importance) AUTO from Ultra logic
     Input sources:
       - teamDNA home/away (stability,momentum,press,flex)
       - tact (pressIntensity)
       - weather effect already stored in ctx.weatherError / ctx.weatherFinishing
       - matchType template (if present)
       - league preset (if provided as options.leagueKey)
       - tierHint (youth/bteam/lowtier modifies tempo/chaos)
     Returns ctx adjustments { tempo, chaos, importance, note }
  */
  V20.Ultra.computeTCI = function(options){
    options = options || {};
    const home = options.home || {};
    const away = options.away || {};
    const tact = options.tact || {};
    const ctxIn = options.ctx || {};
    const leagueKey = options.leagueKey || null;
    const tierHint = options.tierHint || "normal";
    const matchTypeKey = options.matchTypeKey || null;

    // base from league presets
    const leaguePreset = V20.Ultra.getLeaguePreset(leagueKey);
    let tempo = s(ctxIn.tempo, leaguePreset.tempo);
    let chaos = s(ctxIn.chaos, leaguePreset.chaos);
    let importance = s(ctxIn.importance, leaguePreset.importance);

    // team-level drivers
    const pressH = s(tact.home?.pressIntensity || home.press || 5, 5);
    const pressA = s(tact.away?.pressIntensity || away.press || 5, 5);
    const flexH = s(home.flex, 0.5);
    const flexA = s(away.flex, 0.5);
    const stabH = s(home.stability,5);
    const stabA = s(away.stability,5);
    const momH = s(home.momentum,5);
    const momA = s(away.momentum,5);

    // press imbalance increases chaos
    const pressDiff = (pressH - pressA) / 10; // -0.9 .. +0.9
    chaos += pressDiff * 0.9;

    // higher flex and higher tempo teams increase tempo
    const flexAvg = (flexH + flexA)/2;
    tempo += (flexAvg - 0.5) * 1.2;

    // momentum differential biases tempo & flow
    const momDiff = (momH - momA) / 10;
    tempo += momDiff * 0.8;
    chaos += Math.abs(momDiff) * 0.5;

    // lower stability increases chaos & fragility
    const stabAvg = (stabH + stabA)/2;
    chaos += ((6 - stabAvg) / 6) * 1.1;

    // weather finishing/error increases chaos slightly
    if(ctxIn.weatherError) chaos += s(ctxIn.weatherError,0) * 1.6;
    if(ctxIn.weatherFinishing) tempo += s(ctxIn.weatherFinishing,0) * -0.6;

    // matchType influence (if provided)
    if(matchTypeKey && V20.MatchType && V20.MatchType.templates && V20.MatchType.templates[matchTypeKey]){
      const mt = V20.MatchType.templates[matchTypeKey];
      tempo = (tempo * 0.5) + (s(mt.tempo, tempo) * 0.5);
      chaos = (chaos * 0.6) + (s(mt.chaos, chaos) * 0.4);
      importance = Math.max(importance, s(mt.importance, importance));
    }

    // tier adjustments
    if(tierHint === "youth"){ tempo -= 0.7; chaos += 0.9; importance -= 0.5; }
    else if(tierHint === "bteam"){ tempo -= 0.9; chaos += 1.1; importance -= 0.8; }
    else if(tierHint === "lowtier"){ tempo -= 1.0; chaos += 1.6; importance -= 1.0; }

    // clamp final outputs to 1..10
    tempo = V20.clamp( tempo, 1, 10 );
    chaos = V20.clamp( chaos, 1, 10 );
    importance = V20.clamp( importance, 1, 10 );

    // note: provide diagnostic values
    const note = {
      league: leagueKey || null,
      tier: tierHint,
      pressDiff: +(pressDiff.toFixed(3)),
      flexAvg: +(flexAvg.toFixed(3)),
      momDiff: +(momDiff.toFixed(3)),
      stabAvg: +(stabAvg.toFixed(3))
    };

    return { tempo, chaos, importance, note };
  };


  /* ---------------- apply Ultra auto-fill to UI (safe, non-destructive)
     Will fill tempo/chaos/importance and optionally team profile fields
     options: { leagueKey, applyTier:true/false, fillProfiles:true/false }
  */
  V20.Ultra.autoFillEnhanced = function(options){
    options = options || {};
    const homeName = document.getElementById && document.getElementById('home_team') ? (document.getElementById('home_team').value || '') : '';
    const awayName = document.getElementById && document.getElementById('away_team') ? (document.getElementById('away_team').value || '') : '';
    const leagueKey = options.leagueKey || (document.getElementById('league') ? document.getElementById('league').value : null);
    const matchTypeKey = document.getElementById('match_type') ? document.getElementById('match_type').value : null;

    const hDNA = V20.TeamDNA.get(homeName) || {};
    const aDNA = V20.TeamDNA.get(awayName) || {};

    // tier detection
    const tierH = V20.Ultra.detectTierFromName(homeName);
    const tierA = V20.Ultra.detectTierFromName(awayName);
    const tierHint = (tierH !== "normal" || tierA !== "normal") ? (tierH !== "normal" ? tierH : tierA) : "normal";

    // compose options
    const ctxIn = {
      tempo: s(document.getElementById('tempo')?.value, null),
      chaos: s(document.getElementById('chaos')?.value, null),
      importance: s(document.getElementById('importance')?.value, null),
      weatherError: (window && window._V20_WEATHER && window._V20_WEATHER.error) ? window._V20_WEATHER.error : null,
      weatherFinishing: (window && window._V20_WEATHER && window._V20_WEATHER.finishing) ? window._V20_WEATHER.finishing : null
    };

    const tact = {
      home: { pressIntensity: s(document.getElementById('home_press')?.value, hDNA.press || 5) },
      away: { pressIntensity: s(document.getElementById('away_press')?.value, aDNA.press || 5) }
    };

    const result = V20.Ultra.computeTCI({ home: hDNA, away: aDNA, tact, ctx: ctxIn, leagueKey, tierHint, matchTypeKey });

    // write to UI (non-destructive: overrides tempo/chaos/importance only)
    try{
      document.getElementById('tempo').value = Math.round(result.tempo);
      document.getElementById('chaos').value = Math.round(result.chaos);
      document.getElementById('importance').value = Math.round(result.importance);
    }catch(e){ /* ignore if UI missing */ }

    // optionally fill profiles from DNA
    if(options.fillProfiles){
      try{
        document.getElementById('home_st').value = hDNA.stability || document.getElementById('home_st')?.value || 5;
        document.getElementById('home_mom').value = hDNA.momentum || document.getElementById('home_mom')?.value || 5;
        document.getElementById('home_press').value = hDNA.press || document.getElementById('home_press')?.value || 5;
        document.getElementById('home_flex').value = hDNA.flex || document.getElementById('home_flex')?.value || 0.5;

        document.getElementById('away_st').value = aDNA.stability || document.getElementById('away_st')?.value || 5;
        document.getElementById('away_mom').value = aDNA.momentum || document.getElementById('away_mom')?.value || 5;
        document.getElementById('away_press').value = aDNA.press || document.getElementById('away_press')?.value || 5;
        document.getElementById('away_flex').value = aDNA.flex || document.getElementById('away_flex')?.value || 0.5;
      }catch(e){ /* ignore */ }
    }

    // return diagnostic
    return result;
  };

  /* ---------------- attach safe helper to V20.Auto without overwriting core Auto functions
     (if V20.Auto.autoTCIEnhanced not present, create alias)
  */
  if(!V20.Auto) V20.Auto = {};
  if(!V20.Auto.autoTCIEnhanced) V20.Auto.autoTCIEnhanced = function(opts){ return V20.Ultra.autoFillEnhanced(opts); };
  if(!V20.Ultra.applied) V20.Ultra.applied = true;

})(); // end MODULE 12
  /* ============================================================
   MODULE 13 — ULTRA PPDA + PRESSING ENGINE
   Complements Module 12
   Safe, fallback defaults, ready for integration with PSZ ZERO
   ============================================================ */

(function(){

  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  V20.Ultra = V20.Ultra || {};

  /* --------------------------------------------
     Team style categorization (optional input)
     If not supplied, use momentum + flex heuristic
  ---------------------------------------------- */
  V20.Ultra.getTeamStyle = function(teamProfile){
    if(!teamProfile) return "balanced";

    if(teamProfile.style) return String(teamProfile.style);

    const mom = s(teamProfile.momentum,5);
    const flex = s(teamProfile.flex,0.5);
    const stab = s(teamProfile.stability,5);

    if(mom > 7 && flex > 0.6) return "possession";
    if(mom < 4 && stab < 4.5) return "direct";
    if(flex < 0.4) return "counter";

    return "balanced";
  };

  /* --------------------------------------------
     Ultra PPDA Estimator (Enhanced)
     Returns { ppda, pressFactor }
     pressFactor is normalized 0..1 measure of pressing aggression
  ---------------------------------------------- */
  V20.Ultra.estimatePPDA_Enhanced = function(pressIntensity, teamProfile){
    const p = s(pressIntensity,5);
    const style = V20.Ultra.getTeamStyle(teamProfile);

    let ppda = 14 - (p - 1) * 1.05;

    // style modifier
    if(style === "possession") ppda += 1.4;
    else if(style === "direct") ppda -= 1.1;
    else if(style === "counter") ppda += 0.6;

    // future: include defensive line height (module input baru)
    if(teamProfile && teamProfile.defLine){
      const dl = s(teamProfile.defLine,5);
      ppda -= (dl - 5) * 0.6;
    }

    ppda = V20.clamp(ppda, 3.3, 18.0);

    const pressFactor = V20.clamp((10 - p) / 9, 0, 1); // p=10 → hard press → factor ≈ 0

    return { ppda, pressFactor };
  };

  /* --------------------------------------------
     Match-level pressing engine
     Returns:
       - homePPDA / awayPPDA
       - chaosBoost     (0..1)
       - pressMatchFactor (0..1)
  ---------------------------------------------- */
  V20.Ultra.computePressingMatch = function(homeProf, awayProf, tact){
    const hPres = s(tact.home?.pressIntensity || homeProf.press || 5, 5);
    const aPres = s(tact.away?.pressIntensity || awayProf.press || 5, 5);

    const homeEval = V20.Ultra.estimatePPDA_Enhanced(hPres, homeProf);
    const awayEval = V20.Ultra.estimatePPDA_Enhanced(aPres, awayProf);

    const pressGap = Math.abs(hPres - aPres) / 10; // 0..1
    const chaosBoost = V20.clamp(pressGap * 0.9, 0, 1);

    const pressMatchFactor = V20.clamp(
      (1 - homeEval.pressFactor) * 0.5 +
      (1 - awayEval.pressFactor) * 0.5,
      0, 1
    );

    return {
      homePPDA: homeEval.ppda,
      awayPPDA: awayEval.ppda,
      chaosBoost,
      pressMatchFactor
    };
  };

  /* --------------------------------------------
     Helper: Auto-enhanced pressing estimator for UI
  ---------------------------------------------- */
  V20.Ultra.autoPressEnhanced = function(){
    const hTeam = document.getElementById('home_team')?.value || "";
    const aTeam = document.getElementById('away_team')?.value || "";

    const hDNA = V20.TeamDNA.get(hTeam) || {};
    const aDNA = V20.TeamDNA.get(aTeam) || {};

    const presH = s(document.getElementById('home_press')?.value, hDNA.press || 5);
    const presA = s(document.getElementById('away_press')?.value, aDNA.press || 5);

    const res = V20.Ultra.computePressingMatch(
      hDNA,
      aDNA,
      {
        home: { pressIntensity: presH },
        away: { pressIntensity: presA }
      }
    );

    console.log("Ultra PPDA estimate:", res);

    return res;
  };

})(); // end MODULE 13
  /* ============================================================
   MODULE 14 — EXTRA INPUTS: FinishingQuality, Injury, ManagerAggression,
                 DefensiveLineHeight, WeatherPro (detailed)
   Safe readers + applicators for engine integration
   Paste AFTER MODULE 13
   ============================================================ */

(function(){

  // safe number helper
  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  // namespace
  V20.Inputs = V20.Inputs || {};

  /* ---------------- DEFAULTS ---------------- */
  V20.Inputs.defaults = {
    finishingQuality: 5.0,    // 1..10 (higher -> better finishing)
    injuryImpact: 0.0,        // 0..1 (fraction of key players missing)
    managerAggression: 5.0,   // 1..10 (higher -> more aggressive tactics)
    defensiveLine: 5.0,       // 1..10 (higher -> higher line)
    weatherWind: 0.0,         // 0..1 scaled wind impact
    weatherVisibility: 1.0    // 0..1 (1 = clear)
  };

  /* ---------------- READ FROM UI (if elements exist) ----------------
     This function will try to read UI elements by conventional IDs.
     If elements not present or invalid, returns safe defaults.
     Expected optional element IDs:
       - finishing_quality_home, finishing_quality_away (number 1..10)
       - injury_home, injury_away (0..1 or 0..100%)
       - manager_agg_home, manager_agg_away (1..10)
       - defline_home, defline_away (1..10)
       - weather_wind (0..1), weather_visibility (0..1)
  */
  V20.Inputs.getMatchAddons = function(){
    try{
      // home
      const fqH = (document.getElementById('finishing_quality_home')?.value !== undefined)
                  ? Number(document.getElementById('finishing_quality_home').value)
                  : null;
      const fqA = (document.getElementById('finishing_quality_away')?.value !== undefined)
                  ? Number(document.getElementById('finishing_quality_away').value)
                  : null;

      const injH_raw = document.getElementById('injury_home')?.value || null;
      const injA_raw = document.getElementById('injury_away')?.value || null;
      const injH = injH_raw === null ? null : (injH_raw.indexOf('%')>-1 ? Number(injH_raw.replace('%',''))/100 : Number(injH_raw));
      const injA = injA_raw === null ? null : (injA_raw.indexOf('%')>-1 ? Number(injA_raw.replace('%',''))/100 : Number(injA_raw));

      const mgH = (document.getElementById('manager_agg_home')?.value !== undefined) ? Number(document.getElementById('manager_agg_home').value) : null;
      const mgA = (document.getElementById('manager_agg_away')?.value !== undefined) ? Number(document.getElementById('manager_agg_away').value) : null;

      const dlH = (document.getElementById('defline_home')?.value !== undefined) ? Number(document.getElementById('defline_home').value) : null;
      const dlA = (document.getElementById('defline_away')?.value !== undefined) ? Number(document.getElementById('defline_away').value) : null;

      const wind = (document.getElementById('weather_wind')?.value !== undefined) ? Number(document.getElementById('weather_wind').value) : null;
      const vis  = (document.getElementById('weather_visibility')?.value !== undefined) ? Number(document.getElementById('weather_visibility').value) : null;

      // try json_config fallback (if user provided in JSON)
      let json = {};
      try{
        const txt = document.getElementById('json_config')?.value || '';
        if(txt && txt.trim().length) {
          const parsed = JSON.parse(txt);
          json = parsed || {};
        }
      }catch(e){ json = {}; }

      // assemble results with cascading fallback: UI -> JSON -> defaults
      const out = {
        finishingQualityHome: s(fqH, s(json.form_home, V20.Inputs.defaults.finishingQuality)),
        finishingQualityAway: s(fqA, s(json.form_away, V20.Inputs.defaults.finishingQuality)),
        injuryHome: V20.clamp(s(injH, s(json.injury_home, V20.Inputs.defaults.injuryImpact)), 0, 1),
        injuryAway: V20.clamp(s(injA, s(json.injury_away, V20.Inputs.defaults.injuryImpact)), 0, 1),
        managerAggHome: V20.clamp(s(mgH, s(json.manager_agg_home, V20.Inputs.defaults.managerAggression)), 1, 10),
        managerAggAway: V20.clamp(s(mgA, s(json.manager_agg_away, V20.Inputs.defaults.managerAggression)), 1, 10),
        defLineHome: V20.clamp(s(dlH, s(json.defline_home, V20.Inputs.defaults.defensiveLine)), 1, 10),
        defLineAway: V20.clamp(s(dlA, s(json.defline_away, V20.Inputs.defaults.defensiveLine)), 1, 10),
        weatherWind: V20.clamp(s(wind, s(json.weather_wind, V20.Inputs.defaults.weatherWind)), 0, 1),
        weatherVisibility: V20.clamp(s(vis, s(json.weather_visibility, V20.Inputs.defaults.weatherVisibility)), 0, 1)
      };

      return out;
    }catch(e){
      // fallback to defaults to ensure no NaN propagation
      return {
        finishingQualityHome: V20.Inputs.defaults.finishingQuality,
        finishingQualityAway: V20.Inputs.defaults.finishingQuality,
        injuryHome: V20.Inputs.defaults.injuryImpact,
        injuryAway: V20.Inputs.defaults.injuryImpact,
        managerAggHome: V20.Inputs.defaults.managerAggression,
        managerAggAway: V20.Inputs.defaults.managerAggression,
        defLineHome: V20.Inputs.defaults.defensiveLine,
        defLineAway: V20.Inputs.defaults.defensiveLine,
        weatherWind: V20.Inputs.defaults.weatherWind,
        weatherVisibility: V20.Inputs.defaults.weatherVisibility
      };
    }
  };

  /* ---------------- APPLY EFFECTS TO TEAM PROFILES ----------------
     Given homeProfile and awayProfile objects (may be empty),
     this function returns modified shallow copies with:
       - finishingBias (multiplier) applied
       - stability/momentum adjustments due to injury
       - press/difference impact from managerAggression & defLine
  */
  V20.Inputs.applyToProfiles = function(homeProfile, awayProfile, addons){
    try{
      homeProfile = homeProfile || {};
      awayProfile = awayProfile || {};
      addons = addons || V20.Inputs.getMatchAddons();

      const h = Object.assign({}, homeProfile);
      const a = Object.assign({}, awayProfile);

      // finishing quality -> finishing bias: map 1..10 to 0.8..1.2
      const fqMulH = V20.clamp(1 + ((addons.finishingQualityHome - 5) / 5) * 0.08, 0.8, 1.2);
      const fqMulA = V20.clamp(1 + ((addons.finishingQualityAway - 5) / 5) * 0.08, 0.8, 1.2);

      h.finishingBias = fqMulH;
      a.finishingBias = fqMulA;

      // injuries reduce stability and momentum proportionally
      const injH = addons.injuryHome;
      const injA = addons.injuryAway;
      h.stability = V20.clamp((s(h.stability,5) * (1 - injH * 0.45)), 1, 10);
      a.stability = V20.clamp((s(a.stability,5) * (1 - injA * 0.45)), 1, 10);
      h.momentum  = V20.clamp((s(h.momentum,5)  * (1 - injH * 0.35)), 1, 10);
      a.momentum  = V20.clamp((s(a.momentum,5)  * (1 - injA * 0.35)), 1, 10);

      // manager aggression influences tempo/press: map 1..10 -> press delta -/+ 
      const mgH = addons.managerAggHome;
      const mgA = addons.managerAggAway;
      // convert to pressBias - positive means more attacking/high press
      const mgBiasH = (mgH - 5) * 0.28; // ~ -1.12 .. +1.12
      const mgBiasA = (mgA - 5) * 0.28;

      h.press = V20.clamp((s(h.press,5) + mgBiasH), 1, 10);
      a.press = V20.clamp((s(a.press,5) + mgBiasA), 1, 10);

      // defensive line affects press/ppda: higher line -> lower PPDA (more aggressive)
      h.defLine = V20.clamp(addons.defLineHome, 1, 10);
      a.defLine = V20.clamp(addons.defLineAway, 1, 10);

      // weather effects: wind reduces finishing, visibility reduces tempo slightly
      const wind = addons.weatherWind;
      const vis  = addons.weatherVisibility;
      // attach to profile for later use by SQM or EMC
      h.weather = { wind: wind, visibility: vis };
      a.weather = { wind: wind, visibility: vis };

      // attach raw addons for diagnostics
      h._addons = Object.assign({}, addons);
      a._addons = Object.assign({}, addons);

      return { home: h, away: a };
    }catch(e){
      // if anything bad -> return original profiles with minimal safe fields
      return {
        home: Object.assign({}, homeProfile, { stability: s(homeProfile.stability,5), momentum: s(homeProfile.momentum,5), press: s(homeProfile.press,5), finishingBias:1 }),
        away: Object.assign({}, awayProfile, { stability: s(awayProfile.stability,5), momentum: s(awayProfile.momentum,5), press: s(awayProfile.press,5), finishingBias:1 })
      };
    }
  };

  /* ---------------- Convenience: read-and-apply chain for UI integration ----------------
     Usage:
       const addons = V20.Inputs.getMatchAddons();
       const profiles = V20.Inputs.applyToProfiles(hDNA, aDNA, addons);
  */
  V20.Inputs.getAndApply = function(homeProfile, awayProfile){
    const addons = V20.Inputs.getMatchAddons();
    return V20.Inputs.applyToProfiles(homeProfile, awayProfile, addons);
  };

  // mark module loaded
  V20.Inputs.loaded = true;

})(); // end MODULE 14
  /* ============================================================
   MODULE 15 — HYBRID ULTRA MODEL
   Produces ultraHybridScore, ultraProbabilities, predictedScore, confidence
   Depends on: V20.Accuracy (optional), V20.Ultra (PPDA/TCI), V20.Inputs, V20.monteCarlo, V20.detSim
   Safe defaults & light MC (configurable)
   Paste AFTER MODULE 14
   ============================================================ */

(function(){

  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }
  V20.Hybrid = V20.Hybrid || {};

  /* ---------------- computeAdjustedLambda
     baseLambda: {lamH,lamA}
     homeProfile/awayProfile: full profiles (with press, stability, momentum, finishingBias, defLine, weather, _addons)
     ctx: {tempo,chaos,importance,...}
     tact: tactical object {home:{pressIntensity}, away:{pressIntensity}}
     options: { useAccuracy:true/false, usePPDA:true/false, bayesBlend:0..1, mcSimCount, scoreCap }
     returns safe { lamH, lamA, parts }
  */
  V20.Hybrid.computeAdjustedLambda = function(baseLambda, homeProfile, awayProfile, ctx, tact, options){
    options = options || {};
    try{
      baseLambda = baseLambda || { lamH: 1.2, lamA: 1.0 };
      const lamH0 = s(baseLambda.lamH,1.2);
      const lamA0 = s(baseLambda.lamA,1.0);

      // 1) apply Accuracy multipliers if available (xG/form/h2h/shotQuality)
      let accMulH = 1, accMulA = 1;
      try{
        if(V20.Accuracy && options.useAccuracy !== false){
          // attempt to parse json_config for accuracy inputs if options not provided
          const cfg = options.accuracyOptions || {};
          // if options.accuracyOptions empty, rely on window json_config parsing done by V20.Accuracy.patchIntegrator
          const mods = V20.Accuracy.buildLambdaModifiers(cfg || {});
          accMulH = s(mods.lamMulH,1);
          accMulA = s(mods.lamMulA,1);
        }
      }catch(e){ accMulH = accMulH; accMulA = accMulA; }

      // 2) incorporate finishingBias from profiles (Module14)
      const finishMulH = s(homeProfile.finishingBias, 1);
      const finishMulA = s(awayProfile.finishingBias, 1);

      // 3) PPDA effect: more aggressive pressing -> lowers PPDA -> more transitions -> slight lambda adjustments
      let ppdaH = null, ppdaA = null, pressMatchFactor = 0;
      try{
        const pressRes = V20.Ultra && V20.Ultra.computePressingMatch ? V20.Ultra.computePressingMatch(homeProfile, awayProfile, tact || {}) : null;
        if(pressRes){
          ppdaH = s(pressRes.homePPDA, null);
          ppdaA = s(pressRes.awayPPDA, null);
          pressMatchFactor = s(pressRes.pressMatchFactor, 0);
        }
      }catch(e){ /* ignore */ }

      // compute PPDA-driven multipliers: low PPDA (aggressive) increases scoring opportunities slightly
      const ppdaMulH = (ppdaH ? V20.clamp(1 + ((12 - ppdaH)/30), 0.85, 1.18) : 1);
      const ppdaMulA = (ppdaA ? V20.clamp(1 + ((12 - ppdaA)/30), 0.85, 1.18) : 1);

      // 4) tactical flex / tempo / chaos interactions (GSAL-like influence)
      const gs = V20.GSAL && typeof V20.GSAL.adaptLambda === 'function'
                 ? V20.GSAL.adaptLambda({ lamH: lamH0*accMulH, lamA: lamA0*accMulA }, ctx || {}, { scoreH:0, scoreA:0, minute:0 }, homeProfile, awayProfile, tact || {})
                 : { lamH: lamH0*accMulH, lamA: lamA0*accMulA };

      // 5) combine multipliers (damped)
      let lamH = gs.lamH * finishMulH * ppdaMulH;
      let lamA = gs.lamA * finishMulA * ppdaMulA;

      // small adjustment by pressMatchFactor and tempo: more tempo increases expected goals
      const tempoF = (s(ctx.tempo,5) - 5) / 5;
      lamH *= (1 + tempoF*0.06 + pressMatchFactor*0.06);
      lamA *= (1 + tempoF*0.06 + pressMatchFactor*0.06);

      // adjust by defensive line: higher line -> attacking spaces -> slight lambda increase for opponent
      lamH *= (1 + ((s(homeProfile.defLine,5)-5) * -0.02)); // higher home defline slightly reduces home conceded? small sign choices
      lamA *= (1 + ((s(awayProfile.defLine,5)-5) * -0.02));

      // consider injury: injuries reduce goal scoring
      lamH *= (1 - s(homeProfile._addons && homeProfile._addons.injury_home, 0) * 0.28);
      lamA *= (1 - s(awayProfile._addons && awayProfile._addons.injury_away, 0) * 0.28);

      // clamp final safe lambdas
      lamH = V20.clamp(lamH, 0.05, 8.5);
      lamA = V20.clamp(lamA, 0.05, 8.5);

      // optional bayes blend with observed goals if provided in options
      if(options.useBayes !== false && V20.Bayes){
        const bayesOpts = {
          priorH: options.priorH, priorA: options.priorA,
          observedGoalsH: options.observedGoalsH, observedGoalsA: options.observedGoalsA,
          exposureH: options.exposureH, exposureA: options.exposureA,
          bayesBlend: s(options.bayesBlend, 0.18)
        };
        const applied = V20.Accuracy && typeof V20.Accuracy.applyBayesBlend === 'function'
                        ? V20.Accuracy.applyBayesBlend({ lamH, lamA }, bayesOpts)
                        : { lamH, lamA };
        lamH = s(applied.lamH, lamH);
        lamA = s(applied.lamA, lamA);
      }

      return { lamH, lamA, parts: { accMulH, accMulA, finishMulH, finishMulA, ppdaH, ppdaA, ppdaMulH, ppdaMulA, pressMatchFactor } };
    }catch(e){
      return { lamH: s(baseLambda.lamH,1.2), lamA: s(baseLambda.lamA,1.0), parts:{} };
    }
  };

  /* ---------------- computeUltraProbabilities
     Uses adjusted lambda to compute deterministic + optional MC and produces blended probabilities
     options: { mcUse:true/false, mcSimCount, scoreCap, mcWeight (0..1) }
  */
  V20.Hybrid.computeUltraProbabilities = function(adjustedLambda, ctx, homeProfile, awayProfile, options){
    options = options || {};
    try{
      const det = V20.detSim ? V20.detSim(adjustedLambda) : { pH:0.33,pD:0.34,pA:0.33 };
      let mcResult = null;
      if(options.mcUse !== false && V20.monteCarlo){
        const simC = s(options.mcSimCount, 2000);
        const cap = s(options.scoreCap, 6);
        mcResult = V20.monteCarlo(adjustedLambda, ctx || {}, simC, cap, homeProfile, awayProfile, { home: { pressIntensity: homeProfile.press }, away: { pressIntensity: awayProfile.press } });
      }
      // blend weights: if mc present use mcWeight, else rely on det
      const wMC = mcResult ? s(options.mcWeight, 0.45) : 0;
      const wDet = 1 - wMC;

      const pH = V20.clamp( ( (det.pH||0) * wDet ) + ( (mcResult && mcResult.pH) ? mcResult.pH * wMC : 0 ), 0.0001, 0.9999 );
      const pD = V20.clamp( ( (det.pD||0) * wDet ) + ( (mcResult && mcResult.pD) ? mcResult.pD * wMC : 0 ), 0.0001, 0.9999 );
      const pA = V20.clamp( ( (det.pA||0) * wDet ) + ( (mcResult && mcResult.pA) ? mcResult.pA * wMC : 0 ), 0.0001, 0.9999 );

      // normalize
      const ssum = pH + pD + pA;
      const npH = pH/ssum, npD = pD/ssum, npA = pA/ssum;

      // predicted score: if mc available use matrix mean or mode; else use Poisson means from lambdas
      let predicted = { home: 0, away: 0, method: 'poisson' };
      if(mcResult){
        predicted.method = 'mc';
        predicted.home = s(mcResult.avgGoals,0) * ( (adjustedLambda.lamH) / (adjustedLambda.lamH + adjustedLambda.lamA) ); // heuristic mean split
        predicted.away = s(mcResult.avgGoals,0) - predicted.home;
        // better: use matrix expected goals via sums
        try{
          const mat = mcResult.matrix || [];
          let meanH=0, meanA=0;
          for(let h=0; h<mat.length; h++){
            for(let a=0; a<mat[h].length; a++){
              const prob = mat[h][a] || 0;
              meanH += h*prob;
              meanA += a*prob;
            }
          }
          if(isFinite(meanH) && isFinite(meanA)){ predicted.home = meanH; predicted.away = meanA; predicted.method = 'mc_matrix'; }
        }catch(e){}
      } else {
        predicted.method = 'poisson';
        predicted.home = adjustedLambda.lamH;
        predicted.away = adjustedLambda.lamA;
      }

      // confidence: based on agreement between det and mc (if mc), SDI, and meta-consistency if available
      let conf = 0.6;
      try{
        const sdi = (V20.computeSDI && typeof V20.computeSDI === 'function') ? V20.computeSDI(adjustedLambda) : 0;
        const meta = (V20.computeMeta && typeof V20.computeMeta === 'function') ? V20.computeMeta(det, det, sdi) : 0.6;
        const agree = mcResult ? 1 - Math.abs((det.pH - mcResult.pH) + (det.pA - mcResult.pA)) : 1;
        conf = V20.clamp( 0.25*meta + 0.45*V20.clamp(agree,0,1) + 0.30*(1 - V20.clamp(Math.abs(sdi)/2,0,1)), 0.05, 0.98 );
      }catch(e){ conf = 0.6; }

      return {
        probabilities: { pH: npH, pD: npD, pA: npA },
        predictedScore: { home: Number(predicted.home.toFixed(3)), away: Number(predicted.away.toFixed(3)), method: predicted.method },
        confidence: Number((conf).toFixed(3)),
        components: { det: det, mc: mcResult, adjustedLambda: adjustedLambda }
      };
    }catch(e){
      return { probabilities: { pH:0.33,pD:0.34,pA:0.33 }, predictedScore: {home: s(adjustedLambda.lamH,1.2), away: s(adjustedLambda.lamA,1.0), method:'fallback'}, confidence: 0.5, components: {} };
    }
  };

  /* ---------------- convenience master function: computeMatchHybrid
     This reads available inputs and profiles, computes adjusted lambdas then probabilities.
     Inputs:
         baseLambda, homeName, awayName, ctx, tact, options
     Options forward to computeAdjustedLambda & computeUltraProbabilities
  */
  V20.Hybrid.computeMatchHybrid = function(baseLambda, homeName, awayName, ctx, tact, options){
    options = options || {};
    try{
      const hDNA = V20.TeamDNA.get(homeName) || {};
      const aDNA = V20.TeamDNA.get(awayName) || {};
      // merge profiles with Input addons (injury/finishing etc)
      const addons = V20.Inputs.getMatchAddons ? V20.Inputs.getMatchAddons() : {};
      const applied = V20.Inputs.applyToProfiles ? V20.Inputs.applyToProfiles(hDNA, aDNA, addons) : { home: hDNA, away: aDNA };
      const homeProfile = applied.home || hDNA;
      const awayProfile = applied.away || aDNA;

      // make sure tact not undefined
      tact = tact || { home: { pressIntensity: homeProfile.press || 5 }, away: { pressIntensity: awayProfile.press || 5 } };

      // 1) compute ultra TCI influence if available
      if(V20.Ultra && V20.Ultra.computeTCI){
        const tci = V20.Ultra.computeTCI({ home: homeProfile, away: awayProfile, tact, ctx, leagueKey: options.leagueKey, tierHint: options.tierHint, matchTypeKey: options.matchTypeKey });
        // merge result into ctx for further calculations (non-destructive)
        ctx = Object.assign({}, ctx || {}, { tempo: tci.tempo, chaos: tci.chaos, importance: tci.importance });
      }

      // 2) compute pressing results and attach as needed
      const pressRes = (V20.Ultra && V20.Ultra.computePressingMatch) ? V20.Ultra.computePressingMatch(homeProfile, awayProfile, tact) : null;
      if(pressRes){
        ctx = Object.assign({}, ctx || {}, { _ppdaHome: pressRes.homePPDA, _ppdaAway: pressRes.awayPPDA, _pressMatchFactor: pressRes.pressMatchFactor });
      }

      // 3) compute adjusted lambdas
      const adjusted = V20.Hybrid.computeAdjustedLambda(baseLambda, homeProfile, awayProfile, ctx, tact, options);

      // 4) compute probabilities (MC optional)
      const probs = V20.Hybrid.computeUltraProbabilities(adjusted, ctx, homeProfile, awayProfile, {
        mcUse: options.mcUse !== false,
        mcSimCount: options.mcSimCount || 1800,
        scoreCap: options.scoreCap || 6,
        mcWeight: s(options.mcWeight, 0.45)
      });

      // return merged result
      return {
        homeName, awayName, ctx,
        adjustedLambda: adjusted,
        probabilities: probs.probabilities,
        predictedScore: probs.predictedScore,
        confidence: probs.confidence,
        components: probs.components
      };
    }catch(e){
      return { probabilities: { pH:0.33,pD:0.34,pA:0.33 }, predictedScore: {home: baseLambda.lamH, away: baseLambda.lamA}, confidence: 0.5, error: e && e.message };
    }
  };

})(); // end MODULE 15
 /* ============================================================
   MODULE 16 — INFINITY SCORE MODEL
   - Complementary score model: uses adjusted lambda + PPDA + tempo/chaos
   - Outputs: predictedScore (mean/mode), OU probabilities, BTTS estimate, dominanceIndex
   - Paste AFTER MODULE 15
   ============================================================ */

(function(){
  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  V20.Infinity = V20.Infinity || {};

  // small helper: combine lambdas with PPDA & tempo/chaos modifiers
  V20.Infinity.adjustForContext = function(adjustedLambda, ctx, pressInfo, homeProfile, awayProfile){
    try{
      const lamH = s(adjustedLambda.lamH,1.2);
      const lamA = s(adjustedLambda.lamA,1.0);

      // tempo scaling
      const tempoF = (s(ctx.tempo,5) - 5)/5; // -1..+1
      const tempoScale = 1 + tempoF*0.08;

      // chaos increases variance (not mean) — we'll use for OU spread
      const chaosF = (s(ctx.chaos,5) - 5)/5;
      const chaosVar = V20.clamp(1 + chaosF*0.45, 0.7, 2.0);

      // press effect: low PPDA (aggressive) increases transitions -> slightly higher means
      const ppdaHome = s(pressInfo && pressInfo.homePPDA, null);
      const ppdaAway = s(pressInfo && pressInfo.awayPPDA, null);
      const ppdaEffectH = ppdaHome ? V20.clamp(1 + ((12 - ppdaHome)/40), 0.88, 1.15) : 1;
      const ppdaEffectA = ppdaAway ? V20.clamp(1 + ((12 - ppdaAway)/40), 0.88, 1.15) : 1;

      // finishing bias captured in profiles
      const finishH = s(homeProfile.finishingBias, 1);
      const finishA = s(awayProfile.finishingBias, 1);

      const outH = V20.clamp(lamH * tempoScale * ppdaEffectH * finishH, 0.02, 9.5);
      const outA = V20.clamp(lamA * tempoScale * ppdaEffectA * finishA, 0.02, 9.5);

      return { lamH: outH, lamA: outA, chaosVar };
    }catch(e){
      return { lamH: s(adjustedLambda.lamH,1.2), lamA: s(adjustedLambda.lamA,1.0), chaosVar:1 };
    }
  };

  // build OU probabilities (0.5,1.5,2.5,3.5) analytically from lamEff
  V20.Infinity.ouFromLambda = function(lamH, lamA){
    try{
      const lamEff = V20.clamp(lamH + lamA, 0.2, 12);
      const lines = [0.5,1.5,2.5,3.5];
      const out = {};
      lines.forEach(line=>{
        const cut = Math.floor(line);
        let under = 0;
        for(let k=0;k<=cut;k++) under += V20.poissonPMF(lamEff, k);
        out[line] = { under: under, over: 1-under };
      });
      return out;
    }catch(e){
      return { "0.5":{under:0.5,over:0.5},"1.5":{under:0.5,over:0.5},"2.5":{under:0.5,over:0.5},"3.5":{under:0.5,over:0.5} };
    }
  };

  // compute BTTS estimate (more nuanced: include finishing and PPDA)
  V20.Infinity.estimateBTTS = function(lamH, lamA, homeProfile, awayProfile, pressInfo){
    try{
      const base = V20.computeBTTS ? V20.computeBTTS({lamH,lamA}) : (1 - V20.poissonPMF(lamH,0) - V20.poissonPMF(lamA,0) + V20.poissonPMF(lamH,0)*V20.poissonPMF(lamA,0));
      // finishing and weather adjustments
      const finAdj = (s(homeProfile.finishingBias,1) + s(awayProfile.finishingBias,1))/2;
      const ppdaAdj = (pressInfo && pressInfo.homePPDA && pressInfo.awayPPDA) ? ( (12 - pressInfo.homePPDA) + (12 - pressInfo.awayPPDA) )/24 : 0;
      const score = V20.clamp(base * (0.85 + (finAdj-1)*0.12 + ppdaAdj*0.12), 0, 1);
      return score;
    }catch(e){
      return 0.5;
    }
  };

  // compute dominance index: how lopsided chance creation is (0..1, 0.5 neutral)
  V20.Infinity.dominanceIndex = function(lamH, lamA, mat){
    try{
      const diff = Math.abs(lamH - lamA) / Math.max(1, (lamH + lamA)/2);
      // if matrix available, augment with goal share
      let share = 0.5;
      if(mat && mat.length){
        let mh=0, ma=0;
        for(let h=0; h<mat.length; h++){
          for(let a=0; a<mat[h].length; a++){
            const p = mat[h][a]||0;
            mh += h * p; ma += a * p;
          }
        }
        if(isFinite(mh+ma) && (mh+ma) > 0) share = mh / (mh+ma);
      } else {
        share = lamH / (lamH + lamA);
      }
      const idx = V20.clamp(0.5 + (share - 0.5) * (1 + diff*0.6), 0, 1);
      return idx;
    }catch(e){
      return 0.5;
    }
  };

  // main interface
  V20.Infinity.computeScoreModel = function(adjustedLambda, ctx, homeProfile, awayProfile, pressInfo, options){
    options = options || {};
    try{
      const adj = V20.Infinity.adjustForContext(adjustedLambda, ctx || {}, pressInfo || {}, homeProfile || {}, awayProfile || {});
      const lamH = s(adj.lamH, adjustedLambda.lamH || 1.2);
      const lamA = s(adj.lamA, adjustedLambda.lamA || 1.0);
      const chaosVar = s(adj.chaosVar, 1);

      const ou = V20.Infinity.ouFromLambda(lamH, lamA);
      const btts = V20.Infinity.estimateBTTS(lamH, lamA, homeProfile || {}, awayProfile || {}, pressInfo || {});
      // predicted score means
      const meanH = lamH;
      const meanA = lamA;

      // score distribution (small MC if requested)
      let mc = null;
      if(options.mcUse !== false && V20.monteCarlo){
        const simC = s(options.mcSimCount, 1400);
        const cap = s(options.scoreCap, 6);
        mc = V20.monteCarlo({lamH, lamA}, ctx || {}, simC, cap, homeProfile || {}, awayProfile || {}, { home:{ pressIntensity: homeProfile.press }, away:{ pressIntensity: awayProfile.press } });
      }

      const dominance = V20.Infinity.dominanceIndex(lamH, lamA, mc && mc.matrix ? mc.matrix : null);

      return {
        lamH, lamA, chaosVar,
        meanGoals: { home: Number(meanH.toFixed(3)), away: Number(meanA.toFixed(3)) },
        ou, btts: Number((btts).toFixed(3)),
        dominance: Number((dominance).toFixed(3)),
        mc
      };
    }catch(e){
      return { lamH: adjustedLambda.lamH, lamA: adjustedLambda.lamA, meanGoals:{home:adjustedLambda.lamH, away:adjustedLambda.lamA}, ou:null, btts:0.5, dominance:0.5, mc:null };
    }
  };

})(); // end MODULE 16
  /* ============================================================
   MODULE 17 — COMPOSITE FINAL PICKER
   - Combine PSZ fused probabilities + Hybrid + Infinity signals
   - Produce finalPick: { outcome, confidence, reason, scoreLine, ouPick, bttsPick }
   - Paste AFTER MODULE 16
   ============================================================ */

(function(){
  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  V20.Composite = V20.Composite || {};

  // simple helper to pick OU line from ou object
  function pickOULine(ouObj){
    // ouObj expected keys: "0.5","1.5","2.5","3.5" with .over/.under
    if(!ouObj) return { line:2.5, pick:'under', conf:0.5 };
    const lines = [0.5,1.5,2.5,3.5];
    let best = null;
    lines.forEach(l=>{
      const k = String(l);
      const over = s(ouObj[k] && ouObj[k].over, ouObj[l] && ouObj[l].over);
      const under = s(ouObj[k] && ouObj[k].under, ouObj[l] && ouObj[l].under);
      const pref = over > under ? {line:l,pick:'over',conf:over} : {line:l,pick:'under',conf:under};
      if(!best || pref.conf > best.conf) best = pref;
    });
    return best || { line:2.5, pick:'under', conf:0.5 };
  }

  // merge probabilities with weights
  V20.Composite.fuseSignals = function(pszFused, hybrid, infinityModel){
    try{
      pszFused = pszFused || { final:{ pH:0.33,pD:0.34,pA:0.33 } };
      hybrid = hybrid || { probabilities:{ pH:0.33,pD:0.34,pA:0.33 }, confidence:0.5 };
      infinityModel = infinityModel || { meanGoals:{home:1.2,away:1.0}, btts:0.5 };

      // weighting strategy:
      // - PSZ fused (core) : 0.45
      // - Hybrid Ultra (data+press+xG) : 0.35
      // - Infinity model (score-driven) : 0.20
      const wPSZ = 0.45, wHY = 0.35, wIN = 0.20;

      const pH = V20.clamp( (pszFused.final.pH * wPSZ) + (hybrid.probabilities.pH * wHY) + ((infinityModel.meanGoals.home/(infinityModel.meanGoals.home+infinityModel.meanGoals.away || 1)) * wIN ), 0.0001, 0.9999 );
      const pA = V20.clamp( (pszFused.final.pA * wPSZ) + (hybrid.probabilities.pA * wHY) + ((infinityModel.meanGoals.away/(infinityModel.meanGoals.home+infinityModel.meanGoals.away || 1)) * wIN ), 0.0001, 0.9999 );
      const pD = V20.clamp( (pszFused.final.pD * wPSZ) + (hybrid.probabilities.pD * wHY) + ( (1 - ( (infinityModel.meanGoals.home+infinityModel.meanGoals.away)/ ( (infinityModel.meanGoals.home+infinityModel.meanGoals.away) + 2) )) * wIN ), 0.0001, 0.9999 );

      // normalize
      const ssum = pH + pD + pA;
      const npH = pH/ssum, npD = pD/ssum, npA = pA/ssum;

      // combined confidence: weighted conf from components
      const confPSZ = (pszFused.final && pszFused.final.pH) ? (1 - V20.computeUncertainty(pszFused.final.pH, pszFused.final.pD, pszFused.final.pA).score/100) : 0.6;
      const confHY  = s(hybrid.confidence, 0.55);
      const confIN  = 1 - Math.abs(infinityModel.dominance - 0.5) * 2; // higher dominance -> lower uncertainty? invert later
      const combinedConf = V20.clamp( wPSZ*confPSZ + wHY*confHY + wIN*confIN, 0.05, 0.98 );

      // final predicted score line (rounded)
      const scoreH = Number((hybrid.predictedScore.home || infinityModel.meanGoals.home || 1.0).toFixed(2));
      const scoreA = Number((hybrid.predictedScore.away || infinityModel.meanGoals.away || 1.0).toFixed(2));

      // pick outcome
      let outcome = 'draw';
      if(npH > npA && npH > npD) outcome = 'home';
      else if(npA > npH && npA > npD) outcome = 'away';
      else outcome = 'draw';

      // OU pick from infinityModel ou if present else from blended
      const ouPick = pickOULine(infinityModel.ou || V20.Infinity.ouFromLambda((hybrid.adjustedLambda||{}).lamH || 1.2, (hybrid.adjustedLambda||{}).lamA || 1.0));
      const bttsPick = (infinityModel.btts || hybrid.confidence > 0.6) ? 'yes' : 'no';
      const reason = { weights:{ wPSZ,wHY,wIN }, components: { psz: pszFused.final, hybrid: hybrid.probabilities, infinity: infinityModel.meanGoals } };

      return {
        probabilities: { pH: npH, pD: npD, pA: npA },
        outcome, confidence: Number((combinedConf).toFixed(3)),
        scoreLine: { home: scoreH, away: scoreA },
        ouPick, bttsPick, reason
      };
    }catch(e){
      return { probabilities:{pH:0.33,pD:0.34,pA:0.33}, outcome:'draw', confidence:0.5, scoreLine:{home:1,away:1}, ouPick:{line:2.5,pick:'under',conf:0.5}, bttsPick:'yes', reason:{} };
    }
  };

})(); // end MODULE 17
  /* ============================================================
   MODULE 18 — FULL INTEGRATION: Hybrid + Infinity + Composite -> runPrimeZero
   - Patch safe: wraps existing V20.runPrimeZero and augments outputs
   - Paste AFTER MODULE 17
   ============================================================ */

(function(){

  // helper
  function s(v,d=0){ return V20 && V20._safeNum ? V20._safeNum(v,d) : (isFinite(Number(v))?Number(v):d); }

  // backup original runner if exists (should be existing Module10)
  const originalRunner = V20.runPrimeZero && typeof V20.runPrimeZero === 'function' ? V20.runPrimeZero : null;

  // define enhanced runner
  V20.runPrimeZero = function(){
    // run original first (so variables, window._V20_MATCH_TEMPLATE, etc. are set)
    try{
      if(originalRunner) originalRunner();
    }catch(e){
      // proceed anyway — original may have thrown earlier; we still try to continue
      console.warn('Original runPrimeZero threw:', e && e.message);
    }

    try{
      // read basic UI values (safe)
      const homeTeam = (document.getElementById('home_team')?.value || '').trim();
      const awayTeam = (document.getElementById('away_team')?.value || '').trim();

      // base lambda as used by original (attempt to read from window computed objects)
      const lamH_ui = s(document.getElementById('lamH')?.value, 1.2);
      const lamA_ui = s(document.getElementById('lamA')?.value, 1.0);
      const baseLambda = { lamH: lamH_ui, lamA: lamA_ui };

      // rebuild ctx/home/away/tact as original (safe)
      const ctx = {
        tempo: s(document.getElementById('tempo')?.value,5),
        chaos: s(document.getElementById('chaos')?.value,5),
        importance: s(document.getElementById('importance')?.value,5),
        isDerby: !!(window._V20_MATCH_TEMPLATE && window._V20_MATCH_TEMPLATE.isDerby)
      };
      const homeProfileRaw = V20.TeamDNA.get(homeTeam) || {};
      const awayProfileRaw = V20.TeamDNA.get(awayTeam) || {};
      // apply extra inputs
      const addons = V20.Inputs.getMatchAddons ? V20.Inputs.getMatchAddons() : {};
      const applied = V20.Inputs.applyToProfiles ? V20.Inputs.applyToProfiles(homeProfileRaw, awayProfileRaw, addons) : { home: homeProfileRaw, away: awayProfileRaw };
      const homeProfile = applied.home || homeProfileRaw;
      const awayProfile = applied.away || awayProfileRaw;

      const tact = {
        home: { pressIntensity: s(document.getElementById('home_press')?.value, homeProfile.press || 5) },
        away: { pressIntensity: s(document.getElementById('away_press')?.value, awayProfile.press || 5) }
      };

      // compute pressing info
      const pressInfo = (V20.Ultra && V20.Ultra.computePressingMatch) ? V20.Ultra.computePressingMatch(homeProfile, awayProfile, tact) : null;

      // compute hybrid
      const hybrid = V20.Hybrid ? V20.Hybrid.computeMatchHybrid(baseLambda, homeTeam, awayTeam, ctx, tact, { mcUse:true, mcSimCount:1200 }) : null;

      // compute infinity model
      const infinity = V20.Infinity ? V20.Infinity.computeScoreModel(hybrid && hybrid.adjustedLambda ? hybrid.adjustedLambda : baseLambda, ctx, homeProfile, awayProfile, pressInfo, { mcUse:true, mcSimCount:1000, scoreCap:6 }) : null;

      // composite fuse
      const pszFused = window._V20_LAST_FUSED_RESULT || null; 
      // attempt to capture current PSZ fused from previous run if originalRunner set window._V20_LAST_FUSED_RESULT there.
      // if not present, build minimal fused from available data
      let fusedForComposite = pszFused;
      if(!fusedForComposite){
        // try building a minimal fused using existing V20.fuseOutputs inputs if available
        try{
          // attempt to reconstruct det/detChaos/mc from hybrid.components if possible
          const det = V20.detSim ? V20.detSim(baseLambda) : { pH:0.33,pD:0.34,pA:0.33 };
          const detChaos = V20.chaosModel ? V20.detSim(V20.chaosModel(baseLambda, ctx)) : det;
          const mcMinimal = V20.monteCarlo ? V20.monteCarlo(hybrid && hybrid.adjustedLambda ? hybrid.adjustedLambda : baseLambda, ctx, 800, 6, homeProfile, awayProfile, tact) : { pH:det.pH, pD:det.pD, pA:det.pA, avgGoals: (det.pH*1.5 + det.pA*1.0) };
          const zeroProb = V20.singularityZero ? V20.singularityZero({ pH:det.pH, pD:det.pD, pA:det.pA }, V20.computeRisk ? V20.computeRisk(ctx,tact):0.5, V20.computeFragility?V20.computeFragility(ctx,homeProfile,awayProfile):0.5, 0.5, 0.5, 0) : { pH:det.pH, pD:det.pD, pA:det.pA };
          fusedForComposite = V20.fuseOutputs ? V20.fuseOutputs(det, detChaos, mcMinimal, zeroProb) : { final:{ pH:det.pH, pD:det.pD, pA:det.pA } };
          // store for later
          window._V20_LAST_FUSED_RESULT = fusedForComposite;
        }catch(e){
          fusedForComposite = { final:{ pH:0.33,pD:0.34,pA:0.33 } };
        }
      }

      // composite pick
      const composite = V20.Composite ? V20.Composite.fuseSignals(fusedForComposite, hybrid || {}, infinity || {}) : null;

      // update textarea report: append Ultra results
      try{
        const outEl = document.getElementById('output');
        if(outEl){
          let extra = "\n\n=== ULTRA HYBRID LAYER ===\n";
          if(hybrid){
            extra += `Hybrid Confidence : ${(hybrid.confidence*100).toFixed(1)}%\n`;
            extra += `Hybrid Probabilities: H ${(hybrid.probabilities.pH*100).toFixed(1)}% | D ${(hybrid.probabilities.pD*100).toFixed(1)}% | A ${(hybrid.probabilities.pA*100).toFixed(1)}%\n`;
            extra += `Hybrid Predicted Score: ${hybrid.predictedScore.home} - ${hybrid.predictedScore.away} (method: ${hybrid.predictedScore.method})\n`;
          }
          if(infinity){
            extra += `Infinity Mean Goals: H ${infinity.meanGoals.home} | A ${infinity.meanGoals.away}\n`;
            extra += `Infinity BTTS: ${(infinity.btts*100).toFixed(1)}% | Dominance: ${(infinity.dominance*100).toFixed(1)}%\n`;
            // show OU
            if(infinity.ou){
              Object.keys(infinity.ou).forEach(k=>{
                extra += `OU ${k} -> Over ${(infinity.ou[k].over*100).toFixed(1)}% | Under ${(infinity.ou[k].under*100).toFixed(1)}%\n`;
              });
            }
          }
          if(composite){
            extra += `\n=== COMPOSITE PICK ===\n`;
            extra += `Outcome Pick: ${composite.outcome.toUpperCase()} (Confidence ${(composite.confidence*100).toFixed(1)}%)\n`;
            extra += `Scoreline: ${composite.scoreLine.home} - ${composite.scoreLine.away}\n`;
            extra += `OU Pick: ${composite.ouPick.pick.toUpperCase()} ${composite.ouPick.line} (conf ${(composite.ouPick.conf*100).toFixed(1)}%)\n`;
            extra += `BTTS Pick: ${composite.bttsPick.toUpperCase()}\n`;
          }

          // append to existing output
          outEl.value = (outEl.value || '') + extra;
        }
      }catch(e){ /* ignore UI fail */ }

      // store last results globally for debug / reuse
      window._V20_ULTRA = { hybrid: hybrid || null, infinity: infinity || null, composite: composite || null, pressInfo };

      // console debug for developers
      try{ console.debug('V20 ULTRA', window._V20_ULTRA); }catch(e){}

      // update bars/wheel optionally: if composite exists, map probabilities
      try{
        if(composite && document.getElementById('bar_home')){
          // map composite probabilities to bars
          const pH = s(composite.probabilities.pH, 0.33);
          const pD = s(composite.probabilities.pD, 0.34);
          const pA = s(composite.probabilities.pA, 0.33);
          document.getElementById('bar_home').style.width = (Math.round(pH*100)) + '%';
          document.getElementById('bar_draw').style.width = (Math.round(pD*100)) + '%';
          document.getElementById('bar_away').style.width = (Math.round(pA*100)) + '%';
          try{ renderWheel({ pH, pD, pA }); }catch(e){}
        }
      }catch(e){}

    }catch(err){
      console.error('V20 ULTRA integration error', err);
    }
  }; // end patched runPrimeZero

  // mark integration applied
  V20._ULTRA_INTEGRATED = true;

})(); // end MODULE 18
  /* ============================================================
   MODULE 8 — CHAOS / META / SINGULARITY MODELS + META METRICS
   (defines chaosModel, computeMeta, singularityZero, computeRisk,
    computeFragility, computeFlow, computeMomentumSwing, computeSDI)
   ============================================================ */

/* ---------------- chaosModel (stable, bounded) ----------------
   - Adjusts base lambda by chaos context (non-destructive)
   - Always returns safe lamH/lamA within bounds
*/
V20.chaosModel = function(baseLambda, ctx){
  baseLambda = baseLambda || {};
  ctx = ctx || {};
  const lamH = V20._safeNum(baseLambda.lamH, 1.2);
  const lamA = V20._safeNum(baseLambda.lamA, 1.0);
  const chaos = V20._safeNum(ctx.chaos, 5);
  // map chaos [-] -> multiplier in reasonable band
  const chaosF = (chaos - 5) / 5; // -1 .. +1
  const factorH = 1 + V20.clamp(chaosF * 0.22 + ((ctx.tempo||5)-5)/50, -0.35, 0.45);
  const factorA = 1 + V20.clamp(chaosF * 0.22 + ((ctx.tempo||5)-5)/50, -0.35, 0.45);
  return {
    lamH: V20.clamp(lamH * factorH, 0.12, 7.0),
    lamA: V20.clamp(lamA * factorA, 0.12, 7.0)
  };
};

/* ---------------- computeRisk ----------------
   - simple combined risk from chaos + press imbalance + ref impact
   - returns 0..1
*/
V20.computeRisk = function(ctx, tact){
  ctx = ctx || {};
  tact = tact || {};
  const chaos = V20._safeNum(ctx.chaos, 5);
  const pressH = V20._safeNum(tact.home?.pressIntensity, 5);
  const pressA = V20._safeNum(tact.away?.pressIntensity, 5);
  // referee impact may be stored in ctx.refPenalty
  const refPenalty = V20._safeNum(ctx.refPenalty, 0);

  const chaosPart = V20.clamp((chaos - 4) / 6, 0, 1);         // higher chaos => higher risk
  const pressPart = V20.clamp(Math.abs(pressH - pressA) / 10, 0, 1); // press mismatch
  const refPart = V20.clamp(refPenalty, 0, 1);

  // weighted sum, normalized
  const raw = 0.5 * chaosPart + 0.35 * pressPart + 0.15 * refPart;
  return V20.clamp(raw, 0, 1);
};

/* ---------------- computeFragility ----------------
   - fragility: how brittle the match is to shocks (low stability => fragile)
   - returns 0..1 (1 = very fragile)
*/
V20.computeFragility = function(ctx, home, away){
  ctx = ctx || {};
  home = home || {};
  away = away || {};
  const stH = V20._safeNum(home.stability, 5);
  const stA = V20._safeNum(away.stability, 5);
  const avgSt = (stH + stA) / 2;
  const chaos = V20._safeNum(ctx.chaos, 5);
  // lower stability and higher chaos => more fragility
  const frag = V20.clamp(((6 - avgSt) / 6) * 0.7 + ((chaos - 5) / 10) * 0.3, 0, 1);
  return frag;
};

/* ---------------- computeFlow ----------------
   - measures match control flow leaning towards home/away
   - returns 0..1 where >0.5 => home advantage in flow
*/
V20.computeFlow = function(ctx, home, away, tact, pattern){
  ctx = ctx || {}; home = home || {}; away = away || {}; tact = tact || {}; pattern = pattern || {};
  const momH = V20._safeNum(home.momentum, 5);
  const momA = V20._safeNum(away.momentum, 5);
  const pressH = V20._safeNum(tact.home?.pressIntensity, 5);
  const pressA = V20._safeNum(tact.away?.pressIntensity, 5);

  // base flow from momentum difference
  let flow = 0.5 + ((momH - momA) / 40);
  // pressing tilt and tactical flex adjust
  flow += ((pressH - pressA) / 200);
  // pattern influence (control increases home flow slightly)
  flow += V20._safeNum(pattern.control, 0) * 0.02;
  return V20.clamp(flow, 0, 1);
};

/* ---------------- computeMomentumSwing ----------------
   - magnitude of momentum swing (0..1)
*/
V20.computeMomentumSwing = function(home, away){
  home = home || {}; away = away || {};
  const momH = V20._safeNum(home.momentum, 5);
  const momA = V20._safeNum(away.momentum, 5);
  return V20.clamp(Math.abs(momH - momA) / 10, 0, 1);
};

/* ---------------- computeSDI ----------------
   - Simple SDI (lambda difference scaled)
   - used in computeMeta to penalize big asymmetry
*/
V20.computeSDI = function(godHL){
  godHL = godHL || {};
  const lamH = V20._safeNum(godHL.lamH, 1);
  const lamA = V20._safeNum(godHL.lamA, 1);
  return V20.clamp(Math.abs(lamH - lamA) / Math.max(1, (lamH + lamA)/2), 0, 2);
};

/* ---------------- computeMeta ----------------
   - measures agreement between deterministic and chaos outputs and SDI
   - returns 0..1 (1 = perfect meta-consistency)
*/
V20.computeMeta = function(det, chaosDet, sdi){
  if(!det || !chaosDet) return 0.5;
  const detGap = (det.pH || 0) - (det.pA || 0);
  const chaosGap = (chaosDet.pH || 0) - (chaosDet.pA || 0);
  const gapDiff = Math.abs(detGap - chaosGap);
  sdi = V20._safeNum(sdi, 0);
  // meta lower if gaps differ and SDI large
  let meta = 1 - (gapDiff * 0.45 + Math.abs(sdi) * 0.20);
  meta = V20.clamp(meta, 0, 1);
  return meta;
};

/* ---------------- singularityZero (final correction) ----------------
   - Takes base probabilities (raw blend) and adjusts using risk, fragility,
     meta-consistency, flow and momentum swing.
   - Returns normalized {pH,pD,pA}
*/
V20.singularityZero = function(raw, risk, frag, meta, flow, swing){
  raw = raw || {};
  // fallback raw probabilities
  let pH = V20._safeNum(raw.pH, 1/3);
  let pD = V20._safeNum(raw.pD, 1/3);
  let pA = V20._safeNum(raw.pA, 1/3);

  // Safeguard: normalize early
  let s = pH + pD + pA;
  if(!isFinite(s) || s <= 0){ pH = pD = pA = 1/3; s = 1; }
  pH /= s; pD /= s; pA /= s;

  // normalize weights
  risk = V20._safeNum(risk, 0.5);
  frag = V20._safeNum(frag, 0.5);
  meta = V20._safeNum(meta, 0.5);
  flow = V20._safeNum(flow, 0.5);
  swing = V20._safeNum(swing, 0);

  // flow drives tilt between H and A (flow>0.5 favors home)
  const flowTilt = V20.clamp((flow - 0.5) * 0.18 + (swing * 0.06), -0.25, 0.25);

  // fragility pulls away from extremes towards draw when fragile
  const fragPull = V20.clamp((frag - 0.5) * 0.36, -0.25, 0.4);

  // meta reduces overconfidence in side probabilities (push to draw if meta low)
  const metaDrawBoost = V20.clamp((0.5 - meta) * 0.65, -0.2, 0.7);

  // risk spreads probs towards center (higher risk -> more uncertainty)
  const riskSpread = V20.clamp((risk - 0.5) * 0.28, -0.15, 0.3);

  // apply flow tilt
  const gap = pH - pA;
  pH = pH + gap * flowTilt;
  pA = pA - gap * flowTilt;

  // apply frag pull: reduce both sides by fragPull, move into draw
  pH = pH * (1 - fragPull) ;
  pA = pA * (1 - fragPull) ;
  pD = pD + ( (fragPull) * 0.9 ); // mostly to draw

  // apply meta draw boost
  pD = pD + metaDrawBoost * (1 - pD);

  // apply risk spread (blend with uniform)
  pH = pH * (1 - riskSpread) + (1/3) * riskSpread;
  pD = pD * (1 - riskSpread) + (1/3) * riskSpread;
  pA = pA * (1 - riskSpread) + (1/3) * riskSpread;

  // final normalization & safety clamps
  s = pH + pD + pA;
  if(!isFinite(s) || s <= 0){ pH = pD = pA = 1/3; s = 1; }
  pH /= s; pD /= s; pA /= s;

  return { pH: V20.clamp(pH, 0.0001, 0.9999), pD: V20.clamp(pD, 0.0001, 0.9999), pA: V20.clamp(pA, 0.0001, 0.9999) };
};

/* ============================================================
   MODULE 8 DONE
   ============================================================ */
/* ============================================================
   MODULE 9 — PROBABILITY WHEEL RENDERER (SVG)
   ============================================================ */

/* Draw a circular wheel split into H-D-A sections */
function renderWheel(probs){
  const wheel = document.getElementById("prob_wheel");
  if(!wheel) return;

  let pH = V20._safeNum(probs.pH, 1/3);
  let pD = V20._safeNum(probs.pD, 1/3);
  let pA = V20._safeNum(probs.pA, 1/3);

  let s = pH + pD + pA;
  if(!isFinite(s) || s<=0) s = 1;
  pH /= s; pD /= s; pA /= s;

  /* End angles in degrees */
  const angH = pH * 360;
  const angD = angH + pD * 360;
  const angA = 360;

  /* Arc builder */
  function arcPath(startAng, endAng, r){
    const rad = Math.PI/180;
    const x1 = r * Math.cos(startAng*rad);
    const y1 = r * Math.sin(startAng*rad);
    const x2 = r * Math.cos(endAng*rad);
    const y2 = r * Math.sin(endAng*rad);
    const large = (endAng - startAng) > 180 ? 1 : 0;
    return `M0 0 L${x1} ${y1} A${r} ${r} 0 ${large} 1 ${x2} ${y2} Z`;
  }

  /* Build SVG */
  const r = 90;
  const svg = `
    <svg width="220" height="220" viewBox="-110 -110 220 220">
      <!-- background -->
      <circle cx="0" cy="0" r="${r}" fill="rgba(255,255,255,0.03)" />

      <!-- Home -->
      <path d="${arcPath(0, angH, r)}" fill="#06b6d4" opacity="0.88"></path>
      <!-- Draw -->
      <path d="${arcPath(angH, angD, r)}" fill="#4ade80" opacity="0.85"></path>
      <!-- Away -->
      <path d="${arcPath(angD, angA, r)}" fill="#8b5cf6" opacity="0.85"></path>

      <!-- Center dot -->
      <circle cx="0" cy="0" r="6" fill="rgba(255,255,255,0.7)"></circle>

      <!-- Labels -->
      <text x="0" y="-105" fill="#06b6d4" font-size="12" text-anchor="middle">Home ${(pH*100).toFixed(1)}%</text>
      <text x="0" y="117" fill="#8b5cf6" font-size="12" text-anchor="middle">Away ${(pA*100).toFixed(1)}%</text>
      <text x="-105" y="4" fill="#4ade80" font-size="12" text-anchor="start">Draw ${(pD*100).toFixed(1)}%</text>
    </svg>
  `;

  wheel.innerHTML = svg;
}
/* ============================================================
   MODULE 10 — RUN ENGINE (final) & UI bindings
   ============================================================ */

(function(){

  // safe DOM helpers
  function el(id){ return document.getElementById(id); }
  function setBar(id, frac){
    try{ const e = el(id); if(!e) return; const w = Math.max(0, Math.min(100, Math.round((frac||0)*100))); e.style.width = w + '%'; }catch(e){}
  }

  // OU analytic helper (simple)
  function computeOUBlend(godHL, ctx, mc){
    const totalLam = V20._safeNum(godHL.lamH,1) + V20._safeNum(godHL.lamA,1);
    let lamEff = totalLam * (1 + ((V20._safeNum(ctx.chaos,5)-5)/5)*0.10 + ((V20._safeNum(ctx.tempo,5)-5)/5)*0.05);
    lamEff = V20.clamp(lamEff, 0.5, 6.5);
    const lines = [0.5,1.5,2.5,3.5];
    const ou={};
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under = 0;
      for(let k=0;k<=cut;k++) under += V20.poissonPMF(lamEff,k);
      ou[line] = { under: under, over: 1-under };
    });
    // MC version
    const ouMC = {};
    const mat = mc.matrix || [];
    const cap = mc.scoreCap || (mat.length-1);
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under=0, over=0;
      for(let h=0; h<=cap; h++){
        for(let a=0; a<=cap; a++){
          const freq = (mat[h] && mat[h][a])? mat[h][a] : 0;
          if(h+a <= cut) under += freq; else over += freq;
        }
      }
      ouMC[line] = { under: under, over: over };
    });
    // blend weights
    const godPat = mc.pattern || { chaotic:0, swing:0 };
    const patternChaos = (godPat.chaotic||0) + (godPat.swing||0)*0.6;
    const wMC = 0.40 + 0.40 * Math.max(0, patternChaos);
    const wAN = 1 - wMC;
    const out = {};
    lines.forEach(k=>{
      out[k] = { over: ou[k].over*wAN + (ouMC[k].over||0)*wMC, under: ou[k].under*wAN + (ouMC[k].under||0)*wMC };
    });
    return out;
  }

  // main runner
  V20.runPrimeZero = function(){
    const outEl = el('output');
    if(!outEl) return;

    try{
      // --- read inputs ---
      const homeTeam = (el('home_team')?.value||'').trim();
      const awayTeam = (el('away_team')?.value||'').trim();

      const lamH = V20._safeNum(el('lamH')?.value, 1.20);
      const lamA = V20._safeNum(el('lamA')?.value, 1.00);

      let tempo = V20._safeNum(el('tempo')?.value, 5);
      let chaos = V20._safeNum(el('chaos')?.value, 5);
      let importance = V20._safeNum(el('importance')?.value, 5);

      const home_st = V20._safeNum(el('home_st')?.value, 5);
      const away_st = V20._safeNum(el('away_st')?.value, 5);
      const home_mom = V20._safeNum(el('home_mom')?.value, 5);
      const away_mom = V20._safeNum(el('away_mom')?.value, 5);

      const home_press = V20._safeNum(el('home_press')?.value, 5);
      const away_press = V20._safeNum(el('away_press')?.value, 5);
      const home_flex = V20._safeNum(el('home_flex')?.value, 0.5);
      const away_flex = V20._safeNum(el('away_flex')?.value, 0.5);

      let simCount = V20._safeNum(el('simCount')?.value, NaN);
      let scoreCap = V20._safeNum(el('scoreCap')?.value, NaN);
      if(!isFinite(simCount)) simCount = undefined;
      if(!isFinite(scoreCap)) scoreCap = undefined;

      // parse optional JSON config
      let jsonCfg = null;
      try{ const txt = el('json_config')?.value || ''; if(txt && txt.trim().length) jsonCfg = JSON.parse(txt); }catch(e){ jsonCfg = null; }

      // read weather and referee (simple)
      const weatherKey = (el('weather')?.value || '').toString();
      const refStrict = V20._safeNum(el('ref_strict')?.value, 5);
      const refProfile = { cardsPerGame: 2.5 + (refStrict-5)*0.6, foulsPerGame: 20 + (refStrict-5)*3, penaltyFreq: 0.06 + (refStrict-5)*0.008, homeBias: 0 };

      // build base structures
      const baseLambda = { lamH, lamA };
      let ctx = { tempo, chaos, importance, isDerby:false };
      const home = { stability: home_st, momentum: home_mom, flex: home_flex };
      const away = { stability: away_st, momentum: away_mom, flex: away_flex };
      const tact = { home: { pressIntensity: home_press, flex: home_flex }, away: { pressIntensity: away_press, flex: away_flex } };

      // apply match type if user selected (also keep template)
      const mtSel = (el('match_type')?.value || 'normal');
      if(V20.MatchType && V20.MatchType.templates && V20.MatchType.templates[mtSel]){
        const mt = V20.MatchType.templates[mtSel];
        ctx.tempo = V20._safeNum(mt.tempo, ctx.tempo);
        ctx.chaos = V20._safeNum(mt.chaos, ctx.chaos);
        ctx.importance = V20._safeNum(mt.importance, ctx.importance);
        ctx.isDerby = !!mt.isDerby;
        window._V20_MATCH_TEMPLATE = Object.assign({name: mtSel}, mt);
      } else {
        window._V20_MATCH_TEMPLATE = null;
      }

      // apply weather & referee
      if(V20.Weather) ctx = V20.Weather.applyToContext(ctx, weatherKey || 'normal');
      if(V20.RII) ctx = V20.RII.applyToCtx(ctx, refProfile);

      // if json config available, apply overrides (safe)
      if(jsonCfg){
        if(jsonCfg.lamH) baseLambda.lamH = V20._safeNum(jsonCfg.lamH, baseLambda.lamH);
        if(jsonCfg.lamA) baseLambda.lamA = V20._safeNum(jsonCfg.lamA, baseLambda.lamA);
        if(jsonCfg.tempo) ctx.tempo = V20._safeNum(jsonCfg.tempo, ctx.tempo);
        if(jsonCfg.chaos) ctx.chaos = V20._safeNum(jsonCfg.chaos, ctx.chaos);
      }

      // integrate TPM if available
      try{
        const hTPM = V20.TeamDNA.get(homeTeam) || {};
        const aTPM = V20.TeamDNA.get(awayTeam) || {};
        // override some fields if available
        if(hTPM.stability) home.stability = hTPM.stability;
        if(hTPM.momentum) home.momentum = hTPM.momentum;
        if(hTPM.press) tact.home.pressIntensity = hTPM.press;
        if(hTPM.flex) tact.home.flex = hTPM.flex;
        if(aTPM.stability) away.stability = aTPM.stability;
        if(aTPM.momentum) away.momentum = aTPM.momentum;
        if(aTPM.press) tact.away.pressIntensity = aTPM.press;
        if(aTPM.flex) tact.away.flex = aTPM.flex;
      }catch(e){ /* ignore */ }

      // Compute integrator final lambda (use Integrator if present)
      let integrMeta = null;
      let finalLambda = Object.assign({}, baseLambda);
      try{
        if(V20.Integrator && typeof V20.Integrator.computeFinalLambdas === 'function'){
          integrMeta = V20.Integrator.computeFinalLambdas(baseLambda, ctx, null, {}, {}, tact, { weather: weatherKey, referee: refProfile, homeTeamName: homeTeam, awayTeamName: awayTeam });
          finalLambda = { lamH: integrMeta.lamH || baseLambda.lamH, lamA: integrMeta.lamA || baseLambda.lamA };
        } else {
          // fallback: use hyperLambda
          finalLambda = V20.hyperLambda ? V20.hyperLambda(baseLambda, ctx, home, away, tact) : finalLambda;
        }
      }catch(e){
        finalLambda = baseLambda;
      }

      // deterministic baseline
      const det = V20.detSim(baseLambda);
      const chaosL = V20.chaosModel ? V20.chaosModel(baseLambda, ctx) : baseLambda;
      const detChaos = V20.detSim(chaosL);

      // monte carlo
      const mc = V20.monteCarlo(finalLambda, ctx, simCount, scoreCap, home, away, tact);

      // god objects
      const godHL = mc.hyperLambda && mc.hyperLambda.lamH ? mc.hyperLambda : (integrMeta && integrMeta.hyperLambda ? integrMeta.hyperLambda : finalLambda);
      const godPat = mc.pattern || (integrMeta && integrMeta.pattern) || { control:0.25, swing:0.25, stalled:0.25, chaotic:0.25 };

      // base blend
      const baseBlend = { pH: (det.pH + detChaos.pH + mc.pH)/3, pD: (det.pD + detChaos.pD + mc.pD)/3, pA: (det.pA + detChaos.pA + mc.pA)/3 };

      // meta calculations
      const risk01 = V20.computeRisk ? V20.computeRisk(ctx, tact) : 0.5;
      const frag01 = V20.computeFragility ? V20.computeFragility(ctx, home, away) : 0.5;
      const sdi = V20.computeSDI ? V20.computeSDI(godHL) : 0;
      const meta01 = V20.computeMeta ? V20.computeMeta(det, detChaos, sdi) : 0.5;
      const flowVal = V20.computeFlow ? V20.computeFlow(ctx, home, away, tact, godPat) : 0.5;
      const swingVal = V20.computeMomentumSwing ? V20.computeMomentumSwing(home, away) : 0;

      const zeroProb = V20.singularityZero ? V20.singularityZero(baseBlend, risk01, frag01, meta01, flowVal, swingVal) : baseBlend;
      const fused = V20.fuseOutputs(det, detChaos, mc, zeroProb);

      // uncertainty & btts
      const unc = V20.computeUncertainty(fused.final.pH, fused.final.pD, fused.final.pA);
      const btts = V20.computeBTTS ? V20.computeBTTS(godHL) : V20.computeBTTS(finalLambda);

      // engine status
      const riskScore = Math.round(risk01*100);
      const fragScore = Math.round(frag01*100);
      const metaScore = Math.round(meta01*100);
      let engineStatus = "PRIME STABLE";
      if(metaScore < 40 || riskScore > 70 || fragScore > 70) engineStatus = "PRIME CAUTION";
      else if(metaScore < 60) engineStatus = "PRIME NEUTRAL";

      // OU blending
      const ouBlend = computeOUBlend(godHL, ctx, mc);

      // build text report
      let txt = "=== PRIME SINGULARITY ZERO — REPORT (FINAL v3.4) ===\n\n";
      txt += `[ENGINE STATUS] ${engineStatus}\n\n`;
      txt += `[MATCH] ${homeTeam || 'Home'} vs ${awayTeam || 'Away'}\n`;
      txt += `[INPUT] λ base: ${lamH.toFixed(3)} | ${lamA.toFixed(3)}  → λ final: ${V20._safeNum(finalLambda.lamH,lamH).toFixed(3)} | ${V20._safeNum(finalLambda.lamA,lamA).toFixed(3)}\n`;
      txt += `Tempo/Chaos/Imp: ${ctx.tempo.toFixed(1)} / ${ctx.chaos.toFixed(1)} / ${ctx.importance.toFixed(1)}\n`;
      txt += `Home St/Mom: ${home_st.toFixed(1)} / ${home_mom.toFixed(1)}\n`;
      txt += `Away St/Mom: ${away_st.toFixed(1)} / ${away_mom.toFixed(1)}\n\n`;

      txt += "[PROBABILITIES]\n";
      txt += `Home Win : ${(fused.final.pH*100).toFixed(1)}%\n`;
      txt += `Draw     : ${(fused.final.pD*100).toFixed(1)}%\n`;
      txt += `Away Win : ${(fused.final.pA*100).toFixed(1)}%\n\n`;

      txt += `[RISK/FRAG/META] Risk:${riskScore} Frag:${fragScore} Meta:${metaScore}\n`;
      txt += `Uncertainty: ${unc.score.toFixed(1)}%\n`;
      txt += `BTTS: ${(btts*100).toFixed(1)}%\n`;
      txt += `Avg Goals (MC): ${mc.avgGoals.toFixed(3)}\n\n`;

      txt += "[OVER/UNDER blended]\n";
      Object.keys(ouBlend).forEach(k=>{
        txt += `O/U ${k} -> Over ${(ouBlend[k].over*100).toFixed(1)}% | Under ${(ouBlend[k].under*100).toFixed(1)}%\n`;
      });

      txt += `\n[INTEGRATOR]\n - hyperLambda final: ${V20._safeNum(integrMeta?.lamH, finalLambda.lamH).toFixed(3)} | ${V20._safeNum(integrMeta?.lamA, finalLambda.lamA).toFixed(3)}\n`;
      txt += ` - pattern: ${JSON.stringify(mc.pattern || integrMeta?.pattern || {})}\n`;
      txt += `\n[NOTES]\n - Match Type: ${window._V20_MATCH_TEMPLATE?.name || 'none'}\n - Weather: ${weatherKey || 'normal'}\n - Ref strictness: ${refStrict}\n`;

      // write out
      outEl.value = txt;

      // update bars & wheel (IDs differ slightly from earlier versions, use consistent ones)
      const pH = V20._safeNum(fused.final.pH, 0.33);
      const pD = V20._safeNum(fused.final.pD, 0.33);
      const pA = V20._safeNum(fused.final.pA, 0.33);

      // bars in Module 3 used ids: bar_home, bar_draw, bar_away
      setBar('bar_home', pH);
      setBar('bar_draw', pD);
      setBar('bar_away', pA);

      // also call renderWheel (module 9)
      try{ renderWheel({ pH, pD, pA }); }catch(e){ /* ignore */ }

    }catch(err){
      // top-level safety
      try{ console.error('runPrimeZero error', err); alert('Engine error: ' + (err && err.message || err)); }catch(e){}
    }
  }; // end runPrimeZero

  // UI bindings
  document.addEventListener('DOMContentLoaded', function(){
    // btn_auto -> apply autoFill (module 7)
    const btnAuto = el('btn_auto'); if(btnAuto) btnAuto.addEventListener('click', function(){ try{ window.autoFill(); }catch(e){ alert('AUTO error'); } });

    // btn_apply_mt -> apply match type pull to tempo/chaos/importance
    const btnApply = el('btn_apply_mt'); if(btnApply) btnApply.addEventListener('click', function(){
      const sel = el('match_type')?.value || 'normal';
      if(V20.MatchType && V20.MatchType.templates && V20.MatchType.templates[sel]){
        const t = V20.MatchType.templates[sel];
        el('tempo').value = t.tempo;
        el('chaos').value = t.chaos;
        el('importance').value = t.importance;
        window._V20_MATCH_TEMPLATE = Object.assign({name: sel}, t);
        alert('Match Type applied: ' + (V20.MatchType.templates[sel] && sel));
      } else alert('Match Type not found');
    });

    // run button
    const btnRun = el('btn_run'); if(btnRun) btnRun.addEventListener('click', function(){ try{ V20.runPrimeZero(); }catch(e){ alert('Run error'); console.error(e); } });

    // keyboard: Enter on json_config triggers run
    const jsonInput = el('json_config'); if(jsonInput) jsonInput.addEventListener('keydown', function(ev){ if(ev.key === 'Enter' && (ev.ctrlKey || ev.metaKey)){ ev.preventDefault(); V20.runPrimeZero(); } });

    // initial visual reset
    setBar('bar_home', 0.0); setBar('bar_draw', 0.0); setBar('bar_away', 0.0);
    try{ renderWheel({ pH:0.33, pD:0.34, pA:0.33 }); }catch(e){}
  });

})(); // IIFE end

/* ============================================================
   MODULE 10 DONE — END OF SCRIPT
   ============================================================ */
  }catch(e){ console.error(e); }
      });

    }); // end DOMContentLoaded

})(); // end IIFE Module 10
</script>
</body>
</html>


<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PSZ MAX v3.4 CLEAN — Final</title>

<!-- Improved, compact and readable UI styles -->
<style>
  :root{
    --bg-1:#04101a;
    --bg-2:#071a27;
    --card:#081827;
    --muted:#98a6b3;
    --accent-1:#06b6d4;
    --accent-2:#8b5cf6;
    --text:#e6eef6;
    --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:var(--text); -webkit-font-smoothing:antialiased;}
  .wrap{max-width:1220px;margin:18px auto;padding:16px}
  header{display:flex;gap:12px;align-items:center}
  .logo{width:50px;height:50px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#05232f,#04384a); box-shadow:0 6px 20px rgba(2,6,23,0.6)}
  h1{font-size:18px;margin:0}
  .sub{font-size:12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 460px;gap:12px;margin-top:14px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-radius:12px;padding:12px;box-shadow:0 8px 24px rgba(2,6,23,0.55);border:1px solid rgba(255,255,255,0.02)}
  label{display:block;font-size:12px;color:var(--muted);margin-top:8px}
  input,select,textarea,button{font-size:14px;border-radius:10px;padding:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);width:100%;box-sizing:border-box}
  textarea{min-height:84px;resize:vertical}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .col{flex:1;min-width:120px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  button.primary{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));border:none;color:#021022;padding:10px 12px;cursor:pointer;border-radius:10px}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;cursor:pointer;border-radius:10px}
  .small{font-size:12px;color:var(--muted)}
  .badge{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.025);font-size:12px}
  .prob-bar{height:12px;border-radius:8px;background:var(--glass);position:relative;overflow:hidden}
  .prob-fill{height:100%;position:absolute;left:0;top:0;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));width:0%}
  .cols-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px}
  .muted{color:var(--muted)}
  footer{margin-top:14px;font-size:12px;color:var(--muted)}
  @media(max-width:1000px){ .grid{grid-template-columns:1fr} .cols-3{grid-template-columns:1fr} .logo{width:42px;height:42px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo" aria-hidden="true">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 2l3 6 6 .5-4.5 3.8L18 20l-6-3.5L6 20l1.5-7.7L3 8.5 9 8l3-6z" fill="currentColor"/></svg>
    </div>
    <div>
      <h1>Prime Singularity Zero — MAX v3.4 (FINAL)</h1>
      <div class="sub">Clean • Stable • All modules included • UI enhanced</div>
    </div>
  </header>

  <div class="grid" role="main" aria-label="Main interface">
    <!-- LEFT PANEL (inputs) will be here: MODULE 2 -->
<!-- LEFT PANEL : INPUTS -->
    <div class="card" id="left_panel">

      <!-- ========== BASIC TEAM INPUTS ========== -->
      <h3 style="margin:4px 0 8px 0;font-size:15px;">Team Settings</h3>
      <div class="row">
        <div class="col">
          <label>Home Team</label>
          <input id="home_team" placeholder="Contoh: Barcelona"/>
        </div>
        <div class="col">
          <label>Away Team</label>
          <input id="away_team" placeholder="Contoh: Real Madrid"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>λ Home</label>
          <input id="lamH" type="number" step="0.01" value="1.20"/>
        </div>
        <div class="col">
          <label>λ Away</label>
          <input id="lamA" type="number" step="0.01" value="1.00"/>
        </div>
      </div>

      <!-- ========== MATCH CONTEXT ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Match Context</h3>

      <div class="row">
        <div class="col">
          <label>Tempo</label>
          <input id="tempo" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Chaos</label>
          <input id="chaos" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Importance</label>
          <input id="importance" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <!-- ========== STABILITY & MOMENTUM ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Team Profile</h3>

      <div class="row">
        <div class="col">
          <label>Home Stability</label>
          <input id="home_st" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Stability</label>
          <input id="away_st" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Home Momentum</label>
          <input id="home_mom" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Momentum</label>
          <input id="away_mom" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <!-- ========== TACTICAL INPUTS ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Tactical Settings</h3>

      <div class="row">
        <div class="col">
          <label>Home Press</label>
          <input id="home_press" type="number" min="1" max="10" value="5"/>
        </div>
        <div class="col">
          <label>Away Press</label>
          <input id="away_press" type="number" min="1" max="10" value="5"/>
        </div>
      </div>

      <div class="row">
        <div class="col">
          <label>Home Flex</label>
          <input id="home_flex" type="number" step="0.1" min="0" max="1" value="0.5"/>
        </div>
        <div class="col">
          <label>Away Flex</label>
          <input id="away_flex" type="number" step="0.1" min="0" max="1" value="0.5"/>
        </div>
      </div>

      <!-- ========== MATCH TYPE & WEATHER & REFEREE ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Environment</h3>

      <div class="row">
        <div class="col">
          <label>Match Type</label>
          <select id="match_type">
            <option value="normal">Normal Match</option>
            <option value="derby">Derby</option>
            <option value="relegation">Relegation Battle</option>
            <option value="title">Title Decider</option>
            <option value="cup">Cup Knockout</option>
            <option value="ucl">UCL Match</option>
            <option value="ucl_knockout">UCL Knockout</option>
          </select>
        </div>

        <div class="col">
          <label>Weather</label>
          <select id="weather">
            <option value="clear">Clear</option>
            <option value="rain">Rain</option>
            <option value="heavy_rain">Heavy Rain</option>
            <option value="snow">Snow</option>
          </select>
        </div>

        <div class="col">
          <label>Referee Strictness</label>
          <input id="ref_strict" type="number" min="1" max="10" value="5"/>
        </div>
      </div>
 <!-- ========== MONTE CARLO SETTINGS ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Simulation Settings</h3>

      <div class="row">
        <div class="col">
          <label>MC Sim Count</label>
          <input id="simCount" type="number" placeholder="ex: 5000"/>
        </div>
        <div class="col">
          <label>Score Cap</label>
          <input id="scoreCap" type="number" placeholder="ex: 8"/>
        </div>
      </div>

      <!-- ========== JSON CONFIG ========== -->
      <h3 style="margin-top:12px;font-size:15px;">Load JSON Config</h3>
      <textarea id="json_config" placeholder='{"lamH":1.2,"lamA":1.0,...}'></textarea>

      <!-- BUTTONS -->
      <div class="controls">
        <button class="primary" id="btn_auto">AUTO INPUT (FULL)</button>
        <button class="ghost" id="btn_apply_mt">APPLY MATCH TYPE</button>
        <button class="primary" id="btn_run">RUN INTEGRATED</button>
      </div>

    </div>
    <!-- END LEFT PANEL -->
<!-- RIGHT PANEL : OUTPUTS -->
    <div class="card" id="right_panel">

      <h3 style="margin:4px 0 8px 0;font-size:15px;">Prediction Output</h3>

      <!-- OUTPUT TEXT AREA -->
      <label>Engine Report</label>
      <textarea id="output" readonly style="height:200px;"></textarea>

      <!-- PROBABILITY BARS -->
      <h3 style="margin-top:16px;font-size:15px;">Probability Bars</h3>

      <div class="cols-3">
        <div>
          <div class="small muted">Home</div>
          <div class="prob-bar"><div id="bar_home" class="prob-fill"></div></div>
        </div>
        <div>
          <div class="small muted">Draw</div>
          <div class="prob-bar"><div id="bar_draw" class="prob-fill"></div></div>
        </div>
        <div>
          <div class="small muted">Away</div>
          <div class="prob-bar"><div id="bar_away" class="prob-fill"></div></div>
        </div>
      </div>

      <!-- PROBABILITY WHEEL -->
      <h3 style="margin-top:18px;font-size:15px;">Probability Wheel</h3>
      <div id="prob_wheel" style="text-align:center;padding:10px;">
        <!-- Wheel SVG injected by JS (Module 9) -->
        <div class="muted small">No data yet</div>
      </div>

      <!-- EXTRA SPACE FOR NOTES / DNA / FLAGS -->
      <div id="extra_info" style="margin-top:16px;">
        <div class="badge">Engine v3.4 • Stable</div>
      </div>

    </div>
    <!-- END RIGHT PANEL -->
  </div> <!-- end grid -->

  <footer>
    PSZ MAX v3.4 — Clean Final Build • No duplicate modules • Stable Monte Carlo • UI Enhanced
  </footer>

<!-- SCRIPT SECTION STARTS BELOW (MODULES 4–10) -->
<script>
/* ============================================================
   MODULE 4 — CORE UTILITIES (clean, stable, no duplicates)
   ============================================================ */

const V20 = {};

/* ---------- SAFE NUMBER ---------- */
V20._safeNum = function(x, d=0){
  const v = Number(x);
  return isFinite(v) ? v : d;
};

/* ---------- CLAMP ---------- */
V20.clamp = function(v, min, max){
  return v < min ? min : (v > max ? max : v);
};

/* ---------- RANDOM UNIFORM [0,1) ---------- */
V20.rnd = function(){
  return Math.random();
};

/* ---------- POISSON PMF ---------- */
V20.poissonPMF = function(lambda, k){
  lambda = Math.max(lambda, 0.00001);
  if(k < 0) return 0;
  return Math.exp(-lambda) * Math.pow(lambda, k) / V20.factorial(k);
};

/* ---------- FACTORIAL (CACHE) ---------- */
V20._fact_cache = {0:1,1:1};
V20.factorial = function(n){
  n = n|0;
  if(n < 0) return 1;
  if(V20._fact_cache[n]) return V20._fact_cache[n];
  let r = 1;
  for(let i=2;i<=n;i++) r*=i;
  V20._fact_cache[n]=r;
  return r;
};

/* ---------- DETERMINISTIC SIMULATION (matrix-based) ---------- */
V20.detSim = function(lambda){
  const lamH = V20._safeNum(lambda.lamH,1.2);
  const lamA = V20._safeNum(lambda.lamA,1.0);
  let pH=0,pD=0,pA=0;

  for(let h=0;h<=8;h++){
    const pHh = V20.poissonPMF(lamH,h);
    for(let a=0;a<=8;a++){
      const pAa = V20.poissonPMF(lamA,a);
      const p = pHh * pAa;
      if(h>a) pH+=p;
      else if(h==a) pD+=p;
      else pA+=p;
    }
  }
  const s = pH+pD+pA || 1;
  return { pH:pH/s, pD:pD/s, pA:pA/s };
};

/* ---------- BUILD EMPTY MATRIX ---------- */
V20.buildMatrix = function(cap){
  const m = [];
  for(let i=0;i<=cap;i++){
    m[i] = [];
    for(let j=0;j<=cap;j++) m[i][j] = 0;
  }
  return m;
};

/* ---------- ADD TO MATRIX ---------- */
V20.addToMatrix = function(mat, h, a){
  if(mat[h] && typeof mat[h][a] !== "undefined"){
    mat[h][a]++;
  }
};

/* ---------- NORMALIZE MATRIX ---------- */
V20.normalizeMatrix = function(mat, total){
  for(let i=0;i<mat.length;i++){
    for(let j=0;j<mat[i].length;j++){
      mat[i][j] = mat[i][j] / total;
    }
  }
  return mat;
};

/* ---------- BTTS (analytic) ---------- */
V20.computeBTTS = function(lambda){
  const lamH = V20._safeNum(lambda.lamH,1.2);
  const lamA = V20._safeNum(lambda.lamA,1.0);
  const pH0 = V20.poissonPMF(lamH,0);
  const pA0 = V20.poissonPMF(lamA,0);
  return 1 - pH0 - pA0 + (pH0*pA0); // P(H>=1 ∧ A>=1)
};

/* ---------- UNCERTAINTY (entropy-based) ---------- */
V20.computeUncertainty = function(pH,pD,pA){
  const eps = 1e-9;
  const H = -(pH*Math.log(pH+eps) + pD*Math.log(pD+eps) + pA*Math.log(pA+eps));
  const maxH = Math.log(3);
  return { score: (H/maxH)*100 };
};
/* ============================================================
   MODULE 5 — MONTE CARLO + HYPERLAMBDA + FUSE ENGINE
   ============================================================ */

/* ---------- MONTE CARLO SIMULATION ---------- */
V20.monteCarlo = function(lambda, ctx, simCount, scoreCap, home, away, tact){
  const lamH0 = V20._safeNum(lambda.lamH,1.2);
  const lamA0 = V20._safeNum(lambda.lamA,1.0);

  const chaos = V20._safeNum(ctx.chaos,5);
  const tempo = V20._safeNum(ctx.tempo,5);

  simCount = Number(simCount);
  if(!isFinite(simCount) || simCount<=0) simCount = 3000;
  scoreCap = Number(scoreCap);
  if(!isFinite(scoreCap) || scoreCap<=0) scoreCap = 8;

  /* Monte Carlo Result Counters */
  let winH=0, winA=0, draw=0, totalGoals=0;
  const mat = V20.buildMatrix(scoreCap);

  /* Precompute multipliers */
  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;

  const pressH = V20._safeNum(tact?.home?.pressIntensity,5);
  const pressA = V20._safeNum(tact?.away?.pressIntensity,5);
  const flexH  = V20._safeNum(tact?.home?.flex,0.5);
  const flexA  = V20._safeNum(tact?.away?.flex,0.5);

  const stabH  = V20._safeNum(home?.stability,5);
  const stabA  = V20._safeNum(away?.stability,5);

  /* MAIN SIM LOOP */
  for(let i=0;i<simCount;i++){

    /* Lambda adjusted */
    let lamH = lamH0 * (1 + chaosF*0.12 + tempoF*0.05 + (pressA-5)*0.015 - (pressH-5)*0.01);
    let lamA = lamA0 * (1 + chaosF*0.12 + tempoF*0.05 + (pressH-5)*0.015 - (pressA-5)*0.01);

    lamH *= (1 + (flexH-0.5)*0.10 - (stabH-5)*0.01);
    lamA *= (1 + (flexA-0.5)*0.10 - (stabA-5)*0.01);

    lamH = V20.clamp(lamH,0.15,6.5);
    lamA = V20.clamp(lamA,0.15,6.5);

    /* Sample goals using inverse sampling */
    const gH = V20.samplePoisson(lamH);
    const gA = V20.samplePoisson(lamA);

    totalGoals += (gH + gA);

    if(gH > gA) winH++;
    else if(gH < gA) winA++;
    else draw++;

    const h = (gH<=scoreCap)?gH:scoreCap;
    const a = (gA<=scoreCap)?gA:scoreCap;
    V20.addToMatrix(mat, h, a);
  }

  const pH = winH/simCount;
  const pA = winA/simCount;
  const pD = draw/simCount;

  const avgGoals = totalGoals/simCount;

  /* Normalize matrix */
  const matN = V20.normalizeMatrix(mat, simCount);

  /* Return */
  return {
    pH, pD, pA,
    avgGoals,
    matrix: matN,
    scoreCap,
    simCount,
    /* For HyperLambda */
    hyperLambda: { lamH: lamH0, lamA: lamA0 },
    pattern: {
      control: 0.25 + (tempoF*0.10),
      swing: 0.25 + (chaosF*0.15),
      stalled: 0.25 + ((stabH+stabA)/20)*0.1,
      chaotic: 0.25 + (Math.abs(chaosF)*0.2)
    }
  };
};

/* ---------- POISSON SAMPLER (inverse transform) ---------- */
V20.samplePoisson = function(lambda){
  const L = Math.exp(-lambda);
  let k = 0;
  let p = 1;
  do { k++; p *= Math.random(); } while(p > L && k<12);
  return k-1;
};

/* ============================================================
   HYPERLAMBDA — Final stabilizer lambda
   ============================================================ */

V20.hyperLambda = function(lambda, ctx, home, away){
  const lamH0 = V20._safeNum(lambda.lamH,1.2);
  const lamA0 = V20._safeNum(lambda.lamA,1.0);

  const tempo = V20._safeNum(ctx.tempo,5);
  const chaos = V20._safeNum(ctx.chaos,5);

  const tempoF = (tempo - 5)/5;
  const chaosF = (chaos - 5)/5;

  const stH = V20._safeNum(home?.stability,5);
  const stA = V20._safeNum(away?.stability,5);

  const momH = V20._safeNum(home?.momentum,5);
  const momA = V20._safeNum(away?.momentum,5);

  /* Blend base λ with context */
  let lamH = lamH0*(1 + tempoF*0.10 + chaosF*0.08 + (momH-5)*0.02 - (stH-5)*0.01);
  let lamA = lamA0*(1 + tempoF*0.10 + chaosF*0.08 + (momA-5)*0.02 - (stA-5)*0.01);

  lamH = V20.clamp(lamH,0.2,6.5);
  lamA = V20.clamp(lamA,0.2,6.5);

  return { lamH, lamA };
};

/* ============================================================
   FUSE ENGINE — combine deterministic, chaos, MC, zero engine
   ============================================================ */

V20.fuseOutputs = function(det, detChaos, mc, zero){
  const baseH = (det.pH + detChaos.pH + mc.pH)/3;
  const baseD = (det.pD + detChaos.pD + mc.pD)/3;
  const baseA = (det.pA + detChaos.pA + mc.pA)/3;

  const zH = zero.pH, zD = zero.pD, zA = zero.pA;

  const finalH = (baseH*0.55 + zH*0.45);
  const finalD = (baseD*0.55 + zD*0.45);
  const finalA = (baseA*0.55 + zA*0.45);

  let s = finalH + finalD + finalA;
  return {
    final:{
      pH: finalH/s,
      pD: finalD/s,
      pA: finalA/s
    },
    base:{
      pH: baseH, pD: baseD, pA: baseA
    }
  };
};
/* ============================================================
   MODULE 6 — ADVANCED MODELS (Weather, DCM, EMC, GSAL, RII, SQM, Bayes)
   ============================================================ */

V20.Weather = (function(){
  const presets = {
    normal:{chaos:0,tempo:0,finishing:0,error:0},
    rain:{chaos:0.9,tempo:-0.4,finishing:-0.06,error:0.12},
    heavy_rain:{chaos:1.6,tempo:-1.0,finishing:-0.14,error:0.28},
    poor_pitch:{chaos:1.1,tempo:-0.8,finishing:-0.10,error:0.30},
    hot:{chaos:0.2,tempo:-0.4,finishing:-0.02,error:0.06},
    cold:{chaos:0.1,tempo:-0.2,finishing:0,error:0.02},
    snow:{chaos:1.2,tempo:-1.1,finishing:-0.16,error:0.36}
  };
  return {
    presets,
    applyToContext:function(ctx, key){
      const p = presets[key] || presets.normal;
      ctx = ctx || {};
      ctx.chaos = V20._safeNum(ctx.chaos,5) + p.chaos;
      ctx.tempo = V20._safeNum(ctx.tempo,5) + p.tempo;
      ctx.weatherFinishing = p.finishing;
      ctx.weatherError = p.error;
      return ctx;
    }
  };
})();

/* ---------------- DCM (Decompose Chaos & compute multiplier) ---------------- */
V20.DCM = (function(){
  function decompose(ctx, home, away){
    ctx = ctx || {}; home = home || {}; away = away || {};
    const chaos = V20._safeNum(ctx.chaos,5);
    const imp = V20._safeNum(ctx.importance,5);
    const flexAvg = ((home.flex||0.5) + (away.flex||0.5)) / 2;
    const stabilityAvg = ((home.stability||5) + (away.stability||5)) / 2;

    const defensive = 0.18*(chaos/5) + 0.12*(1 - (stabilityAvg/10));
    const structural = 0.12*(chaos/5) + 0.09*(flexAvg);
    const transition = 0.22*(chaos/5) + 0.08*(Math.abs((home.momentum||5)-(away.momentum||5))/5);
    const emotional = 0.28*((imp-5)/10 + ((ctx.isDerby?1:0)*0.9));

    const sum = defensive + structural + transition + emotional || 1;
    return {
      defensive: defensive/sum,
      structural: structural/sum,
      transition: transition/sum,
      emotional: emotional/sum
    };
  }

  function chaosMultiplier(ctx, home, away){
    const parts = decompose(ctx, home, away);
    const mult = 1 + parts.defensive*0.28 + parts.transition*0.20 + parts.emotional*0.30 + parts.structural*0.12;
    return V20.clamp(mult, 0.7, 2.2);
  }

  return { decompose, chaosMultiplier };
})();

/* ---------------- EMC (Estimated Minute Curve) ---------------- */
V20.EMC = (function(){
  function buildCurve(ctx){
    ctx = ctx || {};
    const tempo = V20._safeNum(ctx.tempo,5);
    const chaos = V20._safeNum(ctx.chaos,5);
    const impo = V20._safeNum(ctx.importance,5);
    const curve = new Array(90).fill(1);
    for(let i=0;i<15;i++) curve[i] *= (0.92 + (tempo-5)/30 + (chaos-5)/80);
    for(let i=15;i<35;i++) curve[i] *= (1.02 + (tempo-5)/22 + (chaos-5)/60);
    for(let i=35;i<55;i++) curve[i] *= (1.00 + (tempo-5)/30 + (chaos-5)/90);
    for(let i=55;i<70;i++) curve[i] *= (0.96 + (chaos-5)/45 - (tempo-5)/100);
    for(let i=70;i<90;i++) curve[i] *= (1.08 + (chaos-5)/26 + (impo-5)/40);
    const mean = curve.reduce((a,b)=>a+b,0)/curve.length;
    for(let i=0;i<curve.length;i++) curve[i] = curve[i] / (mean || 1);
    return curve;
  }
  return { buildCurve };
})();

/* ---------------- RII (Referee Impact Index) ---------------- */
V20.RII = (function(){
  function score(profile){
    profile = profile || {};
    const cards = V20._safeNum(profile.cardsPerGame, 2.5);
    const fouls = V20._safeNum(profile.foulsPerGame, 24);
    const pen = V20._safeNum(profile.penaltyFreq, 0.08);
    const homeBias = V20._safeNum(profile.homeBias, 0);
    // scaled 0..1
    const s = ((cards/5)*0.35 + (fouls/40)*0.25 + (pen/0.2)*0.25 + (homeBias)*0.15);
    return V20.clamp(s, 0, 1);
  }
  function applyToCtx(ctx, profile){
    ctx = ctx || {};
    const s = score(profile);
    ctx.chaos = V20._safeNum(ctx.chaos,5) + (s - 0.5) * 0.9;
    ctx.refPenalty = s * 0.18;
    return ctx;
  }
  return { score, applyToCtx };
})();

/* ---------------- SQM (Finishing Quality Model) ---------------- */
V20.SQM = (function(){
  function finishingBias(profile){
    profile = profile || {};
    const xgShot = V20._safeNum(profile.xGperShot, 0.12);
    const postx = V20._safeNum(profile.postxGoffset, 0);
    const form = V20._safeNum(profile.finishingForm, 0);
    const keeper = V20._safeNum(profile.keeperBias, 0);
    let fb = 1 + ((xgShot - 0.12) * 1.8) + postx + form - keeper*0.7;
    return V20.clamp(fb, 0.7, 1.35);
  }
  function applyToLambda(lambda, homeProfile, awayProfile){
    const fh = finishingBias(homeProfile);
    const fa = finishingBias(awayProfile);
    return { lamH: lambda.lamH * fh, lamA: lambda.lamA * fa };
  }
  return { finishingBias, applyToLambda };
})();

/* ---------------- GSAL (Game State Adaptive Lambda) ---------------- */
V20.GSAL = (function(){
  function adaptLambda(baseLam, ctx, state, home, away, tact){
    state = state || {};
    home = home || {}; away = away || {}; tact = tact || {};
    let lamH = V20._safeNum(baseLam.lamH, 1);
    let lamA = V20._safeNum(baseLam.lamA, 1);
    let modH = 1, modA = 1;
    const scoreH = V20._safeNum(state.scoreH,0), scoreA = V20._safeNum(state.scoreA,0);
    if(scoreH > scoreA){ const lead = scoreH - scoreA; modH *= 1 - 0.12*V20.clamp(lead,0,3); modA *= 1 + 0.18*V20.clamp(lead,0,3); }
    else if(scoreA > scoreH){ const lead = scoreA - scoreH; modA *= 1 - 0.12*V20.clamp(lead,0,3); modH *= 1 + 0.18*V20.clamp(lead,0,3); }
    const minute = V20._safeNum(state.minute,0);
    if(minute >= 75){
      if(scoreH < scoreA) modH *= 1.25;
      if(scoreA < scoreH) modA *= 1.25;
      modH *= 1 - 0.06; modA *= 1 - 0.06;
    }
    if(state.redH){ modH *= 1 - 0.18*state.redH; modA *= 1 + 0.12*state.redH; }
    if(state.redA){ modA *= 1 - 0.18*state.redA; modH *= 1 + 0.12*state.redA; }
    const pressDiff = (tact.home?.pressIntensity||5) - (tact.away?.pressIntensity||5);
    if(pressDiff > 0 && minute >= 60){ modH *= 1 + pressDiff*0.02; modA *= 1 - pressDiff*0.01; }
    else if(pressDiff < 0 && minute >= 60){ const pd = Math.abs(pressDiff); modA *= 1 + pd*0.02; modH *= 1 - pd*0.01; }
    const importance = V20._safeNum(ctx.importance,5);
    const chaos = V20._safeNum(ctx.chaos,5);
    const impFactor = 1 - V20.clamp((importance-5)/10, -0.2, 0.2);
    const chaosFactor = 1 + V20.clamp((chaos-5)/10, -0.25, 0.6);
    const outH = V20.clamp(lamH * modH * impFactor * chaosFactor, 0.05, 8.0);
    const outA = V20.clamp(lamA * modA * impFactor * chaosFactor, 0.05, 8.0);
    return { lamH: outH, lamA: outA };
  }
  return { adaptLambda };
})();

/* ---------------- BAYES SIMPLE CALIBRATION ---------------- */
V20.Bayes = (function(){
  function calibrateFromXG(prior, observedGoals, exposureMinutes){
    prior = prior || { alpha:1.5, beta:1.0 };
    observedGoals = V20._safeNum(observedGoals, 0);
    exposureMinutes = V20._safeNum(exposureMinutes, 90);
    const alphaPost = prior.alpha + observedGoals;
    const betaPost = prior.beta + (exposureMinutes/90);
    return { alpha: alphaPost, beta: betaPost, mean: alphaPost / betaPost, variance: alphaPost / (betaPost * betaPost) };
  }
  function calibratePair(priorH, obsH, expH, priorA, obsA, expA){
    const h = calibrateFromXG(priorH, obsH, expH);
    const a = calibrateFromXG(priorA, obsA, expA);
    return { h, a };
  }
  return { calibrateFromXG, calibratePair };
})();

/* ============================================================
   MODULE 6 DONE
   ============================================================ */
/* ============================================================
   MODULE 7 — MATCH TYPE, TEAM DNA, AUTO INPUT ENGINE
   ============================================================ */

/* ---------------- MATCH TYPE PRESETS ---------------- */
V20.MatchType = {
  templates:{
    normal:{ tempo:5, chaos:5, importance:5 },
    derby:{ tempo:6, chaos:7, importance:6, isDerby:true },
    relegation:{ tempo:4, chaos:6, importance:8 },
    title:{ tempo:6, chaos:5, importance:9 },
    cup:{ tempo:5, chaos:6, importance:7 },
    ucl:{ tempo:6, chaos:6, importance:8 },
    ucl_knockout:{ tempo:7, chaos:7, importance:9 }
  },

  apply:function(ctx, typeKey){
    const t = V20.MatchType.templates[typeKey] || V20.MatchType.templates.normal;
    ctx = ctx || {};
    ctx.tempo = t.tempo;
    ctx.chaos = t.chaos;
    ctx.importance = t.importance;
    ctx.isDerby = t.isDerby || false;
    return ctx;
  }
};

/* ---------------- TEAM DNA PRESET (compact example) ---------------- */
V20.TeamDNA = {
  db:{
    "barcelona":{ tempo:7, chaos:4, press:6, momentum:6, stability:7, flex:0.6 },
    "real madrid":{ tempo:6, chaos:5, press:6, momentum:7, stability:6, flex:0.7 },
    "man city":{ tempo:8, chaos:4, press:7, momentum:7, stability:8, flex:0.6 },
    "bayern":{ tempo:7, chaos:5, press:7, momentum:6, stability:7, flex:0.6 }
  },

  get:function(name){
    if(!name) return null;
    const key = name.toLowerCase().trim();
    return V20.TeamDNA.db[key] || null;
  }
};

/* ---------------- AUTO INPUT ENGINE ---------------- */
V20.Auto = {};

V20.Auto.autoTempo = function(teamDNA){
  if(!teamDNA) return 5;
  return V20.clamp(teamDNA.tempo || 5, 1, 10);
};

V20.Auto.autoChaos = function(teamDNA, matchType){
  let c = 5;
  if(teamDNA) c += (teamDNA.chaos - 5)*0.5;
  if(matchType === "derby") c += 1.0;
  if(matchType === "ucl_knockout") c += 1.2;
  return V20.clamp(c, 1, 10);
};

V20.Auto.autoImportance = function(matchType){
  const map = {
    normal:5, derby:6, relegation:8, title:9, cup:7, ucl:8, ucl_knockout:9
  };
  return map[matchType] || 5;
};

V20.Auto.autoStability = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.stability || 5,1,10) : 5;
};

V20.Auto.autoMomentum = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.momentum || 5,1,10) : 5;
};

V20.Auto.autoPress = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.press || 5,1,10) : 5;
};

V20.Auto.autoFlex = function(teamDNA){
  return teamDNA? V20.clamp(teamDNA.flex || 0.5,0,1) : 0.5;
};

/* ---------------- TEAM PROFILE MAPPER ---------------- */
V20.Auto.autoTPM = function(name){
  const dna = V20.TeamDNA.get(name);
  if(!dna) return {};
  return {
    stability:dna.stability || 5,
    momentum:dna.momentum || 5,
    press:dna.press || 5,
    flex:dna.flex || 0.5
  };
};

/* ---------------- APPLY ALL AUTO INPUTS ---------------- */
V20.Auto.applyAll = function(homeName, awayName, matchType){
  const hDNA = V20.TeamDNA.get(homeName);
  const aDNA = V20.TeamDNA.get(awayName);

  const ctx = {};
  ctx.tempo = Math.round((V20.Auto.autoTempo(hDNA)+V20.Auto.autoTempo(aDNA))/2);
  ctx.chaos = Math.round((V20.Auto.autoChaos(hDNA,matchType)+V20.Auto.autoChaos(aDNA,matchType))/2);
  ctx.importance = V20.Auto.autoImportance(matchType);

  const home = V20.Auto.autoTPM(homeName);
  const away = V20.Auto.autoTPM(awayName);

  return { ctx, home, away };
};

/* ---------------- AUTO FILL UI ---------------- */
window.autoFill = function(){
  const home = document.getElementById("home_team")?.value || "";
  const away = document.getElementById("away_team")?.value || "";
  const matchType = document.getElementById("match_type")?.value || "normal";

  const result = V20.Auto.applyAll(home, away, matchType);
  const ctx = result.ctx;
  const hm = result.home;
  const aw = result.away;

  document.getElementById("tempo").value = ctx.tempo;
  document.getElementById("chaos").value = ctx.chaos;
  document.getElementById("importance").value = ctx.importance;

  document.getElementById("home_st").value = hm.stability || 5;
  document.getElementById("home_mom").value = hm.momentum || 5;
  document.getElementById("home_press").value = hm.press || 5;
  document.getElementById("home_flex").value = hm.flex || 0.5;

  document.getElementById("away_st").value = aw.stability || 5;
  document.getElementById("away_mom").value = aw.momentum || 5;
  document.getElementById("away_press").value = aw.press || 5;
  document.getElementById("away_flex").value = aw.flex || 0.5;
};

/* ============================================================
   MODULE 7 DONE
   ============================================================ */
/* ============================================================
   MODULE 8 — CHAOS / META / SINGULARITY MODELS + META METRICS
   (defines chaosModel, computeMeta, singularityZero, computeRisk,
    computeFragility, computeFlow, computeMomentumSwing, computeSDI)
   ============================================================ */

/* ---------------- chaosModel (stable, bounded) ----------------
   - Adjusts base lambda by chaos context (non-destructive)
   - Always returns safe lamH/lamA within bounds
*/
V20.chaosModel = function(baseLambda, ctx){
  baseLambda = baseLambda || {};
  ctx = ctx || {};
  const lamH = V20._safeNum(baseLambda.lamH, 1.2);
  const lamA = V20._safeNum(baseLambda.lamA, 1.0);
  const chaos = V20._safeNum(ctx.chaos, 5);
  // map chaos [-] -> multiplier in reasonable band
  const chaosF = (chaos - 5) / 5; // -1 .. +1
  const factorH = 1 + V20.clamp(chaosF * 0.22 + ((ctx.tempo||5)-5)/50, -0.35, 0.45);
  const factorA = 1 + V20.clamp(chaosF * 0.22 + ((ctx.tempo||5)-5)/50, -0.35, 0.45);
  return {
    lamH: V20.clamp(lamH * factorH, 0.12, 7.0),
    lamA: V20.clamp(lamA * factorA, 0.12, 7.0)
  };
};

/* ---------------- computeRisk ----------------
   - simple combined risk from chaos + press imbalance + ref impact
   - returns 0..1
*/
V20.computeRisk = function(ctx, tact){
  ctx = ctx || {};
  tact = tact || {};
  const chaos = V20._safeNum(ctx.chaos, 5);
  const pressH = V20._safeNum(tact.home?.pressIntensity, 5);
  const pressA = V20._safeNum(tact.away?.pressIntensity, 5);
  // referee impact may be stored in ctx.refPenalty
  const refPenalty = V20._safeNum(ctx.refPenalty, 0);

  const chaosPart = V20.clamp((chaos - 4) / 6, 0, 1);         // higher chaos => higher risk
  const pressPart = V20.clamp(Math.abs(pressH - pressA) / 10, 0, 1); // press mismatch
  const refPart = V20.clamp(refPenalty, 0, 1);

  // weighted sum, normalized
  const raw = 0.5 * chaosPart + 0.35 * pressPart + 0.15 * refPart;
  return V20.clamp(raw, 0, 1);
};

/* ---------------- computeFragility ----------------
   - fragility: how brittle the match is to shocks (low stability => fragile)
   - returns 0..1 (1 = very fragile)
*/
V20.computeFragility = function(ctx, home, away){
  ctx = ctx || {};
  home = home || {};
  away = away || {};
  const stH = V20._safeNum(home.stability, 5);
  const stA = V20._safeNum(away.stability, 5);
  const avgSt = (stH + stA) / 2;
  const chaos = V20._safeNum(ctx.chaos, 5);
  // lower stability and higher chaos => more fragility
  const frag = V20.clamp(((6 - avgSt) / 6) * 0.7 + ((chaos - 5) / 10) * 0.3, 0, 1);
  return frag;
};

/* ---------------- computeFlow ----------------
   - measures match control flow leaning towards home/away
   - returns 0..1 where >0.5 => home advantage in flow
*/
V20.computeFlow = function(ctx, home, away, tact, pattern){
  ctx = ctx || {}; home = home || {}; away = away || {}; tact = tact || {}; pattern = pattern || {};
  const momH = V20._safeNum(home.momentum, 5);
  const momA = V20._safeNum(away.momentum, 5);
  const pressH = V20._safeNum(tact.home?.pressIntensity, 5);
  const pressA = V20._safeNum(tact.away?.pressIntensity, 5);

  // base flow from momentum difference
  let flow = 0.5 + ((momH - momA) / 40);
  // pressing tilt and tactical flex adjust
  flow += ((pressH - pressA) / 200);
  // pattern influence (control increases home flow slightly)
  flow += V20._safeNum(pattern.control, 0) * 0.02;
  return V20.clamp(flow, 0, 1);
};

/* ---------------- computeMomentumSwing ----------------
   - magnitude of momentum swing (0..1)
*/
V20.computeMomentumSwing = function(home, away){
  home = home || {}; away = away || {};
  const momH = V20._safeNum(home.momentum, 5);
  const momA = V20._safeNum(away.momentum, 5);
  return V20.clamp(Math.abs(momH - momA) / 10, 0, 1);
};

/* ---------------- computeSDI ----------------
   - Simple SDI (lambda difference scaled)
   - used in computeMeta to penalize big asymmetry
*/
V20.computeSDI = function(godHL){
  godHL = godHL || {};
  const lamH = V20._safeNum(godHL.lamH, 1);
  const lamA = V20._safeNum(godHL.lamA, 1);
  return V20.clamp(Math.abs(lamH - lamA) / Math.max(1, (lamH + lamA)/2), 0, 2);
};

/* ---------------- computeMeta ----------------
   - measures agreement between deterministic and chaos outputs and SDI
   - returns 0..1 (1 = perfect meta-consistency)
*/
V20.computeMeta = function(det, chaosDet, sdi){
  if(!det || !chaosDet) return 0.5;
  const detGap = (det.pH || 0) - (det.pA || 0);
  const chaosGap = (chaosDet.pH || 0) - (chaosDet.pA || 0);
  const gapDiff = Math.abs(detGap - chaosGap);
  sdi = V20._safeNum(sdi, 0);
  // meta lower if gaps differ and SDI large
  let meta = 1 - (gapDiff * 0.45 + Math.abs(sdi) * 0.20);
  meta = V20.clamp(meta, 0, 1);
  return meta;
};

/* ---------------- singularityZero (final correction) ----------------
   - Takes base probabilities (raw blend) and adjusts using risk, fragility,
     meta-consistency, flow and momentum swing.
   - Returns normalized {pH,pD,pA}
*/
V20.singularityZero = function(raw, risk, frag, meta, flow, swing){
  raw = raw || {};
  // fallback raw probabilities
  let pH = V20._safeNum(raw.pH, 1/3);
  let pD = V20._safeNum(raw.pD, 1/3);
  let pA = V20._safeNum(raw.pA, 1/3);

  // Safeguard: normalize early
  let s = pH + pD + pA;
  if(!isFinite(s) || s <= 0){ pH = pD = pA = 1/3; s = 1; }
  pH /= s; pD /= s; pA /= s;

  // normalize weights
  risk = V20._safeNum(risk, 0.5);
  frag = V20._safeNum(frag, 0.5);
  meta = V20._safeNum(meta, 0.5);
  flow = V20._safeNum(flow, 0.5);
  swing = V20._safeNum(swing, 0);

  // flow drives tilt between H and A (flow>0.5 favors home)
  const flowTilt = V20.clamp((flow - 0.5) * 0.18 + (swing * 0.06), -0.25, 0.25);

  // fragility pulls away from extremes towards draw when fragile
  const fragPull = V20.clamp((frag - 0.5) * 0.36, -0.25, 0.4);

  // meta reduces overconfidence in side probabilities (push to draw if meta low)
  const metaDrawBoost = V20.clamp((0.5 - meta) * 0.65, -0.2, 0.7);

  // risk spreads probs towards center (higher risk -> more uncertainty)
  const riskSpread = V20.clamp((risk - 0.5) * 0.28, -0.15, 0.3);

  // apply flow tilt
  const gap = pH - pA;
  pH = pH + gap * flowTilt;
  pA = pA - gap * flowTilt;

  // apply frag pull: reduce both sides by fragPull, move into draw
  pH = pH * (1 - fragPull) ;
  pA = pA * (1 - fragPull) ;
  pD = pD + ( (fragPull) * 0.9 ); // mostly to draw

  // apply meta draw boost
  pD = pD + metaDrawBoost * (1 - pD);

  // apply risk spread (blend with uniform)
  pH = pH * (1 - riskSpread) + (1/3) * riskSpread;
  pD = pD * (1 - riskSpread) + (1/3) * riskSpread;
  pA = pA * (1 - riskSpread) + (1/3) * riskSpread;

  // final normalization & safety clamps
  s = pH + pD + pA;
  if(!isFinite(s) || s <= 0){ pH = pD = pA = 1/3; s = 1; }
  pH /= s; pD /= s; pA /= s;

  return { pH: V20.clamp(pH, 0.0001, 0.9999), pD: V20.clamp(pD, 0.0001, 0.9999), pA: V20.clamp(pA, 0.0001, 0.9999) };
};

/* ============================================================
   MODULE 8 DONE
   ============================================================ */
/* ============================================================
   MODULE 9 — PROBABILITY WHEEL RENDERER (SVG)
   ============================================================ */

/* Draw a circular wheel split into H-D-A sections */
function renderWheel(probs){
  const wheel = document.getElementById("prob_wheel");
  if(!wheel) return;

  let pH = V20._safeNum(probs.pH, 1/3);
  let pD = V20._safeNum(probs.pD, 1/3);
  let pA = V20._safeNum(probs.pA, 1/3);

  let s = pH + pD + pA;
  if(!isFinite(s) || s<=0) s = 1;
  pH /= s; pD /= s; pA /= s;

  /* End angles in degrees */
  const angH = pH * 360;
  const angD = angH + pD * 360;
  const angA = 360;

  /* Arc builder */
  function arcPath(startAng, endAng, r){
    const rad = Math.PI/180;
    const x1 = r * Math.cos(startAng*rad);
    const y1 = r * Math.sin(startAng*rad);
    const x2 = r * Math.cos(endAng*rad);
    const y2 = r * Math.sin(endAng*rad);
    const large = (endAng - startAng) > 180 ? 1 : 0;
    return `M0 0 L${x1} ${y1} A${r} ${r} 0 ${large} 1 ${x2} ${y2} Z`;
  }

  /* Build SVG */
  const r = 90;
  const svg = `
    <svg width="220" height="220" viewBox="-110 -110 220 220">
      <!-- background -->
      <circle cx="0" cy="0" r="${r}" fill="rgba(255,255,255,0.03)" />

      <!-- Home -->
      <path d="${arcPath(0, angH, r)}" fill="#06b6d4" opacity="0.88"></path>
      <!-- Draw -->
      <path d="${arcPath(angH, angD, r)}" fill="#4ade80" opacity="0.85"></path>
      <!-- Away -->
      <path d="${arcPath(angD, angA, r)}" fill="#8b5cf6" opacity="0.85"></path>

      <!-- Center dot -->
      <circle cx="0" cy="0" r="6" fill="rgba(255,255,255,0.7)"></circle>

      <!-- Labels -->
      <text x="0" y="-105" fill="#06b6d4" font-size="12" text-anchor="middle">Home ${(pH*100).toFixed(1)}%</text>
      <text x="0" y="117" fill="#8b5cf6" font-size="12" text-anchor="middle">Away ${(pA*100).toFixed(1)}%</text>
      <text x="-105" y="4" fill="#4ade80" font-size="12" text-anchor="start">Draw ${(pD*100).toFixed(1)}%</text>
    </svg>
  `;

  wheel.innerHTML = svg;
}
/* ============================================================
   MODULE 10 — RUN ENGINE (final) & UI bindings
   ============================================================ */

(function(){

  // safe DOM helpers
  function el(id){ return document.getElementById(id); }
  function setBar(id, frac){
    try{ const e = el(id); if(!e) return; const w = Math.max(0, Math.min(100, Math.round((frac||0)*100))); e.style.width = w + '%'; }catch(e){}
  }

  // OU analytic helper (simple)
  function computeOUBlend(godHL, ctx, mc){
    const totalLam = V20._safeNum(godHL.lamH,1) + V20._safeNum(godHL.lamA,1);
    let lamEff = totalLam * (1 + ((V20._safeNum(ctx.chaos,5)-5)/5)*0.10 + ((V20._safeNum(ctx.tempo,5)-5)/5)*0.05);
    lamEff = V20.clamp(lamEff, 0.5, 6.5);
    const lines = [0.5,1.5,2.5,3.5];
    const ou={};
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under = 0;
      for(let k=0;k<=cut;k++) under += V20.poissonPMF(lamEff,k);
      ou[line] = { under: under, over: 1-under };
    });
    // MC version
    const ouMC = {};
    const mat = mc.matrix || [];
    const cap = mc.scoreCap || (mat.length-1);
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under=0, over=0;
      for(let h=0; h<=cap; h++){
        for(let a=0; a<=cap; a++){
          const freq = (mat[h] && mat[h][a])? mat[h][a] : 0;
          if(h+a <= cut) under += freq; else over += freq;
        }
      }
      ouMC[line] = { under: under, over: over };
    });
    // blend weights
    const godPat = mc.pattern || { chaotic:0, swing:0 };
    const patternChaos = (godPat.chaotic||0) + (godPat.swing||0)*0.6;
    const wMC = 0.40 + 0.40 * Math.max(0, patternChaos);
    const wAN = 1 - wMC;
    const out = {};
    lines.forEach(k=>{
      out[k] = { over: ou[k].over*wAN + (ouMC[k].over||0)*wMC, under: ou[k].under*wAN + (ouMC[k].under||0)*wMC };
    });
    return out;
  }

  // main runner
  V20.runPrimeZero = function(){
    const outEl = el('output');
    if(!outEl) return;

    try{
      // --- read inputs ---
      const homeTeam = (el('home_team')?.value||'').trim();
      const awayTeam = (el('away_team')?.value||'').trim();

      const lamH = V20._safeNum(el('lamH')?.value, 1.20);
      const lamA = V20._safeNum(el('lamA')?.value, 1.00);

      let tempo = V20._safeNum(el('tempo')?.value, 5);
      let chaos = V20._safeNum(el('chaos')?.value, 5);
      let importance = V20._safeNum(el('importance')?.value, 5);

      const home_st = V20._safeNum(el('home_st')?.value, 5);
      const away_st = V20._safeNum(el('away_st')?.value, 5);
      const home_mom = V20._safeNum(el('home_mom')?.value, 5);
      const away_mom = V20._safeNum(el('away_mom')?.value, 5);

      const home_press = V20._safeNum(el('home_press')?.value, 5);
      const away_press = V20._safeNum(el('away_press')?.value, 5);
      const home_flex = V20._safeNum(el('home_flex')?.value, 0.5);
      const away_flex = V20._safeNum(el('away_flex')?.value, 0.5);

      let simCount = V20._safeNum(el('simCount')?.value, NaN);
      let scoreCap = V20._safeNum(el('scoreCap')?.value, NaN);
      if(!isFinite(simCount)) simCount = undefined;
      if(!isFinite(scoreCap)) scoreCap = undefined;

      // parse optional JSON config
      let jsonCfg = null;
      try{ const txt = el('json_config')?.value || ''; if(txt && txt.trim().length) jsonCfg = JSON.parse(txt); }catch(e){ jsonCfg = null; }

      // read weather and referee (simple)
      const weatherKey = (el('weather')?.value || '').toString();
      const refStrict = V20._safeNum(el('ref_strict')?.value, 5);
      const refProfile = { cardsPerGame: 2.5 + (refStrict-5)*0.6, foulsPerGame: 20 + (refStrict-5)*3, penaltyFreq: 0.06 + (refStrict-5)*0.008, homeBias: 0 };

      // build base structures
      const baseLambda = { lamH, lamA };
      let ctx = { tempo, chaos, importance, isDerby:false };
      const home = { stability: home_st, momentum: home_mom, flex: home_flex };
      const away = { stability: away_st, momentum: away_mom, flex: away_flex };
      const tact = { home: { pressIntensity: home_press, flex: home_flex }, away: { pressIntensity: away_press, flex: away_flex } };

      // apply match type if user selected (also keep template)
      const mtSel = (el('match_type')?.value || 'normal');
      if(V20.MatchType && V20.MatchType.templates && V20.MatchType.templates[mtSel]){
        const mt = V20.MatchType.templates[mtSel];
        ctx.tempo = V20._safeNum(mt.tempo, ctx.tempo);
        ctx.chaos = V20._safeNum(mt.chaos, ctx.chaos);
        ctx.importance = V20._safeNum(mt.importance, ctx.importance);
        ctx.isDerby = !!mt.isDerby;
        window._V20_MATCH_TEMPLATE = Object.assign({name: mtSel}, mt);
      } else {
        window._V20_MATCH_TEMPLATE = null;
      }

      // apply weather & referee
      if(V20.Weather) ctx = V20.Weather.applyToContext(ctx, weatherKey || 'normal');
      if(V20.RII) ctx = V20.RII.applyToCtx(ctx, refProfile);

      // if json config available, apply overrides (safe)
      if(jsonCfg){
        if(jsonCfg.lamH) baseLambda.lamH = V20._safeNum(jsonCfg.lamH, baseLambda.lamH);
        if(jsonCfg.lamA) baseLambda.lamA = V20._safeNum(jsonCfg.lamA, baseLambda.lamA);
        if(jsonCfg.tempo) ctx.tempo = V20._safeNum(jsonCfg.tempo, ctx.tempo);
        if(jsonCfg.chaos) ctx.chaos = V20._safeNum(jsonCfg.chaos, ctx.chaos);
      }

      // integrate TPM if available
      try{
        const hTPM = V20.TeamDNA.get(homeTeam) || {};
        const aTPM = V20.TeamDNA.get(awayTeam) || {};
        // override some fields if available
        if(hTPM.stability) home.stability = hTPM.stability;
        if(hTPM.momentum) home.momentum = hTPM.momentum;
        if(hTPM.press) tact.home.pressIntensity = hTPM.press;
        if(hTPM.flex) tact.home.flex = hTPM.flex;
        if(aTPM.stability) away.stability = aTPM.stability;
        if(aTPM.momentum) away.momentum = aTPM.momentum;
        if(aTPM.press) tact.away.pressIntensity = aTPM.press;
        if(aTPM.flex) tact.away.flex = aTPM.flex;
      }catch(e){ /* ignore */ }

      // Compute integrator final lambda (use Integrator if present)
      let integrMeta = null;
      let finalLambda = Object.assign({}, baseLambda);
      try{
        if(V20.Integrator && typeof V20.Integrator.computeFinalLambdas === 'function'){
          integrMeta = V20.Integrator.computeFinalLambdas(baseLambda, ctx, null, {}, {}, tact, { weather: weatherKey, referee: refProfile, homeTeamName: homeTeam, awayTeamName: awayTeam });
          finalLambda = { lamH: integrMeta.lamH || baseLambda.lamH, lamA: integrMeta.lamA || baseLambda.lamA };
        } else {
          // fallback: use hyperLambda
          finalLambda = V20.hyperLambda ? V20.hyperLambda(baseLambda, ctx, home, away, tact) : finalLambda;
        }
      }catch(e){
        finalLambda = baseLambda;
      }

      // deterministic baseline
      const det = V20.detSim(baseLambda);
      const chaosL = V20.chaosModel ? V20.chaosModel(baseLambda, ctx) : baseLambda;
      const detChaos = V20.detSim(chaosL);

      // monte carlo
      const mc = V20.monteCarlo(finalLambda, ctx, simCount, scoreCap, home, away, tact);

      // god objects
      const godHL = mc.hyperLambda && mc.hyperLambda.lamH ? mc.hyperLambda : (integrMeta && integrMeta.hyperLambda ? integrMeta.hyperLambda : finalLambda);
      const godPat = mc.pattern || (integrMeta && integrMeta.pattern) || { control:0.25, swing:0.25, stalled:0.25, chaotic:0.25 };

      // base blend
      const baseBlend = { pH: (det.pH + detChaos.pH + mc.pH)/3, pD: (det.pD + detChaos.pD + mc.pD)/3, pA: (det.pA + detChaos.pA + mc.pA)/3 };

      // meta calculations
      const risk01 = V20.computeRisk ? V20.computeRisk(ctx, tact) : 0.5;
      const frag01 = V20.computeFragility ? V20.computeFragility(ctx, home, away) : 0.5;
      const sdi = V20.computeSDI ? V20.computeSDI(godHL) : 0;
      const meta01 = V20.computeMeta ? V20.computeMeta(det, detChaos, sdi) : 0.5;
      const flowVal = V20.computeFlow ? V20.computeFlow(ctx, home, away, tact, godPat) : 0.5;
      const swingVal = V20.computeMomentumSwing ? V20.computeMomentumSwing(home, away) : 0;

      const zeroProb = V20.singularityZero ? V20.singularityZero(baseBlend, risk01, frag01, meta01, flowVal, swingVal) : baseBlend;
      const fused = V20.fuseOutputs(det, detChaos, mc, zeroProb);

      // uncertainty & btts
      const unc = V20.computeUncertainty(fused.final.pH, fused.final.pD, fused.final.pA);
      const btts = V20.computeBTTS ? V20.computeBTTS(godHL) : V20.computeBTTS(finalLambda);

      // engine status
      const riskScore = Math.round(risk01*100);
      const fragScore = Math.round(frag01*100);
      const metaScore = Math.round(meta01*100);
      let engineStatus = "PRIME STABLE";
      if(metaScore < 40 || riskScore > 70 || fragScore > 70) engineStatus = "PRIME CAUTION";
      else if(metaScore < 60) engineStatus = "PRIME NEUTRAL";

      // OU blending
      const ouBlend = computeOUBlend(godHL, ctx, mc);

      // build text report
      let txt = "=== PRIME SINGULARITY ZERO — REPORT (FINAL v3.4) ===\n\n";
      txt += `[ENGINE STATUS] ${engineStatus}\n\n`;
      txt += `[MATCH] ${homeTeam || 'Home'} vs ${awayTeam || 'Away'}\n`;
      txt += `[INPUT] λ base: ${lamH.toFixed(3)} | ${lamA.toFixed(3)}  → λ final: ${V20._safeNum(finalLambda.lamH,lamH).toFixed(3)} | ${V20._safeNum(finalLambda.lamA,lamA).toFixed(3)}\n`;
      txt += `Tempo/Chaos/Imp: ${ctx.tempo.toFixed(1)} / ${ctx.chaos.toFixed(1)} / ${ctx.importance.toFixed(1)}\n`;
      txt += `Home St/Mom: ${home_st.toFixed(1)} / ${home_mom.toFixed(1)}\n`;
      txt += `Away St/Mom: ${away_st.toFixed(1)} / ${away_mom.toFixed(1)}\n\n`;

      txt += "[PROBABILITIES]\n";
      txt += `Home Win : ${(fused.final.pH*100).toFixed(1)}%\n`;
      txt += `Draw     : ${(fused.final.pD*100).toFixed(1)}%\n`;
      txt += `Away Win : ${(fused.final.pA*100).toFixed(1)}%\n\n`;

      txt += `[RISK/FRAG/META] Risk:${riskScore} Frag:${fragScore} Meta:${metaScore}\n`;
      txt += `Uncertainty: ${unc.score.toFixed(1)}%\n`;
      txt += `BTTS: ${(btts*100).toFixed(1)}%\n`;
      txt += `Avg Goals (MC): ${mc.avgGoals.toFixed(3)}\n\n`;

      txt += "[OVER/UNDER blended]\n";
      Object.keys(ouBlend).forEach(k=>{
        txt += `O/U ${k} -> Over ${(ouBlend[k].over*100).toFixed(1)}% | Under ${(ouBlend[k].under*100).toFixed(1)}%\n`;
      });

      txt += `\n[INTEGRATOR]\n - hyperLambda final: ${V20._safeNum(integrMeta?.lamH, finalLambda.lamH).toFixed(3)} | ${V20._safeNum(integrMeta?.lamA, finalLambda.lamA).toFixed(3)}\n`;
      txt += ` - pattern: ${JSON.stringify(mc.pattern || integrMeta?.pattern || {})}\n`;
      txt += `\n[NOTES]\n - Match Type: ${window._V20_MATCH_TEMPLATE?.name || 'none'}\n - Weather: ${weatherKey || 'normal'}\n - Ref strictness: ${refStrict}\n`;

      // write out
      outEl.value = txt;

      // update bars & wheel (IDs differ slightly from earlier versions, use consistent ones)
      const pH = V20._safeNum(fused.final.pH, 0.33);
      const pD = V20._safeNum(fused.final.pD, 0.33);
      const pA = V20._safeNum(fused.final.pA, 0.33);

      // bars in Module 3 used ids: bar_home, bar_draw, bar_away
      setBar('bar_home', pH);
      setBar('bar_draw', pD);
      setBar('bar_away', pA);

      // also call renderWheel (module 9)
      try{ renderWheel({ pH, pD, pA }); }catch(e){ /* ignore */ }

    }catch(err){
      // top-level safety
      try{ console.error('runPrimeZero error', err); alert('Engine error: ' + (err && err.message || err)); }catch(e){}
    }
  }; // end runPrimeZero

  // UI bindings
  document.addEventListener('DOMContentLoaded', function(){
    // btn_auto -> apply autoFill (module 7)
    const btnAuto = el('btn_auto'); if(btnAuto) btnAuto.addEventListener('click', function(){ try{ window.autoFill(); }catch(e){ alert('AUTO error'); } });

    // btn_apply_mt -> apply match type pull to tempo/chaos/importance
    const btnApply = el('btn_apply_mt'); if(btnApply) btnApply.addEventListener('click', function(){
      const sel = el('match_type')?.value || 'normal';
      if(V20.MatchType && V20.MatchType.templates && V20.MatchType.templates[sel]){
        const t = V20.MatchType.templates[sel];
        el('tempo').value = t.tempo;
        el('chaos').value = t.chaos;
        el('importance').value = t.importance;
        window._V20_MATCH_TEMPLATE = Object.assign({name: sel}, t);
        alert('Match Type applied: ' + (V20.MatchType.templates[sel] && sel));
      } else alert('Match Type not found');
    });

    // run button
    const btnRun = el('btn_run'); if(btnRun) btnRun.addEventListener('click', function(){ try{ V20.runPrimeZero(); }catch(e){ alert('Run error'); console.error(e); } });

    // keyboard: Enter on json_config triggers run
    const jsonInput = el('json_config'); if(jsonInput) jsonInput.addEventListener('keydown', function(ev){ if(ev.key === 'Enter' && (ev.ctrlKey || ev.metaKey)){ ev.preventDefault(); V20.runPrimeZero(); } });

    // initial visual reset
    setBar('bar_home', 0.0); setBar('bar_draw', 0.0); setBar('bar_away', 0.0);
    try{ renderWheel({ pH:0.33, pD:0.34, pA:0.33 }); }catch(e){}
  });

})(); // IIFE end

/* ============================================================
   MODULE 10 DONE — END OF SCRIPT
   ============================================================ */
</body>
</html>

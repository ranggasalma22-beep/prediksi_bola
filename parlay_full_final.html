<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PSZ Master — Full Final (Hybrid Pro)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:12px;background:#f5f7fb;color:#111}
    .wrap{max-width:1100px;margin:0 auto;background:#fff;padding:16px;border-radius:8px;box-shadow:0 6px 18px rgba(20,30,50,.08)}
    h1{margin:4px 0 12px;font-size:20px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    .card{background:#fafbfd;padding:10px;border-radius:8px;border:1px solid #edf1f7}
    label{display:block;font-size:12px;color:#445;padding-top:8px}
    input[type="text"], input[type="number"], select, textarea{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;border:1px solid #d7e0ef;background:#fff}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .btn{padding:8px 10px;border-radius:6px;border:0;background:#0b6efd;color:#fff;cursor:pointer}
    .btn.secondary{background:#6c757d}
    textarea#output{height:520px;font-family:monospace;white-space:pre-wrap;overflow:auto}
    .small{font-size:12px;color:#667}
    .muted{color:#7b8aa3}
    .section-title{font-weight:700;margin-top:10px}
    .controls{display:flex;gap:8px;margin-top:8px}
    .checkbox-row{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PSZ MASTER — Full Final (Hybrid PRO Auto)</h1>
    <div class="grid">
      <!-- Left: Inputs -->
      <div>
        <div class="card">
          <div class="section-title">Match Info</div>
          <label>Home Team</label><input id="home_team" type="text" value="Home FC">
          <label>Away Team</label><input id="away_team" type="text" value="Away United">
          <label>League</label><input id="league" type="text" value="epl">
          <label>Match Type</label>
          <select id="match_type">
            <option value="normal">Normal</option>
            <option value="derby">Derby</option>
            <option value="cup">Cup</option>
            <option value="ucl">UCL</option>
            <option value="friendly">Friendly</option>
          </select>

          <div class="section-title">Core Inputs</div>
          <label>λ Home (lamH)</label><input id="lamH" type="number" step="0.01" value="1.20">
          <label>λ Away (lamA)</label><input id="lamA" type="number" step="0.01" value="1.00">
          <label>Tempo (1-10)</label><input id="tempo" type="number" step="0.1" value="5">
          <label>Chaos (1-10)</label><input id="chaos" type="number" step="0.1" value="5">
          <label>Importance (1-10)</label><input id="importance" type="number" step="0.1" value="5">

          <div class="section-title">Team State</div>
          <label>Home Stability (1-10)</label><input id="home_st" type="number" step="0.1" value="5">
          <label>Away Stability (1-10)</label><input id="away_st" type="number" step="0.1" value="5">
          <label>Home Momentum (1-10)</label><input id="home_mom" type="number" step="0.1" value="5">
          <label>Away Momentum (1-10)</label><input id="away_mom" type="number" step="0.1" value="5">

          <div class="section-title">Tactical</div>
          <label>Home Press (1-10)</label><input id="home_press" type="number" step="0.1" value="5">
          <label>Away Press (1-10)</label><input id="away_press" type="number" step="0.1" value="5">
          <label>Home Flex</label><input id="home_flex" type="number" step="0.1" value="0.5">
          <label>Away Flex</label><input id="away_flex" type="number" step="0.1" value="0.5">

          <div class="section-title">Advanced (Auto fillable)</div>
          <label>Finishing Quality Home (1-10)</label><input id="finishing_quality_home" type="number" step="0.1" value="5">
          <label>Finishing Quality Away (1-10)</label><input id="finishing_quality_away" type="number" step="0.1" value="5">
          <label>Injury Impact Home (-3..10)</label><input id="injury_home" type="number" step="0.1" value="0">
          <label>Injury Impact Away (-3..10)</label><input id="injury_away" type="number" step="0.1" value="0">
          <label>Manager Aggression Home (1-10)</label><input id="manager_agg_home" type="number" step="0.1" value="5">
          <label>Manager Aggression Away (1-10)</label><input id="manager_agg_away" type="number" step="0.1" value="5">
          <label>Defensive Line Home (1-10)</label><input id="defline_home" type="number" step="0.1" value="5">
          <label>Defensive Line Away (1-10)</label><input id="defline_away" type="number" step="0.1" value="5">

          <label>PPDA Home (auto/manual)</label><input id="ppda_home" type="number" step="0.1" value="12">
          <label>PPDA Away (auto/manual)</label><input id="ppda_away" type="number" step="0.1" value="12">

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="btn_auto" class="btn">AUTO INPUT (FULL)</button>
            <button id="btn_run" class="btn">RUN INTEGRATED</button>
            <button id="btn_reset" class="btn secondary">RESET</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="section-title">Auto / Quick Stats (optional)</div>
          <label>xG Home (if known)</label><input id="xg_home" type="number" step="0.01" value="1.20">
          <label>xG Away (if known)</label><input id="xg_away" type="number" step="0.01" value="1.00">
          <label>Shots Home (optional)</label><input id="shots_home" type="number" step="1" value="10">
          <label>Shots Away (optional)</label><input id="shots_away" type="number" step="1" value="8">
          <label>ShotQuality Home (xG/shot)</label><input id="shotq_home" type="number" step="0.01" value="0.12">
          <label>ShotQuality Away (xG/shot)</label><input id="shotq_away" type="number" step="0.01" value="0.10">
          <label>Possession Home (%)</label><input id="pos_home" type="number" step="0.1" value="52">
          <label>Possession Away (%)</label><input id="pos_away" type="number" step="0.1" value="48">
          <div class="small muted">Form/last5 fields for better auto: (optional) provide formPts_home, formPts_away, conceded_last5_home/away, squadDepth, injuries count.</div>
          <label style="margin-top:6px">FormPts Home (last5 total points, 0-15)</label><input id="form_home" type="number" step="0.1" value="6">
          <label>FormPts Away (last5)</label><input id="form_away" type="number" step="0.1" value="5">
          <label>Conceded last5 Home</label><input id="conceded_home" type="number" step="1" value="4">
          <label>Conceded last5 Away</label><input id="conceded_away" type="number" step="1" value="6">
          <label>SquadDepth Home (0-10)</label><input id="squad_home" type="number" step="0.1" value="5">
          <label>SquadDepth Away (0-10)</label><input id="squad_away" type="number" step="0.1" value="5">
        </div>
      </div>

      <!-- Right: Output & compact controls -->
      <div>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>OUTPUT — SUPER REPORT</strong></div>
            <div class="small muted">Copy result from textarea</div>
          </div>
          <textarea id="output" readonly>Ready. Press AUTO INPUT (FULL) then RUN INTEGRATED.</textarea>
          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="btn_copy" class="btn secondary">COPY OUTPUT</button>
            <button id="btn_save" class="btn secondary">DOWNLOAD TXT</button>
            <div class="small muted" id="status"></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="section-title">Toggles (modules)</div>
          <div class="checkbox-row">
            <label><input type="checkbox" id="flag_dla" checked> DLA</label>
            <label><input type="checkbox" id="flag_gsm" checked> GSM</label>
            <label><input type="checkbox" id="flag_tem" checked> TEM</label>
            <label><input type="checkbox" id="flag_xt" checked> xT</label>
            <label><input type="checkbox" id="flag_fma2" checked> FMA2</label>
            <label><input type="checkbox" id="flag_chrono" checked> ChronoSim</label>
            <label><input type="checkbox" id="flag_selfcal" checked> SelfCal</label>
            <label><input type="checkbox" id="flag_rc" checked> RC</label>
            <label><input type="checkbox" id="flag_reco" checked> Recommender</label>
          </div>
          <div class="small muted" style="margin-top:6px">Toggle modules for testing. Disabling a module will fallback to safe behavior.</div>
        </div>
      </div>
    </div>

    <div style="margin-top:12px" class="small muted">
      Version: PSZ Master — Full Final (Hybrid PRO). If you want persistence, I can add localStorage for history/self-cal.
    </div>
  </div>

  <!-- SCRIPT: Core helpers + Master Upgrade + AutoHybrid + Recommender + Engines + UI -->
  <script>
  // --- Basic V20 namespace & helpers
  window.V20 = window.V20 || {};
  (function(ns){
    ns.num = function(v, d){ const n = Number(v); return isFinite(n) ? n : d; };
    ns.clamp = function(v,a,b){ return Math.max(a, Math.min(b, v)); };
    ns.poissonPMF = function(lambda,k){ if(k<0) return 0; const fact = (n=>{ let r=1; for(let i=2;i<=n;i++) r*=i; return r; })(k); return Math.exp(-lambda)*Math.pow(lambda,k)/fact; };
    ns.randInt = function(a,b){ return Math.floor(a + Math.random()*(b-a+1)); };
  })(V20);

  /* ============================
     MASTER UPGRADE PACK (Level Dewa)
     ============================ */
  (function(){
    V20.Master = V20.Master || {};

    // safe helpers
    V20.Master._safeNum = function(v,d=0){const n=Number(v); return isFinite(n)?n:d;};
    V20.Master._clamp = function(v,a,b){return Math.max(a,Math.min(b, v));};
    V20.Master._now = ()=>Date.now();

    // ANS clamp
    V20.Master.ANS = {
      clampInputs: function(inputs){
        if(!inputs) return;
        inputs.ppda_home = V20.Master._clamp(V20.Master._safeNum(inputs.ppda_home,12),3.2,18);
        inputs.ppda_away = V20.Master._clamp(V20.Master._safeNum(inputs.ppda_away,12),3.2,18);
        inputs.fin_home = V20.Master._clamp(V20.Master._safeNum(inputs.fin_home,5),1,10);
        inputs.fin_away = V20.Master._clamp(V20.Master._safeNum(inputs.fin_away,5),1,10);
        inputs.mom_home = V20.Master._clamp(V20.Master._safeNum(inputs.mom_home,5),1,10);
        inputs.mom_away = V20.Master._clamp(V20.Master._safeNum(inputs.mom_away,5),1,10);
        inputs.stab_home = V20.Master._clamp(V20.Master._safeNum(inputs.stab_home,5),1,10);
        inputs.stab_away = V20.Master._clamp(V20.Master._safeNum(inputs.stab_away,5),1,10);
      }
    };

    // Auto fillers (basic)
    V20.Master.Auto = {
      autoFinishingFrom_xG: function(xg, goals, defaultVal=5){
        xg = V20.Master._safeNum(xg, NaN); goals = V20.Master._safeNum(goals, NaN);
        if(!isFinite(xg) || xg<=0) return defaultVal;
        let ratio = goals / xg;
        let val = 5 + (ratio-1)*2;
        return V20.Master._clamp(val,1,10);
      },
      autoPPDAFromPressDefline: function(press, defline, momentum){
        press = V20.Master._safeNum(press,5); defline = V20.Master._safeNum(defline,5);
        momentum = V20.Master._safeNum(momentum,5);
        let pp = 14 - (press-5)*1.2 - (defline-5)*0.6 - (momentum-5)*0.12;
        return V20.Master._clamp(pp,3.2,18);
      },
      autoxGbasic: function(shots, shotQuality, tempoFactor, ppdaEffect){
        shots = V20.Master._safeNum(shots,6); shotQuality = V20.Master._safeNum(shotQuality,0.12);
        tempoFactor = V20.Master._safeNum(tempoFactor,1); ppdaEffect = V20.Master._safeNum(ppdaEffect,1);
        let xg = shots * shotQuality * tempoFactor * ppdaEffect;
        return Math.max(0.05, xg);
      }
    };

    // Synthetic DNA
    V20.Master.SyntheticDNA = {
      buildFromProfile: function(profile){
        profile = profile || {};
        const press = V20.Master._safeNum(profile.press,5);
        const momentum = V20.Master._safeNum(profile.momentum,5);
        const stability = V20.Master._safeNum(profile.stability,5);
        const xg = V20.Master._safeNum(profile.xg,1.1);
        const xga = V20.Master._safeNum(profile.xga,1.1);
        const styleScore = (press>6?1:0) + (xg>1.2?0.8:0) + ((momentum-5)/5);
        const style = styleScore > 1.2 ? 'gegenpress' : (styleScore < -0.5 ? 'low_block' : 'possession');
        return {
          style,
          tempoBias: V20.Master._clamp(1 + (press-5)*0.06 + (momentum-5)*0.03, 0.7, 1.5),
          finishingBias: V20.Master._clamp((xg>0? (xg / Math.max(0.2, profile.shotxg||0.12)) : 1)*0.5 + 1, 0.6, 1.6),
          fragility: V20.Master._clamp( (xga - stability*0.05), 0, 5),
          transitionBias: V20.Master._clamp((press-5)*0.15 + (momentum-5)*0.1, -1, 1),
          dnaTimestamp: V20.Master._now()
        };
      }
    };

    // DLA
    V20.Master.DLA = {
      adjustLambda: function(baseLam, ctx, home, away, pressInfo, meta){
        try{
          let lam = { ...baseLam };
          const momDiff = (home.momentum - away.momentum)/10;
          lam.lamH *= (1 + momDiff*0.35);
          lam.lamA *= (1 - momDiff*0.35);
          const fragH = Math.max(0, 1 - home.stability/12);
          const fragA = Math.max(0, 1 - away.stability/12);
          lam.lamH *= (1 + fragA*0.18);
          lam.lamA *= (1 + fragH*0.18);
          const ppdaRatio = (pressInfo.awayPPDA/Math.max(0.0001,pressInfo.homePPDA));
          lam.lamH *= (1 - (ppdaRatio-1)*0.08);
          lam.lamA *= (1 + (ppdaRatio-1)*0.08);
          lam.lamH *= (1 + (ctx.tempo-5)/5*0.08 + (ctx.chaos-5)/5*0.04);
          lam.lamA *= (1 + (ctx.tempo-5)/5*0.08 + (ctx.chaos-5)/5*0.04);
          lam.lamH *= (home.finishingBias || 1);
          lam.lamA *= (away.finishingBias || 1);
          const imp = V20.Master._safeNum(ctx.importance,5);
          const impAdj = 1 - (imp-5)*0.03;
          lam.lamH *= impAdj; lam.lamA *= impAdj;
          if(meta && meta.singularityBoost) {
            lam.lamH *= 1 + meta.singularityBoost*0.02;
            lam.lamA *= 1 + meta.singularityBoost*0.02;
          }
          lam.lamH = V20.Master._clamp(lam.lamH, 0.2, 8);
          lam.lamA = V20.Master._clamp(lam.lamA, 0.2, 8);
          return lam;
        }catch(e){
          console.warn("DLA.adjustLambda err",e);
          return baseLam;
        }
      }
    };

    // GSM
    V20.Master.GSM = {
      applyGameState: function(state, ctxMods){
        if(!ctxMods) return;
        const minute = V20.Master._safeNum(state.minute,0);
        const gd = (state.homeGoals - state.awayGoals);
        if(gd>0){ ctxMods.tempo *= 0.92; ctxMods.chaos *= 0.85; }
        else if(gd<0){ ctxMods.tempo *= 1.12; ctxMods.chaos *= 1.08; }
        else { if(minute>75) { ctxMods.tempo *= 1.05; ctxMods.chaos *= 1.06; } }
        if(minute>80 && Math.abs(gd)<=1){ ctxMods.tempo *= 1.12; ctxMods.chaos *= 1.10; }
        ctxMods.tempo = V20.Master._clamp(ctxMods.tempo, 0.5, 10);
        ctxMods.chaos = V20.Master._clamp(ctxMods.chaos, 0.5, 10);
        return ctxMods;
      }
    };

    // TEM
    V20.Master.TEM = {
      computeTransitionScore: function(home, away, pressInfo){
        const pressDiff = (pressInfo.homePPDA - pressInfo.awayPPDA) / 18;
        const deflineDiff = (away.defline - home.defline)/10;
        const momDiff = (home.momentum - away.momentum)/10;
        let scoreHome = ( (home.transitionBias || 0) + (-pressDiff*0.8) + momDiff*0.4 + deflineDiff*0.5 );
        let scoreAway = ( (away.transitionBias || 0) + (pressDiff*0.8) - momDiff*0.4 - deflineDiff*0.5 );
        scoreHome = V20.Master._clamp( (scoreHome+1)/2, 0, 1);
        scoreAway = V20.Master._clamp( (scoreAway+1)/2, 0, 1);
        return {scoreHome, scoreAway};
      }
    };

    // xT Lite
    V20.Master.xT = {
      computeLite: function(profile){
        const possession = V20.Master._safeNum(profile.possession,50)/100;
        const width = V20.Master._safeNum(profile.widthUse,0.5);
        const central = V20.Master._safeNum(profile.centralUse,0.5);
        const entries = V20.Master._safeNum(profile.finalThirdEntries,5);
        let xt = possession*0.4 + (central*0.35 + width*0.25) * 0.8 + (entries/10)*0.6;
        return V20.Master._clamp(xt, 0, 2.5);
      }
    };

    // FMA2
    V20.Master.FMA2 = {
      evaluate: function(homeFormation, awayFormation, profiles){
        const mapWidth = {'4-3-3':0.8,'4-2-3-1':0.7,'3-4-3':0.9,'5-3-2':0.5,'4-4-2':0.6};
        const hW = mapWidth[homeFormation] || 0.7;
        const aW = mapWidth[awayFormation] || 0.7;
        const wingAdv = (hW - aW);
        const centralAdv = ( (profiles.home.xGEfficiency||1) - (profiles.away.xGEfficiency||1) ) * 0.3;
        const fmaScore = V20.Master._clamp(wingAdv*0.8 + centralAdv, -1, 1);
        return {wingAdv, centralAdv, fmaScore};
      }
    };

    // SPS (score smoothing)
    V20.Master.SPS = {
      shapeScores: function(dist){
        const alpha = 0.92; const out = {}; let total = 0;
        for(let h in dist){ out[h]=out[h]||{}; for(let a in dist[h]){ let p = dist[h][a]||0; const closeBoost = (Math.abs(h-a)<=1)?1.06:0.97; p = Math.pow(p,alpha)*closeBoost; out[h][a]=p; total+=p; } }
        for(let h in out){ for(let a in out[h]){ out[h][a] /= Math.max(1e-12,total); } }
        return out;
      }
    };

    // AMPE
    V20.Master.AMPE = {
      phaseForMinute: function(minute){
        if(minute < 15) return 'early'; if(minute < 30) return 'control';
        if(minute < 45) return 'expansion'; if(minute < 60) return 'reset';
        if(minute < 75) return 'transition'; return 'surge';
      },
      phaseModifiers: function(phase){
        switch(phase){
          case 'early': return {tempo:1.05, chaos:1.08};
          case 'control': return {tempo:0.98, chaos:0.95};
          case 'expansion': return {tempo:1.02, chaos:1.03};
          case 'reset': return {tempo:0.95, chaos:0.98};
          case 'transition': return {tempo:1.08, chaos:1.10};
          case 'surge': return {tempo:1.15, chaos:1.18};
        }
        return {tempo:1, chaos:1};
      }
    };

    // Morale
    V20.Master.Morale = {
      compute: function(formScore, momentum, error){
        const m = V20.Master._safeNum(momentum,5); const f = V20.Master._safeNum(formScore,0); const e = V20.Master._safeNum(error,0);
        let morale = (f*0.6) + ((m-5)*0.4) - (e*0.3);
        return V20.Master._clamp(morale, -5, 5);
      }
    };

    // PCV
    V20.Master.PCV = {
      compute: function(uncertainty, stabilityDiff, ppdaDiff){
        const u = V20.Master._clamp(V20.Master._safeNum(uncertainty,0.2), 0, 1);
        const stab = V20.Master._clamp(V20.Master._safeNum(stabilityDiff,0)/10,0,1);
        const ppd = V20.Master._clamp(V20.Master._safeNum(ppdaDiff,0)/2,0,1);
        const score = (1-u)*0.6 + (1-stab)*0.2 + (1-ppd)*0.2;
        if(score > 0.75) return 'HIGH'; if(score > 0.45) return 'MEDIUM'; return 'LOW';
      }
    };

    // RC fuse
    V20.Master.RC = {
      fuse: function(components, hints){
        hints = hints || {};
        let w = {det:0.22, chaos:0.18, hybrid:0.2, infinity:0.2, xT:0.2};
        const vol = V20.Master._safeNum(hints.volatility, 0.2);
        w.chaos += V20.Master._clamp(vol*0.5,0,0.25);
        const finSkew = V20.Master._safeNum(hints.finSkew, 0);
        w.infinity += V20.Master._clamp(Math.abs(finSkew)*0.15,0,0.2);
        let sum = Object.values(w).reduce((s,n)=>s+n,0);
        for(let k in w) w[k] /= sum;
        const final = {pH:0,pD:0,pA:0};
        for(let k in components){
          const c = components[k]; const wk = w[k] || 0;
          final.pH += (c.pH||0) * wk; final.pD += (c.pD||0) * wk; final.pA += (c.pA||0) * wk;
        }
        const tot = final.pH+final.pD+final.pA || 1; final.pH/=tot; final.pD/=tot; final.pA/=tot;
        return final;
      }
    };

    // SelfCal (light)
    V20.Master.SelfCal = {
      memory: { history: [], maxLen: 120 },
      record: function(matchInput,result,preds){ this.memory.history.push({input:matchInput, result, preds, ts:V20.Master._now()}); if(this.memory.history.length>this.memory.maxLen) this.memory.history.shift(); },
      calibrateWeights: function(){ const hist=this.memory.history; if(hist.length<8) return null; let biasSum=0; hist.slice(-30).forEach(h=>{ const {result,preds}=h; const predChoice = preds.pH>preds.pA && preds.pH>preds.pD ? 'H' : (preds.pA>preds.pH && preds.pA>preds.pD ? 'A':'D'); biasSum += (predChoice===result)?0:(result==='H'?-0.4:(result==='A'?0.4:0)); }); if(Math.abs(biasSum)>3) return {biasNudge: V20.Master._clamp(biasSum/30,-0.05,0.05)}; return null; }
    };

    // ChronoSim (light)
    V20.Master.ChronoSim = {
      simulateMatch: function(params, opts){
        opts = opts||{};
        const cap = V20.Master._safeNum(opts.cap,6);
        const step = V20.Master._safeNum(opts.minuteStep,5);
        const sim = {matrix:[], events: [], final:{h:0,a:0}, avgGoals:0, simCount:1};
        const minutes = Array.from({length: Math.ceil(90/step)}, (_,i)=>i*step);
        let lamHtotal = V20.Master._safeNum(params.lamH,1.2);
        let lamAtotal = V20.Master._safeNum(params.lamA,1.0);
        minutes.forEach((m)=>{
          const phase = V20.Master.AMPE.phaseForMinute(m);
          const phmod = V20.Master.AMPE.phaseModifiers(phase);
          const lH = lamHtotal * (phmod.tempo + phmod.chaos)/2 * 0.12;
          const lA = lamAtotal * (phmod.tempo + phmod.chaos)/2 * 0.12;
          const pGoalH = 1 - Math.exp(-lH);
          const pGoalA = 1 - Math.exp(-lA);
          if(Math.random() < pGoalH) sim.final.h += 1, sim.events.push({min:m,team:'H'});
          if(Math.random() < pGoalA) sim.final.a += 1, sim.events.push({min:m,team:'A'});
        });
        const mat = Array.from({length:cap+1}, ()=>Array.from({length:cap+1}, ()=>0));
        mat[sim.final.h] = mat[sim.final.h] || []; mat[sim.final.h][sim.final.a] = (mat[sim.final.h][sim.final.a] || 0) + 1;
        sim.matrix = mat; sim.avgGoals = sim.final.h + sim.final.a; return sim;
      }
    };

    // masterRun integrator
    V20.Master.masterRun = function(context){
      try{
        const baseLam = { lamH: V20.Master._safeNum(context.lamH,1.2), lamA: V20.Master._safeNum(context.lamA,1.0) };
        const ctx = { tempo: V20.Master._safeNum(context.tempo,5), chaos: V20.Master._safeNum(context.chaos,5), importance: V20.Master._safeNum(context.importance,5) };
        const home = context.home || {}; const away = context.away || {};
        V20.Master.ANS.clampInputs({ ppda_home: context.ppda_home, ppda_away: context.ppda_away, fin_home: context.fin_home, fin_away: context.fin_away, mom_home: context.mom_home, mom_away: context.mom_away, stab_home: context.stab_home, stab_away: context.stab_away});
        const homeProfile = Object.assign({}, home, { finishingBias: context.fin_home || 1, stability: context.stab_home || 5, momentum: context.mom_home || 5, defline: context.defline_home || 5, xg: context.xg_home || 1.0, xga: context.xga_home || 1.0, transitionBias: context.homeTransitionBias || 0, shotxg: context.homeShotXG || 0.12, xGEfficiency: context.homeXGEff || 1 });
        const awayProfile = Object.assign({}, away, { finishingBias: context.fin_away || 1, stability: context.stab_away || 5, momentum: context.mom_away || 5, defline: context.defline_away || 5, xg: context.xg_away || 1.0, xga: context.xga_away || 1.0, transitionBias: context.awayTransitionBias || 0, shotxg: context.awayShotXG || 0.12, xGEfficiency: context.awayXGEff || 1 });
        const pressInfo = { homePPDA: V20.Master._safeNum(context.ppda_home,12), awayPPDA: V20.Master._safeNum(context.ppda_away,12), pressMatchFactor: context.pressMatchFactor || 0 };
        const homeDNA = V20.Master.SyntheticDNA.buildFromProfile(homeProfile);
        const awayDNA = V20.Master.SyntheticDNA.buildFromProfile(awayProfile);
        const adjustedLam = (V20.Master.flags && V20.Master.flags.ENABLE_DLA===false)? baseLam : V20.Master.DLA.adjustLambda(baseLam, ctx, homeProfile, awayProfile, pressInfo, context.meta||{});
        const transition = (V20.Master.flags && V20.Master.flags.ENABLE_TEM===false)? {scoreHome:0.5,scoreAway:0.5} : V20.Master.TEM.computeTransitionScore(homeProfile, awayProfile, pressInfo);
        const xtHome = (V20.Master.flags && V20.Master.flags.ENABLE_xT===false)? 1 : V20.Master.xT.computeLite({possession:context.possession_home||50,widthUse:context.homeWidth||0.5,centralUse:context.homeCentral||0.5,finalThirdEntries:context.homeEntries||5});
        const xtAway = (V20.Master.flags && V20.Master.flags.ENABLE_xT===false)? 1 : V20.Master.xT.computeLite({possession:context.possession_away||50,widthUse:context.awayWidth||0.5,centralUse:context.awayCentral||0.5,finalThirdEntries:context.awayEntries||5});
        const fma = (V20.Master.flags && V20.Master.flags.ENABLE_FMA2===false)? {fmaScore:0} : V20.Master.FMA2.evaluate(context.homeFormation||'4-3-3', context.awayFormation||'4-4-2', {home:{xGEfficiency:homeProfile.xGEfficiency}, away:{xGEfficiency:awayProfile.xGEfficiency}});
        const chrono = (V20.Master.flags && V20.Master.flags.ENABLE_CHRONOSIM===false)? {avgGoals: (adjustedLam.lamH+adjustedLam.lamA)} : V20.Master.ChronoSim.simulateMatch({lamH:adjustedLam.lamH, lamA:adjustedLam.lamA}, {cap: context.scoreCap||6, minuteStep:5});
        const hints = { volatility: Math.abs(ctx.chaos - 5) + Math.abs((homeProfile.momentum - awayProfile.momentum)/5), finSkew: (homeProfile.finishingBias - awayProfile.finishingBias), xtDiff: xtHome - xtAway };
        return { adjustedLam, pressInfo, transition, xtHome, xtAway, fma, chrono, hints, homeDNA, awayDNA };
      }catch(e){ console.warn("masterRun err",e); return null; }
    };
// flags defaults
    V20.Master.flags = { ENABLE_DLA:true, ENABLE_GSM:true, ENABLE_TEM:true, ENABLE_xT:true, ENABLE_FMA2:true, ENABLE_CHRONOSIM:true, ENABLE_SELFCAL:true, ENABLE_RC:true, ENABLE_PCV:true, ENABLE_ANS:true };
  })();

  /* ============================
     AUTOHYBRID — HYBRID PRO (Auto + Hybrid selection)
     Paste after Master.Auto (integrated)
     ============================ */
  (function(){
    V20.AutoHybrid = V20.AutoHybrid || {};
    const _safe = (v,d=0)=> (typeof v === 'number' && isFinite(v)) ? v : ( (v!==undefined && !isNaN(Number(v))) ? Number(v) : d );
    const _clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
    const now = ()=> Date.now();

    function confFromDataRichness(ctxPiece){
      let score = 0;
      if(_safe(ctxPiece.shots,0) >= 6) score += 0.35;
      if(_safe(ctxPiece.possession,0) > 0) score += 0.25;
      if(_safe(ctxPiece.xg,0) > 0) score += 0.2;
      if(typeof ctxPiece.formPts === 'number' && ctxPiece.formPts !== 0) score += 0.2;
      return _clamp(score, 0, 1);
    }

    const auto = {
      tempo: function(ctx){ const shots = _safe(ctx.shots_home,10) + _safe(ctx.shots_away,8); const base = (shots/4) + (_safe(ctx.chaos,5)/2); return _clamp(base, 1, 10); },
      chaos: function(ctx){ const ppdaDiff = Math.abs(_safe(ctx.ppda_home,12) - _safe(ctx.ppda_away,12)); const t = _safe(ctx.transition,5); const rf = Math.random()*0.6 - 0.3; const val = (ppdaDiff/3) + (t/4) + rf + 4.5; return _clamp(val, 1, 10); },
      stability: function(teamCtx){ const conceded = _safe(teamCtx.conceded_last5,2); const chaos = _safe(teamCtx.chaos,5); const base = 7 - (conceded/1.2) - ( (chaos-5) / 2.5 ); return _clamp(base, 1, 10); },
      momentum: function(teamCtx){ const form = _safe(teamCtx.formPts_last5,6); const fin = _safe(teamCtx.finishingSurge,0); const base = (form/15)*10 + (fin*0.18); return _clamp(base, 1, 10); },
      pressIntensity: function(ppda){ const val = (_safe(18 - ppda,6) / 1.5); return _clamp(val, 1, 10); },
      flex: function(teamCtx){ const possession = _safe(teamCtx.possession,50); const rigidity = _safe(teamCtx.rigidityFactor,0.5); const val = 5 + ((possession - 50) / 10) - (rigidity*2); return _clamp(val, 1, 10); },
      managerAggression: function(teamCtx){ const shots = _safe(teamCtx.shots,8); const press = _safe(teamCtx.pressIntensity,5); const attackBias = _safe(teamCtx.attackingBias,0); const val = (shots/10) + (press/3) + attackBias; return _clamp(val, 1, 10); },
      defLine: function(teamCtx){ const possession = _safe(teamCtx.possession,50); const conceded = _safe(teamCtx.conceded_last5,2); const val = 5 + ((possession - 50) / 8) - (conceded/10); return _clamp(val, 1, 10); },
      injuryImpact: function(teamCtx){ const inj = _safe(teamCtx.injuries,0); const depth = _safe(teamCtx.squadDepth,5); const base = inj * 1.2 - (depth*0.3); return _clamp(base, 0, 10); },
      transitionBias: function(teamCtx){ const press = _safe(teamCtx.pressIntensity,5); const defline = _safe(teamCtx.defLine,5); const momentum = _safe(teamCtx.momentum,5); const chaos = _safe(teamCtx.chaos,5); const val = (press - defline)/2 + (momentum/5) + (chaos/4) + 5; return _clamp(val, 1, 10); },
      pressLevel: function(teamCtx){ const press = _safe(teamCtx.pressIntensity,5); const defline = _safe(teamCtx.defLine,5); const val = 6 + (press/3) - (defline/4); return _clamp(val, 1, 10); }
    };

    V20.AutoHybrid.computeAll = function(ctx){
      ctx = ctx || {};
      const base = {
        shots_total: _safe(ctx.shots_home,10) + _safe(ctx.shots_away,8),
        ppda_home: _safe(ctx.ppda_home,12),
        ppda_away: _safe(ctx.ppda_away,12),
        possession_home: _safe(ctx.possession_home,50),
        possession_away: _safe(ctx.possession_away,50),
        chaos: _safe(ctx.chaos,5)
      };
      const autoTempo = auto.tempo({shots_home:ctx.shots_home, shots_away:ctx.shots_away, chaos:base.chaos});
      const autoChaos = auto.chaos({ppda_home:base.ppda_home, ppda_away:base.ppda_away, transition:_safe(ctx.transition,5)});
      const ppdaHome = _safe(ctx.ppda_home, V20.Master ? V20.Master.Auto.autoPPDAFromPressDefline(_safe(ctx.home_press,5), _safe(ctx.defline_home,5), _safe(ctx.home_mom,5)) : 12);
      const ppdaAway = _safe(ctx.ppda_away, V20.Master ? V20.Master.Auto.autoPPDAFromPressDefline(_safe(ctx.away_press,5), _safe(ctx.defline_away,5), _safe(ctx.away_mom,5)) : 12);
const homeCtx = { xg: _safe(ctx.xg_home, _safe(ctx.lamH,1.2)), shots: _safe(ctx.shots_home,10), possession: _safe(ctx.possession_home,50), formPts_last5: _safe(ctx.formPts_home,6), conceded_last5: _safe(ctx.conceded_last5_home,2), injuries: _safe(ctx.injuries_home,0), squadDepth: _safe(ctx.squadDepth_home,5), attackingBias: _safe(ctx.home_attackBias,0), chaos: autoChaos };
      const awayCtx = { xg: _safe(ctx.xg_away, _safe(ctx.lamA,1.0)), shots: _safe(ctx.shots_away,8), possession: _safe(ctx.possession_away,50), formPts_last5: _safe(ctx.formPts_away,5), conceded_last5: _safe(ctx.conceded_last5_away,2), injuries: _safe(ctx.injuries_away,0), squadDepth: _safe(ctx.squadDepth_away,5), attackingBias: _safe(ctx.away_attackBias,0), chaos: autoChaos };

      const homeAuto = {}; const awayAuto = {};
      homeAuto.stability = auto.stability({conceded_last5:homeCtx.conceded_last5, chaos:autoChaos});
      awayAuto.stability = auto.stability({conceded_last5:awayCtx.conceded_last5, chaos:autoChaos});
      homeAuto.momentum = auto.momentum({formPts_last5:homeCtx.formPts_last5, finishingSurge:_safe(ctx.home_finishingSurge,0)});
      awayAuto.momentum = auto.momentum({formPts_last5:awayCtx.formPts_last5, finishingSurge:_safe(ctx.away_finishingSurge,0)});
      homeAuto.pressIntensity = auto.pressIntensity(ppdaHome);
      awayAuto.pressIntensity = auto.pressIntensity(ppdaAway);
      homeAuto.flex = auto.flex({possession:homeCtx.possession, rigidityFactor:_safe(ctx.home_rigidity,0.5)});
      awayAuto.flex = auto.flex({possession:awayCtx.possession, rigidityFactor:_safe(ctx.away_rigidity,0.5)});
      homeAuto.managerAgg = auto.managerAggression({shots:homeCtx.shots, pressIntensity:homeAuto.pressIntensity, attackingBias:homeCtx.attackingBias});
      awayAuto.managerAgg = auto.managerAggression({shots:awayCtx.shots, pressIntensity:awayAuto.pressIntensity, attackingBias:awayCtx.attackingBias});
      homeAuto.defLine = auto.defLine({possession:homeCtx.possession, conceded_last5:homeCtx.conceded_last5});
      awayAuto.defLine = auto.defLine({possession:awayCtx.possession, conceded_last5:awayCtx.conceded_last5});
      homeAuto.injuryImpact = auto.injuryImpact({injuries:homeCtx.injuries, squadDepth:homeCtx.squadDepth});
      awayAuto.injuryImpact = auto.injuryImpact({injuries:awayCtx.injuries, squadDepth:awayCtx.squadDepth});
      homeAuto.transition = auto.transitionBias({pressIntensity:homeAuto.pressIntensity, defLine:homeAuto.defLine, momentum:homeAuto.momentum, chaos:autoChaos});
      awayAuto.transition = auto.transitionBias({pressIntensity:awayAuto.pressIntensity, defLine:awayAuto.defLine, momentum:awayAuto.momentum, chaos:autoChaos});
      homeAuto.pressLevel = auto.pressLevel({pressIntensity:homeAuto.pressIntensity, defLine:homeAuto.defLine});
      awayAuto.pressLevel = auto.pressLevel({pressIntensity:awayAuto.pressIntensity, defLine:awayAuto.defLine});

      const autoVals = { tempo: autoTempo, chaos: autoChaos, ppda_home: ppdaHome, ppda_away: ppdaAway };
      const confHome = confFromDataRichness({shots:homeCtx.shots, possession:homeCtx.possession, xg:homeCtx.xg, formPts:homeCtx.formPts_last5});
      const confAway = confFromDataRichness({shots:awayCtx.shots, possession:awayCtx.possession, xg:awayCtx.xg, formPts:awayCtx.formPts_last5});
      const confGlobal = _clamp((confHome + confAway)/2, 0, 1);

      function choose(fieldName, manualHome, autoHome, manualAway, autoAway){
        const mh = (manualHome !== undefined && !isNaN(Number(manualHome))) ? Number(manualHome) : null;
        const ma = (manualAway !== undefined && !isNaN(Number(manualAway))) ? Number(manualAway) : null;
        const ch = (mh !== null) ? ( (confHome > 0.45) ? ( (Math.abs(mh-autoHome) < 0.8) ? mh : ( (Math.random()<0.5)?autoHome:mh ) ) : autoHome ) : autoHome;
        const ca = (ma !== null) ? ( (confAway > 0.45) ? ( (Math.abs(ma-autoAway) < 0.8) ? ma : ( (Math.random()<0.5)?autoAway:ma ) ) : autoAway ) : autoAway;
        const confH = _clamp( (confHome*0.6) + (1 - Math.min(1, Math.abs(ch - autoHome)/5))*0.4, 0, 1 );
        const confA = _clamp( (confAway*0.6) + (1 - Math.min(1, Math.abs(ca - autoAway)/5))*0.4, 0, 1 );
        return {home: _clamp(ch,1,10), away: _clamp(ca,1,10), confHome:confH, confAway:confA};
      }

      const chosen = {}; const confidences = {};
      const stabPick = choose('stability', ctx.manual_stab_home, homeAuto.stability, ctx.manual_stab_away, awayAuto.stability);
      chosen.stability_home = stabPick.home; chosen.stability_away = stabPick.away; confidences.stability_home = stabPick.confHome; confidences.stability_away = stabPick.confAway;
      const momPick = choose('momentum', ctx.manual_mom_home, homeAuto.momentum, ctx.manual_mom_away, awayAuto.momentum);
      chosen.momentum_home = momPick.home; chosen.momentum_away = momPick.away; confidences.momentum_home = momPick.confHome; confidences.momentum_away = momPick.confAway;
      const pressPick = choose('press', ctx.manual_press_home, homeAuto.pressIntensity, ctx.manual_press_away, awayAuto.pressIntensity);
      chosen.press_home = pressPick.home; chosen.press_away = pressPick.away; confidences.press_home = pressPick.confHome; confidences.press_away = pressPick.confAway;
      const flexPick = choose('flex', ctx.manual_flex_home, homeAuto.flex, ctx.manual_flex_away, awayAuto.flex);
      chosen.flex_home = flexPick.home; chosen.flex_away = flexPick.away; confidences.flex_home = flexPick.confHome; confidences.flex_away = flexPick.confAway;
      const aggPick = choose('agg', ctx.manual_agg_home, homeAuto.managerAgg, ctx.manual_agg_away, awayAuto.managerAgg);
      chosen.managerAgg_home = aggPick.home; chosen.managerAgg_away = aggPick.away; confidences.managerAgg_home = aggPick.confHome; confidences.managerAgg_away = aggPick.confAway;
      const defPick = choose('defline', ctx.manual_defline_home, homeAuto.defLine, ctx.manual_defline_away, awayAuto.defLine);
      chosen.defline_home = defPick.home; chosen.defline_away = defPick.away; confidences.defline_home = defPick.confHome; confidences.defline_away = defPick.confAway;
      const injPick = choose('inj', ctx.manual_inj_home, homeAuto.injuryImpact, ctx.manual_inj_away, awayAuto.injuryImpact);
      chosen.injury_home = injPick.home; chosen.injury_away = injPick.away; confidences.injury_home = injPick.confHome; confidences.injury_away = injPick.confAway;
      const transPick = choose('trans', ctx.manual_trans_home, homeAuto.transition, ctx.manual_trans_away, awayAuto.transition);
      chosen.transition_home = transPick.home; chosen.transition_away = transPick.away; confidences.transition_home = transPick.confHome; confidences.transition_away = transPick.confAway;
      const plPick = choose('pressLevel', ctx.manual_pressLevel_home, homeAuto.pressLevel, ctx.manual_pressLevel_away, awayAuto.pressLevel);
      chosen.pressLevel_home = plPick.home; chosen.pressLevel_away = plPick.away; confidences.pressLevel_home = plPick.confHome; confidences.pressLevel_away = plPick.confAway;
      const tempoPick = choose('tempo', ctx.manual_tempo, autoTempo, ctx.manual_tempo, autoTempo);
      chosen.tempo = tempoPick.home; confidences.tempo = tempoPick.confHome;
      const chaosPick = choose('chaos', ctx.manual_chaos, autoChaos, ctx.manual_chaos, autoChaos);
      chosen.chaos = chaosPick.home; confidences.chaos = chaosPick.confHome;
const result = {
        auto: { tempo: autoTempo, chaos: autoChaos, home: homeAuto, away: awayAuto },
        chosen: chosen,
        confidence: confidences,
        meta: { confHome, confAway, confGlobal, timestamp: now() }
      };
      return result;
    };

    V20.AutoHybrid.applyChosenToUI = function(hybridResult){
      try{
        if(!hybridResult) return;
        if(document.getElementById('tempo')) document.getElementById('tempo').value = Number(hybridResult.chosen.tempo).toFixed(2);
        if(document.getElementById('chaos')) document.getElementById('chaos').value = Number(hybridResult.chosen.chaos).toFixed(2);
        if(document.getElementById('home_st')) document.getElementById('home_st').value = Number(hybridResult.chosen.stability_home).toFixed(2);
        if(document.getElementById('away_st')) document.getElementById('away_st').value = Number(hybridResult.chosen.stability_away).toFixed(2);
        if(document.getElementById('home_mom')) document.getElementById('home_mom').value = Number(hybridResult.chosen.momentum_home).toFixed(2);
        if(document.getElementById('away_mom')) document.getElementById('away_mom').value = Number(hybridResult.chosen.momentum_away).toFixed(2);
        if(document.getElementById('home_press')) document.getElementById('home_press').value = Number(hybridResult.chosen.press_home).toFixed(2);
        if(document.getElementById('away_press')) document.getElementById('away_press').value = Number(hybridResult.chosen.press_away).toFixed(2);
        if(document.getElementById('home_flex')) document.getElementById('home_flex').value = Number(hybridResult.chosen.flex_home).toFixed(2);
        if(document.getElementById('away_flex')) document.getElementById('away_flex').value = Number(hybridResult.chosen.flex_away).toFixed(2);
        if(document.getElementById('defline_home')) document.getElementById('defline_home').value = Number(hybridResult.chosen.defline_home).toFixed(2);
        if(document.getElementById('defline_away')) document.getElementById('defline_away').value = Number(hybridResult.chosen.defline_away).toFixed(2);
        if(document.getElementById('injury_home')) document.getElementById('injury_home').value = Number(hybridResult.chosen.injury_home).toFixed(2);
        if(document.getElementById('injury_away')) document.getElementById('injury_away').value = Number(hybridResult.chosen.injury_away).toFixed(2);
        if(document.getElementById('ppda_home')) document.getElementById('ppda_home').value = Number(hybridResult.auto.ppda_home).toFixed(2);
        if(document.getElementById('ppda_away')) document.getElementById('ppda_away').value = Number(hybridResult.auto.ppda_away).toFixed(2);
        if(document.getElementById('status')) document.getElementById('status').textContent = "Hybrid-Auto applied (Hybrid PRO).";
      }catch(e){ console.warn("applyChosenToUI err", e); }
    };

    V20.AutoHybrid.computeAndApply = function(ctx){
      const res = V20.AutoHybrid.computeAll(ctx);
      V20.AutoHybrid.applyChosenToUI(res);
      return res;
    };

  })();

  /* ============================
     Recommender (HDP/OU/BTTS/Score/Value/Risk)
     ============================ */
  (function(){
    V20.Reco = V20.Reco || {};
    const CL = (v,a,b)=>Math.max(a,Math.min(b,v));
    V20.Reco.HDP = function(pH,pD,pA,fragH,fragA,momH,momA,fmaScore){
      const bias = (momH - momA)/10 + fmaScore*0.4 - (fragH-fragA)*0.03;
      let rec="", conf=0;
      if(pH>pA && pH>pD){
        if(pH>0.55 || bias>0.25){ rec="Home -0.25"; conf=(pH*0.55 + (bias+1)/2*0.45)*100; } else { rec="Home +0.0"; conf=pH*100; }
      } else if(pA>pH && pA>pD){
        if(pA>0.55 || bias<-0.25){ rec="Away -0.25"; conf=(pA*0.55 + (1-bias)/2*0.45)*100; } else { rec="Away +0.0"; conf=pA*100; }
      } else { rec="No Bet (Draw heavy)"; conf=Math.max(pD*100,20); }
      return {rec, conf:CL(conf,20,95)};
    };
    V20.Reco.OU = function(ouBlend, avgGoals, tempo, chaos, transitionScore){
      let pick=""; let baseOU = avgGoals;
      if(baseOU >= 2.3 && (ouBlend["2.5"] && ouBlend["2.5"].over>0.55)){ pick="Over 2.5"; }
      else if(baseOU <= 2.1 && (ouBlend["2.5"] && ouBlend["2.5"].under>0.55)){ pick="Under 2.5"; }
      else { if(transitionScore>0.55) pick="Over 2.0"; else pick="Under 3.0"; }
      const conf = CL((Math.abs(baseOU-2.5)*15) + (Math.abs(transitionScore-0.5)*35) + ((tempo-5)/5*20) + ((chaos-5)/5*20),35,92);
      return {pick, conf};
    };
    V20.Reco.BTTS = function(prob, xtH, xtA, finH, finA){
      let pick = prob>=0.54 ? "YES":"NO";
      let conf = (prob*70) + ((xtH+xtA)/2*20) + ((finH+finA)/2*5); conf = CL(conf,25,90);
      return {pick, conf};
    };
    V20.Reco.Score = function(matrix){
      const scores=[]; for(let h in matrix){ for(let a in matrix[h]) scores.push({score:`${h}-${a}`, prob:matrix[h][a]}); }
scores.sort((x,y)=>y.prob-x.prob); return scores.slice(0,3).map(s=>({score:s.score, prob:(s.prob*100).toFixed(1)}));
    };
    V20.Reco.Value = function(fairProb, marketOdds){ if(!marketOdds) return {value:"N/A"}; const fairOdds=1/fairProb; const v = marketOdds - fairOdds; if(v>0.15) return {value:"STRONG", diff:v.toFixed(2)}; if(v>0.05) return {value:"MILD", diff:v.toFixed(2)}; return {value:"NONE", diff:v.toFixed(2)}; };
    V20.Reco.Risk = function(volatility, uncertainty, fragH, fragA, chaos){ const score = (volatility*0.35) + (uncertainty*0.25) + (Math.abs(fragH-fragA)/10*0.2) + ((chaos-5)/5*0.2); if(score<0.33) return {level:"SAFE", score:score.toFixed(2)}; if(score<0.66) return {level:"BALANCED", score:score.toFixed(2)}; return {level:"CHAOTIC", score:score.toFixed(2)}; };
  })();

  /* ============================
     Lightweight detSim & MonteCarlo
     ============================ */
  (function(){
    V20.detSim = function(lambda){
      const lamH = V20.num(lambda.lamH,1.2), lamA = V20.num(lambda.lamA,1.0);
      const max = 6;
      const mat = Array.from({length:max+1},()=>Array.from({length:max+1},()=>0));
      const fact = n=>{ let r=1; for(let i=2;i<=n;i++) r*=i; return r; };
      for(let h=0;h<=max;h++){ for(let a=0;a<=max;a++){
        const pH = Math.exp(-lamH)*Math.pow(lamH,h)/fact(h);
        const pA = Math.exp(-lamA)*Math.pow(lamA,a)/fact(a);
        mat[h][a] = pH * pA;
      } }
      let pH=0,pD=0,pA=0;
      for(let h=0;h<=max;h++){ for(let a=0;a<=max;a++){ if(h>a) pH+=mat[h][a]; else if(h==a) pD+=mat[h][a]; else pA+=mat[h][a]; } }
      return {pH,pD,pA,mat,lamH,lamA};
    };

    V20.monteCarlo = function(lambda, ctx, simCount, scoreCap){
      simCount = isFinite(Number(simCount))?Number(simCount):2000;
      scoreCap = isFinite(Number(scoreCap))?Number(scoreCap):6;
      const mat = Array.from({length:scoreCap+1}, ()=>Array.from({length:scoreCap+1}, ()=>0));
      let cntH=0,cntD=0,cntA=0, totGoals=0;
      for(let i=0;i<simCount;i++){
        const lamH = V20.num(lambda.lamH,1.2);
        const lamA = V20.num(lambda.lamA,1.0);
        const h = samplePoisson(lamH);
        const a = samplePoisson(lamA);
        const hcap = Math.min(scoreCap,h); const acap = Math.min(scoreCap,a);
        mat[hcap][acap] += 1;
        totGoals += h + a;
        if(h>a) cntH++; else if(h==a) cntD++; else cntA++;
      }
      return {matrix:mat, simCount, pH:cntH/simCount, pD:cntD/simCount, pA:cntA/simCount, avgGoals: totGoals/simCount, scoreCap};
      function samplePoisson(lambda){
        const L = Math.exp(-lambda); let k=0; let p=1;
        do{ k++; p *= Math.random(); } while(p > L);
        return k-1;
      }
    };
  })();

  /* ============================
     Utility compute functions & fuse
     ============================ */
  (function(){
    V20.computeUncertainty = function(pH,pD,pA){
      const max = Math.max(pH,pD,pA);
      const unc = 1 - max;
      return {score: Math.max(2, Math.min(90, unc*100))};
    };
    V20.computeBTTS = function(godHL){
      const sum = (godHL.lamH || 1) + (godHL.lamA || 1);
      return Math.min(0.95, 0.28 + sum*0.12);
    };
    V20.computeRisk = function(ctx, tact){
      const r = (Math.abs(ctx.chaos-5)/5)*0.6 + (Math.abs(ctx.tempo-5)/5)*0.2 + ((tact.home.pressIntensity||5)+(tact.away.pressIntensity||5))/20*0.2;
      return Math.min(1, Math.max(0, r));
    };
    V20.computeFragility = function(ctx, home, away){
      return Math.max(0, (10 - Math.max(home.stability || 5, away.stability || 5))/10);
    };
    V20.computeMeta = function(det, detChaos, sdi){ return 0.5; };
    V20.computeFlow = function(ctx, home, away, tact, godPat){ return 0.5; };
    V20.computeMomentumSwing = function(home, away){ return Math.max(0, ((home.momentum || 5) - (away.momentum || 5))/10); };

    V20.fuseOutputs = function(det, detChaos, mc, zeroProb){
      const pH = (det.pH + detChaos.pH + mc.pH)/3;
      const pD = (det.pD + detChaos.pD + mc.pD)/3;
      const pA = (det.pA + detChaos.pA + mc.pA)/3;
      const tot = pH+pD+pA || 1;
      return {final:{pH:pH/tot,pD:pD/tot,pA:pA/tot}};
    };
  })();
/* ============================
     Build context from UI
     ============================ */
  function buildContextFromUI(){
    const ctx = {};
    ctx.home_team = document.getElementById('home_team').value;
    ctx.away_team = document.getElementById('away_team').value;
    ctx.league = document.getElementById('league').value;
    ctx.match_type = document.getElementById('match_type').value;

    ctx.lamH = V20.num(document.getElementById('lamH').value,1.2);
    ctx.lamA = V20.num(document.getElementById('lamA').value,1.0);
    ctx.tempo = V20.num(document.getElementById('tempo').value,5);
    ctx.chaos = V20.num(document.getElementById('chaos').value,5);
    ctx.importance = V20.num(document.getElementById('importance').value,5);

    ctx.home_st = V20.num(document.getElementById('home_st').value,5);
    ctx.away_st = V20.num(document.getElementById('away_st').value,5);
    ctx.home_mom = V20.num(document.getElementById('home_mom').value,5);
    ctx.away_mom = V20.num(document.getElementById('away_mom').value,5);

    ctx.home_press = V20.num(document.getElementById('home_press').value,5);
    ctx.away_press = V20.num(document.getElementById('away_press').value,5);
    ctx.home_flex = V20.num(document.getElementById('home_flex').value,0.5);
    ctx.away_flex = V20.num(document.getElementById('away_flex').value,0.5);

    ctx.fin_home = V20.num(document.getElementById('finishing_quality_home').value,5);
    ctx.fin_away = V20.num(document.getElementById('finishing_quality_away').value,5);
    ctx.injury_home = V20.num(document.getElementById('injury_home').value,0);
    ctx.injury_away = V20.num(document.getElementById('injury_away').value,0);
    ctx.manager_agg_home = V20.num(document.getElementById('manager_agg_home').value,5);
    ctx.manager_agg_away = V20.num(document.getElementById('manager_agg_away').value,5);

    ctx.defline_home = V20.num(document.getElementById('defline_home').value,5);
    ctx.defline_away = V20.num(document.getElementById('defline_away').value,5);
    ctx.ppda_home = V20.num(document.getElementById('ppda_home').value,12);
    ctx.ppda_away = V20.num(document.getElementById('ppda_away').value,12);

    ctx.xg_home = V20.num(document.getElementById('xg_home').value, ctx.lamH);
    ctx.xg_away = V20.num(document.getElementById('xg_away').value, ctx.lamA);
    ctx.shots_home = V20.num(document.getElementById('shots_home').value,10);
    ctx.shots_away = V20.num(document.getElementById('shots_away').value,8);
    ctx.shotq_home = V20.num(document.getElementById('shotq_home').value,0.12);
    ctx.shotq_away = V20.num(document.getElementById('shotq_away').value,0.10);
    ctx.possession_home = V20.num(document.getElementById('pos_home').value,50);
    ctx.possession_away = V20.num(document.getElementById('pos_away').value,50);
    ctx.formPts_home = V20.num(document.getElementById('form_home').value,6);
    ctx.formPts_away = V20.num(document.getElementById('form_away').value,5);
    ctx.conceded_last5_home = V20.num(document.getElementById('conceded_home').value,2);
    ctx.conceded_last5_away = V20.num(document.getElementById('conceded_away').value,2);
    ctx.squadDepth_home = V20.num(document.getElementById('squad_home').value,5);
    ctx.squadDepth_away = V20.num(document.getElementById('squad_away').value,5);

    ctx.scoreCap = 6;
    ctx.homeFormation = document.getElementById('home_formation')?.value || '4-3-3';
    ctx.awayFormation = document.getElementById('away_formation')?.value || '4-4-2';
    return ctx;
  }
/* ============================
     Build Super Output (text)
     ============================ */
  function buildSuperOutput(vars){
    const out = [];
    out.push("============================================================");
    out.push("                P S Z   S U P E R   O U T P U T");
    out.push("============================================================");
    out.push("");
    out.push("[ENGINE STATUS] " + vars.engineStatus);
    out.push("Confidence Level : " + vars.pcv);
    out.push("Volatility Index : " + vars.volatility.toFixed(2));
    out.push("Uncertainty      : " + (vars.unc.score).toFixed(1) + "%");
    out.push("Risk Level       : " + vars.riskR.level + " (" + vars.riskR.score + ")");
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("INPUT SUMMARY");
    out.push("------------------------------------------------------------");
    out.push("λH (base): " + vars.lamH.toFixed(2) + " → adjusted: " + vars.mOut.adjustedLam.lamH.toFixed(2));
    out.push("λA (base): " + vars.lamA.toFixed(2) + " → adjusted: " + vars.mOut.adjustedLam.lamA.toFixed(2));
    out.push("Tempo / Chaos / Importance : " + vars.tempo + " / " + vars.chaos + " / " + vars.importance);
    out.push("Home Stability/Momentum    : " + vars.home_st + " / " + vars.home_mom);
    out.push("Away Stability/Momentum    : " + vars.away_st + " / " + vars.away_mom);
    out.push("PPDA (H/A)                 : " + vars.ppda_home + " / " + vars.ppda_away);
    out.push("Finishing (H/A)            : " + vars.fin_home + " / " + vars.fin_away);
    out.push("Defline (H/A)              : " + vars.defline_home + " / " + vars.defline_away);
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("ADVANCED MODULE OUTPUTS (LEVEL DEWA)");
    out.push("------------------------------------------------------------");
    out.push("Transition Score    : H " + vars.mOut.transition.scoreHome.toFixed(2) + " | A " + vars.mOut.transition.scoreAway.toFixed(2));
    out.push("xT Attack           : H " + vars.mOut.xtHome.toFixed(2) + " | A " + vars.mOut.xtAway.toFixed(2));
    out.push("Formation Matchup   : " + (vars.mOut.fma.fmaScore >= 0 ? "Home advantage":"Away advantage") + " (" + vars.mOut.fma.fmaScore.toFixed(2) + ")");
    out.push("Morale Index        : H " + vars.moraleH.toFixed(2) + " | A " + vars.moraleA.toFixed(2));
    out.push("DNA Style (H/A)     : " + vars.mOut.homeDNA.style + " / " + vars.mOut.awayDNA.style);
    out.push("ChronoSim Avg Goals : " + vars.mOut.chrono.avgGoals.toFixed(2));
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("CORE PROBABILITIES (1X2)");
    out.push("------------------------------------------------------------");
    out.push("Home Win : " + (vars.pH*100).toFixed(1) + "%");
    out.push("Draw     : " + (vars.pD*100).toFixed(1) + "%");
    out.push("Away Win : " + (vars.pA*100).toFixed(1) + "%");
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("OVER / UNDER");
    out.push("------------------------------------------------------------");
    for(const k of Object.keys(vars.ouBlend)){
      out.push("O/U " + k + " → Over " + (vars.ouBlend[k].over*100).toFixed(1) + "% | Under " + (vars.ouBlend[k].under*100).toFixed(1) + "%");
    }
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("BTTS & GOAL METRICS");
    out.push("------------------------------------------------------------");
    out.push("BTTS Probability : " + (vars.btts*100).toFixed(1) + "%");
    out.push("Avg Goals (MC)   : " + vars.mc.avgGoals.toFixed(2));
    out.push("Goal Swing Index : " + vars.swingVal.toFixed(2));
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("TOP SCORELINES (SPS + RC)");
    out.push("------------------------------------------------------------");
    vars.top3.forEach(s => out.push(" • " + s.score + " (" + s.prob + "%)"));
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("MATCH DYNAMICS");
    out.push("------------------------------------------------------------");
    out.push("Transition Battle : " + (vars.mOut.transition.scoreHome > vars.mOut.transition.scoreAway ? "HOME advantage":"AWAY advantage"));
    out.push("Surge Potential   : " + vars.surgeText);
    out.push("Collapse Risk     : " + vars.collapseText);
    out.push("Game Flow Rating  : " + vars.flowVal.toFixed(2));
    out.push("Phase Bias        : " + vars.phaseBias);
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("RECOMMENDATIONS (FULL)");
    out.push("------------------------------------------------------------");
    out.push("HDP Recommendation : " + vars.hdp.rec + " (Conf " + vars.hdp.conf.toFixed(1) + "%)");
    out.push("O/U Recommendation : " + vars.ouRec.pick + " (Conf " + vars.ouRec.conf.toFixed(1) + "%)");
    out.push("BTTS Recommendation: " + vars.bttsR.pick + " (Conf " + vars.bttsR.conf.toFixed(1) + "%)");
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("MARKET SUITABILITY");
    out.push("------------------------------------------------------------");
    if(vars.riskR.level === "SAFE"){
      out.push("Best Markets : Handicap, Over/Under, BTTS");
    } else if(vars.riskR.level === "BALANCED"){
      out.push("Best Markets : Over/Under, BTTS");
      out.push("Avoid       : Heavy handicap lines");
    } else {
      out.push("Best Markets : Over, BTTS");
      out.push("Avoid       : 1X2 & HDP (high chaos)");
    }
    out.push("");
    out.push("------------------------------------------------------------");
    out.push("FINAL NOTES");
    out.push("------------------------------------------------------------");
    out.push("• All active modules integrated.");
    out.push("• Output stabilized using SPS + Anti-Noise.");
    out.push("• Confidence Vector used as reliability gauge.");
    out.push("");
    return out.join("\n");
  }
/* ============================
     runPrimeZeroIntegrated (final)
     ============================ */
  function runPrimeZeroIntegrated(){
    try{
      const outEl = document.getElementById('output'); if(!outEl) return;
      outEl.value = "Running analysis...";
      // build ctx
      const ctx = buildContextFromUI();
      // apply module toggles
      V20.Master.flags.ENABLE_DLA = document.getElementById('flag_dla').checked;
      V20.Master.flags.ENABLE_GSM = document.getElementById('flag_gsm').checked;
      V20.Master.flags.ENABLE_TEM = document.getElementById('flag_tem').checked;
      V20.Master.flags.ENABLE_xT = document.getElementById('flag_xt').checked;
      V20.Master.flags.ENABLE_FMA2 = document.getElementById('flag_fma2').checked;
      V20.Master.flags.ENABLE_CHRONOSIM = document.getElementById('flag_chrono').checked;
      V20.Master.flags.ENABLE_SELFCAL = document.getElementById('flag_selfcal').checked;
      V20.Master.flags.ENABLE_RC = document.getElementById('flag_rc').checked;

      // HYBRID PRO compute & apply
      const hybrid = V20.AutoHybrid.computeAll({
        xg_home: ctx.xg_home, xg_away: ctx.xg_away,
        shots_home: ctx.shots_home, shots_away: ctx.shots_away,
        possession_home: ctx.possession_home, possession_away: ctx.possession_away,
        formPts_home: ctx.formPts_home, formPts_away: ctx.formPts_away,
        conceded_last5_home: ctx.conceded_last5_home, conceded_last5_away: ctx.conceded_last5_away,
        ppda_home: ctx.ppda_home, ppda_away: ctx.ppda_away,
        injuries_home: 0, injuries_away: 0,
        squadDepth_home: ctx.squadDepth_home, squadDepth_away: ctx.squadDepth_away,
        manual_stab_home: Number(document.getElementById('home_st').value||NaN),
        manual_stab_away: Number(document.getElementById('away_st').value||NaN),
        manual_mom_home: Number(document.getElementById('home_mom').value||NaN),
        manual_mom_away: Number(document.getElementById('away_mom').value||NaN),
        manual_press_home: Number(document.getElementById('home_press').value||NaN),
        manual_press_away: Number(document.getElementById('away_press').value||NaN),
        manual_flex_home: Number(document.getElementById('home_flex').value||NaN),
        manual_flex_away: Number(document.getElementById('away_flex').value||NaN),
        manual_defline_home: Number(document.getElementById('defline_home').value||NaN),
        manual_defline_away: Number(document.getElementById('defline_away').value||NaN),
        manual_inj_home: Number(document.getElementById('injury_home').value||NaN),
        manual_inj_away: Number(document.getElementById('injury_away').value||NaN),
        manual_tempo: Number(document.getElementById('tempo').value||NaN),
        manual_chaos: Number(document.getElementById('chaos').value||NaN)
      });
      V20.AutoHybrid.applyChosenToUI(hybrid);

      // build master context using hybrid chosen
      const mctx = {
        lamH: ctx.lamH, lamA: ctx.lamA,
        tempo: hybrid.chosen.tempo || ctx.tempo,
        chaos: hybrid.chosen.chaos || ctx.chaos,
        importance: ctx.importance,
        home: {
          stability: hybrid.chosen.stability_home || ctx.home_st,
          momentum: hybrid.chosen.momentum_home || ctx.home_mom,
          defline: hybrid.chosen.defline_home || ctx.defline_home,
          xg: ctx.xg_home
        },
        away: {
          stability: hybrid.chosen.stability_away || ctx.away_st,
          momentum: hybrid.chosen.momentum_away || ctx.away_mom,
          defline: hybrid.chosen.defline_away || ctx.defline_away,
          xg: ctx.xg_away
        },
        ppda_home: hybrid.auto.ppda_home || ctx.ppda_home,
        ppda_away: hybrid.auto.ppda_away || ctx.ppda_away,
        fin_home: ctx.fin_home, fin_away: ctx.fin_away,
        xg_home: ctx.xg_home, xg_away: ctx.xg_away, scoreCap: ctx.scoreCap,
        homeFormation: ctx.homeFormation, awayFormation: ctx.awayFormation,
        homeEntries: ctx.shots_home, awayEntries: ctx.shots_away, homeXGEff: ctx.shotq_home, awayXGEff: ctx.shotq_away
      };

      const mOut = V20.Master.masterRun(mctx);
      if(!mOut){ outEl.value = "Master run failed"; return; }

      // detSim baseline
      const det = V20.detSim({lamH:ctx.lamH, lamA:ctx.lamA});
      // chaos adjusted det
      const chaosScale = 1 + ( (hybrid.chosen.chaos || ctx.chaos) -5)/25;
      const detChaos = V20.detSim({lamH:ctx.lamH*chaosScale, lamA:ctx.lamA*chaosScale});

      // monte carlo using adjusted lam
      const mc = V20.monteCarlo({lamH:mOut.adjustedLam.lamH, lamA:mOut.adjustedLam.lamA}, {tempo:hybrid.chosen.tempo || ctx.tempo, chaos:hybrid.chosen.chaos || ctx.chaos, importance:ctx.importance}, 2000, ctx.scoreCap);

      // fuse outputs
      const fused = V20.fuseOutputs(det, detChaos, mc, 0);
      const pH = fused.final.pH, pD = fused.final.pD, pA = fused.final.pA;

      // extras
      const godHL = {lamH:mOut.adjustedLam.lamH, lamA:mOut.adjustedLam.lamA};
      const unc = V20.computeUncertainty(pH,pD,pA);
      const btts = V20.computeBTTS(godHL);
      const flowVal = V20.computeFlow({tempo:hybrid.chosen.tempo || ctx.tempo, chaos:hybrid.chosen.chaos || ctx.chaos}, {stability:hybrid.chosen.stability_home, momentum:hybrid.chosen.momentum_home}, {stability:hybrid.chosen.stability_away, momentum:hybrid.chosen.momentum_away}, {home:{pressIntensity:hybrid.chosen.press_home}, away:{pressIntensity:hybrid.chosen.press_away}}, {control:0.25});
      const swingVal = V20.computeMomentumSwing({momentum:hybrid.chosen.momentum_home},{momentum:hybrid.chosen.momentum_away});
      const riskScore = V20.computeRisk({tempo:hybrid.chosen.tempo || ctx.tempo,chaos:hybrid.chosen.chaos || ctx.chaos,importance:ctx.importance}, {home:{pressIntensity:hybrid.chosen.press_home}, away:{pressIntensity:hybrid.chosen.press_away}});
      const fragHome = Math.max(0, (10 - (hybrid.chosen.stability_home || ctx.home_st))/10), fragAway = Math.max(0,(10 - (hybrid.chosen.stability_away || ctx.away_st))/10);
// OU lines
      const totalLamBase = mOut.adjustedLam.lamH + mOut.adjustedLam.lamA;
      let lamEff = totalLamBase * (1 + ((hybrid.chosen.chaos || ctx.chaos)-5)/5*0.10 + ((hybrid.chosen.tempo || ctx.tempo)-5)/5*0.05);
      lamEff = V20.clamp(lamEff,0.5,8);
      const lines = [0.5,1.5,2.5,3.5];
      const ou = {}; lines.forEach(line=>{
        const cut = Math.floor(line);
        let under=0;
        for(let k=0;k<=100;k++){
          const pmf = Math.exp(-lamEff)*Math.pow(lamEff,k)/ (function f(n){let r=1; for(let i=2;i<=n;i++) r*=i; return r;})(k);
          if(k<=cut) under += pmf;
        }
        ou[line] = {under:under, over:1-under};
      });

      // MonteCarlo OU from matrix
      const mat = mc.matrix; const cap = mc.scoreCap;
      const ouMC = {}; lines.forEach(line=>{
        const cut = Math.floor(line); let under=0, over=0;
        for(let h=0;h<=cap;h++){ for(let a=0;a<=cap;a++){ const freq = (mat[h]&&mat[h][a])?mat[h][a]:0; const sum=h+a; if(sum<=cut) under+=freq; else over+=freq; } }
        ouMC[line] = {under: under/mc.simCount, over: over/mc.simCount};
      });

      // blend
      const patternChaos = 0.2; const wMC = 0.4 + 0.4*Math.max(0,patternChaos);
      const wAN = 1 - wMC;
      const ouBlend = {}; lines.forEach(k=>{ ouBlend[k] = { over: ou[k].over*wAN + ouMC[k].over*wMC, under: ou[k].under*wAN + ouMC[k].under*wMC }; });

      // score matrix/sps/top3
      const scoreMat = det.mat;
      const sps = V20.Master.SPS.shapeScores(scoreMat);
      const top3raw = []; for(let h=0;h<scoreMat.length;h++){ for(let a=0;a<scoreMat[h].length;a++){ top3raw.push({score:h+"-"+a, prob:scoreMat[h][a]}); } }
      top3raw.sort((x,y)=>y.prob-x.prob); const top3 = top3raw.slice(0,3).map(s=>({score:s.score, prob:(s.prob*100).toFixed(1)}));

      // recommender outputs
      const hdpre = V20.Reco.HDP(pH,pD,pA,fragHome,fragAway,hybrid.chosen.momentum_home,hybrid.chosen.momentum_away, mOut.fma.fmaScore);
      const ourec = V20.Reco.OU(ouBlend, mc.avgGoals, hybrid.chosen.tempo || ctx.tempo, hybrid.chosen.chaos || ctx.chaos, mOut.transition.scoreHome);
      const bttsr = V20.Reco.BTTS(btts, mOut.xtHome, mOut.xtAway, ctx.fin_home, ctx.fin_away);
      const topScores = V20.Reco.Score(det.mat);
      const riskR = V20.Reco.Risk(Math.abs((hybrid.chosen.chaos||ctx.chaos)-5)/5 + Math.abs((hybrid.chosen.momentum_home||ctx.home_mom)-(hybrid.chosen.momentum_away||ctx.away_mom))/5, unc.score/100, fragHome, fragAway, hybrid.chosen.chaos||ctx.chaos);

      const surgeText = ((hybrid.chosen.tempo||ctx.tempo)>6 || (hybrid.chosen.momentum_home - hybrid.chosen.momentum_away) > 1) ? "High" : ((hybrid.chosen.tempo||ctx.tempo)>5?"Medium":"Low");
      const collapseText = (fragAway>0.5 && (hybrid.chosen.momentum_away||ctx.away_mom)<4) ? "Moderate" : "Low";
      const phaseBias = V20.Master.AMPE.phaseForMinute(0);

      const vars = {
        engineStatus: ((unc.score<40 && riskScore<0.6) ? "PRIME STABLE" : (riskScore>0.75 ? "PRIME CAUTION" : "PRIME NEUTRAL")),
        pcv: V20.Master.PCV.compute(unc.score/100, Math.abs((hybrid.chosen.stability_home||ctx.home_st)-(hybrid.chosen.stability_away||ctx.away_st)), Math.abs((hybrid.auto.ppda_home||ctx.ppda_home)-(hybrid.auto.ppda_away||ctx.ppda_away))),
        volatility: Math.abs((hybrid.chosen.chaos||ctx.chaos)-5)/5 + Math.abs(((hybrid.chosen.momentum_home||ctx.home_mom)-(hybrid.chosen.momentum_away||ctx.away_mom))/5),
        unc, riskR, lamH:ctx.lamH, lamA:ctx.lamA, tempo:hybrid.chosen.tempo||ctx.tempo, chaos:hybrid.chosen.chaos||ctx.chaos, importance:ctx.importance,
        home_st: hybrid.chosen.stability_home||ctx.home_st, home_mom: hybrid.chosen.momentum_home||ctx.home_mom,
        away_st: hybrid.chosen.stability_away||ctx.away_st, away_mom: hybrid.chosen.momentum_away||ctx.away_mom,
        ppda_home: hybrid.auto.ppda_home||ctx.ppda_home, ppda_away: hybrid.auto.ppda_away||ctx.ppda_away, fin_home: ctx.fin_home, fin_away: ctx.fin_away,
        defline_home: hybrid.chosen.defline_home||ctx.defline_home, defline_away: hybrid.chosen.defline_away||ctx.defline_away,
        mOut, pH, pD, pA, ouBlend, btts, mc, swingVal: swingVal, top3, surgeText, collapseText, flowVal, phaseBias,
        hdp: hdpre, ouRec: ourec, bttsR: bttsr, topScores, riskR, moraleH: V20.Master.Morale.compute(ctx.formPts_home, hybrid.chosen.momentum_home||ctx.home_mom, 0), moraleA: V20.Master.Morale.compute(ctx.formPts_away, hybrid.chosen.momentum_away||ctx.away_mom, 0)
      };

      const finalText = buildSuperOutput(vars);
      outEl.value = finalText;

      // self-cal record
      if(V20.Master.flags.ENABLE_SELFCAL) V20.Master.SelfCal.record({home:ctx.home_team,away:ctx.away_team}, (pH>pA?'H':(pA>pH?'A':'D')), {pH,pD,pA});

    }catch(e){
      const tgt = document.getElementById('output');
      if(tgt) tgt.value = "Error running analysis: "+(e.message||e);
      console.error(e);
    }
  }
/* ============================
     UI wiring
     ============================ */
  document.getElementById('btn_auto').addEventListener('click', function(){
    const ctx = buildContextFromUI();
    const hybrid = V20.AutoHybrid.computeAll({
      xg_home: ctx.xg_home, xg_away: ctx.xg_away,
      shots_home: ctx.shots_home, shots_away: ctx.shots_away,
      possession_home: ctx.possession_home, possession_away: ctx.possession_away,
      formPts_home: ctx.formPts_home, formPts_away: ctx.formPts_away,
      conceded_last5_home: ctx.conceded_last5_home, conceded_last5_away: ctx.conceded_last5_away,
      ppda_home: ctx.ppda_home, ppda_away: ctx.ppda_away,
      injuries_home: 0, injuries_away: 0, squadDepth_home: ctx.squadDepth_home, squadDepth_away: ctx.squadDepth_away,
      manual_stab_home: Number(document.getElementById('home_st').value||NaN),
      manual_stab_away: Number(document.getElementById('away_st').value||NaN),
      manual_mom_home: Number(document.getElementById('home_mom').value||NaN),
      manual_mom_away: Number(document.getElementById('away_mom').value||NaN),
      manual_press_home: Number(document.getElementById('home_press').value||NaN),
      manual_press_away: Number(document.getElementById('away_press').value||NaN),
      manual_flex_home: Number(document.getElementById('home_flex').value||NaN),
      manual_flex_away: Number(document.getElementById('away_flex').value||NaN),
      manual_defline_home: Number(document.getElementById('defline_home').value||NaN),
      manual_defline_away: Number(document.getElementById('defline_away').value||NaN),
      manual_inj_home: Number(document.getElementById('injury_home').value||NaN),
      manual_inj_away: Number(document.getElementById('injury_away').value||NaN),
      manual_tempo: Number(document.getElementById('tempo').value||NaN),
      manual_chaos: Number(document.getElementById('chaos').value||NaN)
    });
    V20.AutoHybrid.applyChosenToUI(hybrid);
    document.getElementById('status').textContent = "AutoHybrid applied ✔";
  });

  document.getElementById('btn_run').addEventListener('click', function(){ runPrimeZeroIntegrated(); });

  document.getElementById('btn_copy').addEventListener('click', function(){
    const t = document.getElementById('output'); t.select(); document.execCommand('copy'); document.getElementById('status').textContent = "Copied to clipboard";
  });

  document.getElementById('btn_save').addEventListener('click', function(){
    const blob = new Blob([document.getElementById('output').value], {type:'text/plain'}); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'psz_output.txt'; a.click(); URL.revokeObjectURL(url);
  });

  document.getElementById('btn_reset').addEventListener('click', function(){ location.reload(); });

  // init
  document.addEventListener('DOMContentLoaded', function(){ document.getElementById('output').value = "Ready. Press AUTO INPUT (FULL) then RUN INTEGRATED."; });
// ==========================
// RUN INTEGRATED (LEVEL 9) - Safe, complete, OU fix + MC blend
// Paste this block before the closing </script> tag
// ==========================
(function(){
  // safe util wrappers (use existing V20 if present)
  const _num = (v,d=0)=> (typeof v === 'number' && isFinite(v)) ? v : ( (v!==undefined && v!==null && !isNaN(Number(v))) ? Number(v) : d );
  const _clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

  // Try to find existing functions in V20; fallback minimal implementations
  const detSim = (window.V20 && V20.detSim) ? V20.detSim : function(lambda){ return { pH:0.45, pD:0.2, pA:0.35, mat:[], lamH:lambda.lamH, lamA:lambda.lamA }; };
  const monteCarlo = (window.V20 && V20.monteCarlo) ? V20.monteCarlo : function(lambda, ctx, simCount, scoreCap){ return { matrix:[], simCount:2000, pH:0.46, pD:0.19, pA:0.35, avgGoals: lambda.lamH+lambda.lamA, scoreCap: scoreCap||6 }; };
  const masterRun = (window.V20 && V20.Master && V20.Master.masterRun) ? V20.Master.masterRun : function(c){ return { adjustedLam: { lamH: c.lamH || 1.2, lamA: c.lamA || 1.0 }, transition:{scoreHome:0.5,scoreAway:0.5}, xtHome:1, xtAway:1, fma:{fmaScore:0}, chrono:{avgGoals:(c.lamH||1.2)+(c.lamA||1.0)}, homeDNA:{style:'possession'}, awayDNA:{style:'possession'} }; };
  const fuseOutputs = (window.V20 && V20.fuseOutputs) ? V20.fuseOutputs : function(d1,d2,mc,z){ const pH=(d1.pH+d2.pH+mc.pH)/3; const pD=(d1.pD+d2.pD+mc.pD)/3; const pA=(d1.pA+d2.pA+mc.pA)/3; const tot=pH+pD+pA||1; return { final:{ pH:pH/tot, pD:pD/tot, pA:pA/tot } }; };
  const computeUncertainty = (window.V20 && V20.computeUncertainty) ? V20.computeUncertainty : (pH,pD,pA)=>({score: Math.max(2,Math.min(90,(1-Math.max(pH,pD,pA))*100))});
  const computeBTTS = (window.V20 && V20.computeBTTS) ? V20.computeBTTS : (godHL)=> Math.min(0.95, 0.28 + ((godHL.lamH||1)+(godHL.lamA||1))*0.12);

  function buildContextFromUI_safe(){
    // mirror your UI inputs (non-destructive)
    const ctx = {};
    try{
      ctx.lamH = _num(document.getElementById('lamH')?.value,1.2);
      ctx.lamA = _num(document.getElementById('lamA')?.value,1.0);
      ctx.tempo = _num(document.getElementById('tempo')?.value,5);
      ctx.chaos = _num(document.getElementById('chaos')?.value,5);
      ctx.importance = _num(document.getElementById('importance')?.value,5);

      ctx.home_st = _num(document.getElementById('home_st')?.value,5);
      ctx.away_st = _num(document.getElementById('away_st')?.value,5);
      ctx.home_mom = _num(document.getElementById('home_mom')?.value,5);
      ctx.away_mom = _num(document.getElementById('away_mom')?.value,5);

      ctx.home_press = _num(document.getElementById('home_press')?.value,5);
      ctx.away_press = _num(document.getElementById('away_press')?.value,5);
      ctx.home_flex = _num(document.getElementById('home_flex')?.value,0.5);
      ctx.away_flex = _num(document.getElementById('away_flex')?.value,0.5);

      ctx.fin_home = _num(document.getElementById('finishing_quality_home')?.value,5);
      ctx.fin_away = _num(document.getElementById('finishing_quality_away')?.value,5);

      ctx.ppda_home = _num(document.getElementById('ppda_home')?.value,12);
      ctx.ppda_away = _num(document.getElementById('ppda_away')?.value,12);

      ctx.xg_home = _num(document.getElementById('xg_home')?.value, ctx.lamH);
      ctx.xg_away = _num(document.getElementById('xg_away')?.value, ctx.lamA);

      ctx.shots_home = _num(document.getElementById('shots_home')?.value,10);
      ctx.shots_away = _num(document.getElementById('shots_away')?.value,8);
      ctx.shotq_home = _num(document.getElementById('shotq_home')?.value,0.12);
      ctx.shotq_away = _num(document.getElementById('shotq_away')?.value,0.10);

      ctx.possession_home = _num(document.getElementById('pos_home')?.value,50);
      ctx.possession_away = _num(document.getElementById('pos_away')?.value,50);

      ctx.scoreCap = _num(document.getElementById('scoreCap')?.value,6);
      ctx.simCount = _num(document.getElementById('simCount')?.value,2000);
      ctx.homeFormation = document.getElementById('home_formation')?.value || '4-3-3';
      ctx.awayFormation = document.getElementById('away_formation')?.value || '4-4-2';
    }catch(e){ console.warn('buildContextFromUI_safe err',e); }
    return ctx;
  }

  function computeOUBlend(lamEff, mc, cap){
    // analytic OU using Poisson marginal (fast approximate)
    const lines = [0.5,1.5,2.5,3.5];
    const ou = {}; const maxK = Math.max(20, Math.ceil(lamEff*6));
    // precompute poisson pmf up to maxK
    const pmf = [];
    for(let k=0;k<=maxK;k++){
      // factorial safe
      let fact=1; for(let i=2;i<=k;i++) fact*=i;
      pmf[k] = Math.exp(-lamEff)*Math.pow(lamEff,k)/Math.max(1,fact);
    }
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under=0;
      for(let k=0;k<=maxK;k++) if(k<=cut) under += pmf[k];
      ou[line] = { under: _clamp(under,0,1), over: _clamp(1-under,0,1) };
    });
    // MC OU
    const ouMC = {};
    lines.forEach(line=>{
      const cut = Math.floor(line);
      let under=0, over=0;
      for(let h=0; h<=cap; h++){
        for(let a=0; a<=cap; a++){
          const freq = (mc.matrix && mc.matrix[h] && mc.matrix[h][a]) ? mc.matrix[h][a] : 0;
          if((h+a) <= cut) under += freq;
          else over += freq;
        }
      }
      ouMC[line] = { under: mc.simCount ? under/mc.simCount : 0, over: mc.simCount ? over/mc.simCount : 0 };
    });
    // blend analytic + MC with weight by patternChaos estimate (safe default)
    const patternChaos = 0.2; // safe default if missing
    const wMC = 0.40 + 0.40*Math.max(0, patternChaos);
    const wAN = 1 - wMC;
    const ouBlend = {};
    lines.forEach(k=>{
      const an = ou[k] || {under:0.5,over:0.5};
      const mcv = ouMC[k] || {under:0.5,over:0.5};
      ouBlend[k] = {
        over: an.over * wAN + mcv.over * wMC,
        under: an.under * wAN + mcv.under * wMC
      };
    });
    return {ouBlend,ou,ouMC};
  }

  // main run function (safe)
  function runIntegrated_safe(){
    const outEl = document.getElementById('output');
    if(!outEl){ console.warn('no output element'); return; }
    outEl.value = "Running integrated analysis (safe)...";

    try{
      const ctx = buildContextFromUI_safe();

      // run master adjustment (DLA etc.) if exists
      const mOut = masterRun({
        lamH: ctx.lamH, lamA: ctx.lamA,
        tempo: ctx.tempo, chaos: ctx.chaos, importance: ctx.importance,
        home: { stability: ctx.home_st, momentum: ctx.home_mom, xg: ctx.xg_home, defline: ctx.defline_home || 5 },
        away: { stability: ctx.away_st, momentum: ctx.away_mom, xg: ctx.xg_away, defline: ctx.defline_away || 5 },
        ppda_home: ctx.ppda_home, ppda_away: ctx.ppda_away, fin_home: ctx.fin_home, fin_away: ctx.fin_away,
        scoreCap: ctx.scoreCap
      });

      // baseline detSim
      const det = detSim({ lamH: ctx.lamH, lamA: ctx.lamA });
      // chaos adjusted det
      const chaosScale = 1 + ((ctx.chaos - 5)/25);
      const detChaos = detSim({ lamH: ctx.lamH * chaosScale, lamA: ctx.lamA * chaosScale });

      // montecarlo using adjusted lam
      const mc = monteCarlo({ lamH: mOut.adjustedLam.lamH, lamA: mOut.adjustedLam.lamA }, { tempo: ctx.tempo, chaos: ctx.chaos }, ctx.simCount, ctx.scoreCap);

      // fuse (simple average fuse if fuseOutputs exists)
      const fused = fuseOutputs(det, detChaos, mc, 0);
      const pH = fused.final.pH, pD = fused.final.pD, pA = fused.final.pA;

      // compute uncertainty, btts
      const unc = computeUncertainty(pH,pD,pA);
      const btts = computeBTTS(mOut.adjustedLam);

      // OU blend using total lamEff
      const totalLamBase = (mOut.adjustedLam.lamH || ctx.lamH) + (mOut.adjustedLam.lamA || ctx.lamA);
      let lamEff = totalLamBase;
      lamEff *= (1 + ((ctx.chaos - 5)/5)*0.10 + ((ctx.tempo - 5)/5)*0.05);
      lamEff = _clamp(lamEff, 0.3, 8);
      const ouObj = computeOUBlend(lamEff, mc, ctx.scoreCap);

      // top scorelines (from det.mat)
      const scoreMat = det.mat || [];
      const top3 = [];
      if(scoreMat && scoreMat.length){
        for(let h=0; h<scoreMat.length; h++){
          for(let a=0; a<scoreMat[h].length; a++){
            top3.push({score: h+'-'+a, prob: scoreMat[h][a]});
          }
        }
        top3.sort((x,y)=>y.prob - x.prob);
      }

      // Recommender simple (fallback)
      const hdpRec = (pH>pA && pH>pD) ? 'Home fav' : (pA>pH && pA>pD ? 'Away fav' : 'Market Draw');
      const ouRec = (ouObj.ouBlend && ouObj.ouBlend["2.5"]) ? (ouObj.ouBlend["2.5"].over > 0.55 ? 'Over 2.5' : (ouObj.ouBlend["2.5"].under > 0.55 ? 'Under 2.5' : 'No strong OU')) : 'No OU';
      const bttsRec = (btts >= 0.54) ? 'YES' : 'NO';

      // engine status
      const engineStatus = (unc.score < 40 && Math.max(pH,pD,pA) > 0.45) ? 'PRIME STABLE' : 'PRIME NEUTRAL';

      // build output
      const lines = [];
      lines.push("=== RUN INTEGRATED (SAFE) ===");
      lines.push("[ENGINE STATUS] " + engineStatus);
      lines.push("");
      lines.push("[INPUT]");
      lines.push("λH: " + ctx.lamH + " | λA: " + ctx.lamA);
      lines.push("Tempo/Chaos/Importance: " + ctx.tempo + " / " + ctx.chaos + " / " + ctx.importance);
      lines.push("Home St/Mom: " + ctx.home_st + " / " + ctx.home_mom);
      lines.push("Away St/Mom: " + ctx.away_st + " / " + ctx.away_mom);
      lines.push("PPDA H/A: " + ctx.ppda_home + " / " + ctx.ppda_away);
      lines.push("");
      lines.push("[PROBABILITIES]");
      lines.push("Home Win : " + (pH*100).toFixed(1) + "%");
      lines.push("Draw     : " + (pD*100).toFixed(1) + "%");
      lines.push("Away Win : " + (pA*100).toFixed(1) + "%");
      lines.push("");
      lines.push("[UNCERTAINTY / BTTS]");
      lines.push("Uncertainty: " + (unc.score).toFixed(1) + "%");
      lines.push("BTTS: " + (btts*100).toFixed(1) + "%");
      lines.push("");
      lines.push("[OVER/UNDER BLEND]");
      Object.keys(ouObj.ouBlend).forEach(k=>{
        const v = ouObj.ouBlend[k];
        lines.push("O/U " + k + " → Over " + (v.over*100).toFixed(1) + "% | Under " + (v.under*100).toFixed(1) + "%");
      });
      lines.push("");
      lines.push("[RECOMMENDATIONS]");
      lines.push("HDP : " + hdpRec);
      lines.push("OU  : " + ouRec);
      lines.push("BTTS: " + bttsRec);
      lines.push("");
      lines.push("[TOP SCORELINES]");
      top3.slice(0,3).forEach(s=> lines.push(" • " + s.score + " (" + (s.prob*100||0).toFixed(1) + "%)"));

      outEl.value = lines.join("\n");

      // update UI bars if exist
      try{
        const pHfill = document.getElementById('pH_fill'); if(pHfill) pHfill.style.width = Math.round(pH*100)+'%';
        const pDfill = document.getElementById('pD_fill'); if(pDfill) pDfill.style.width = Math.round(pD*100)+'%';
        const pAfill = document.getElementById('pA_fill'); if(pAfill) pAfill.style.width = Math.round(pA*100)+'%';
      }catch(e){/*nonfatal*/}

    }catch(err){
      outEl.value = "ERROR running integrated: " + (err && err.message ? err.message : String(err));
      console.error("runIntegrated_safe error:", err);
    }
  }

  // wire to existing buttons safely
  const btnAnalyze = document.getElementById('btn_analyze') || document.getElementById('btn_run') || document.getElementById('btn_run_integrated');
  if(btnAnalyze){
    btnAnalyze.removeEventListener && btnAnalyze.removeEventListener('click', runIntegrated_safe);
    btnAnalyze.addEventListener('click', runIntegrated_safe);
  } else {
    console.warn('RUN button not found; create manual trigger: runIntegrated_safe()');
  }

  // add global alias
  window.runIntegrated_safe = runIntegrated_safe;

})(); // end IIFE
  </script>
</body>
</html>

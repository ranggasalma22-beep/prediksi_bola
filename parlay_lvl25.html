<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>PARLAY — LEVEL 25 REBUILD (PART 1/8)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#04121a; --panel:#071826; --card:#072330; --accent:#00f0d8; --muted:#9fbfc6; --text:#e9fbf7;
      --glass: rgba(255,255,255,0.03);
      --mono: "Courier New", Courier, monospace;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,var(--bg),#021018);color:var(--text);padding:12px;}
    .container{display:flex;gap:12px;align-items:flex-start;}
    .panel{background:linear-gradient(180deg,var(--panel),#061826);border-radius:12px;padding:12px;width:380px;max-height:92vh;overflow:auto;box-shadow:0 10px 30px rgba(0,0,0,0.6);}
    .main{flex:1;display:flex;flex-direction:column;gap:12px;max-height:92vh;}
    h1{margin:0;font-size:16px;color:var(--accent)}
    .section{background:var(--card);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);margin-bottom:10px;}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}
    input[type="text"], input[type="number"], select, textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:var(--text);}
    textarea{min-height:140px;font-family:var(--mono);font-size:13px;resize:vertical;}
    .row{display:flex;gap:8px;}
    .col{display:flex;flex-direction:column;gap:8px;}
    button{background:var(--accent);color:#042827;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
    button.alt{background:transparent;color:var(--accent);border:1px solid rgba(0,240,216,0.10)}
    .muted{color:var(--muted);font-size:12px}
    .tag{display:inline-block;padding:4px 8px;border-radius:999px;background:var(--glass);font-size:12px;color:var(--muted);}
    .kbd{background:#042b2c;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-family:var(--mono);font-size:12px}
    @media (max-width:900px){ .panel{width:340px} }
    @media (max-width:700px){ .container{flex-direction:column} .panel{width:auto} .main{max-height:none} }
  </style>
</head>
<body>
  <div class="container">
    <!-- PANEL LEFT: Inputs -->
    <div class="panel" id="leftPanel">
      <h1>PARLAY — LEVEL 25 REBUILD</h1>
      <div class="muted" style="margin:6px 0 12px 0">UI3 · Engine:E5 (Omega+) · Output:O5 (GOD ULTRA)</div>

      <div class="section">
        <label>Match ID</label>
        <input id="match_id" type="text" value="M_REBLD_0001">
        <div class="row">
          <div style="flex:1"><label>Home Team</label><input id="home_team" type="text" value="Home FC"></div>
          <div style="flex:1"><label>Away Team</label><input id="away_team" type="text" value="Away FC"></div>
        </div>
        <label>Match Type</label>
        <select id="match_type">
          <option value="league">League</option>
          <option value="cup">Domestic Cup</option>
          <option value="ucl">UEFA Champions League</option>
          <option value="uel">UEFA Europa League</option>
          <option value="uecl">UEFA Conference League</option>
          <option value="supercup">Super Cup</option>
          <option value="playoff">Playoff/Relegation</option>
          <option value="intl">International</option>
          <option value="friendly">Friendly</option>
        </select>
      </div>

      <div class="section">
        <h3 class="muted">SOURCE DATA (isi jika tersedia — SMART AUTO TIDAK MENG-OVERRIDE)</h3>
        <label>λH (xG Home)</label><input id="lamH" type="number" step="0.01" placeholder="leave blank for auto">
        <label>λA (xG Away)</label><input id="lamA" type="number" step="0.01" placeholder="leave blank for auto">

        <div class="row">
          <div style="flex:1"><label>Shots Home</label><input id="shots_home" type="number"></div>
          <div style="flex:1"><label>Shots Away</label><input id="shots_away" type="number"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>SOT Home</label><input id="sot_home" type="number"></div>
          <div style="flex:1"><label>SOT Away</label><input id="sot_away" type="number"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Possession Home (%)</label><input id="pos_home" type="number"></div>
          <div style="flex:1"><label>Possession Away (%)</label><input id="pos_away" type="number"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>FormPts Home (last5)</label><input id="formPts_home" type="number"></div>
          <div style="flex:1"><label>FormPts Away (last5)</label><input id="formPts_away" type="number"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Scored last5 Home</label><input id="scored_last5_home" type="number"></div>
          <div style="flex:1"><label>Scored last5 Away</label><input id="scored_last5_away" type="number"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Conceded last5 Home</label><input id="conceded_last5_home" type="number"></div>
          <div style="flex:1"><label>Conceded last5 Away</label><input id="conceded_last5_away" type="number"></div>
        </div>
      </div>

      <div class="section">
        <h3 class="muted">TACTICAL / DERIVED (SMART AUTO mengisi bila kosong)</h3>

        <div class="row">
          <div style="flex:1"><label>Home Formation</label><input id="homeFormation" type="text" value="4-3-3"></div>
          <div style="flex:1"><label>Away Formation</label><input id="awayFormation" type="text" value="4-4-2"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Stability Home (1-10)</label><input id="home_st" type="number" step="0.01"></div>
          <div style="flex:1"><label>Stability Away (1-10)</label><input id="away_st" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Momentum Home (1-10)</label><input id="home_mom" type="number" step="0.01"></div>
          <div style="flex:1"><label>Momentum Away (1-10)</label><input id="away_mom" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Press Intensity Home (1-10)</label><input id="home_press" type="number" step="0.01"></div>
          <div style="flex:1"><label>Press Intensity Away (1-10)</label><input id="away_press" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>PPDA Home</label><input id="ppda_home" type="number" step="0.01"></div>
          <div style="flex:1"><label>PPDA Away</label><input id="ppda_away" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Flex Home (0-1)</label><input id="home_flex" type="number" step="0.01"></div>
          <div style="flex:1"><label>Flex Away (0-1)</label><input id="away_flex" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Manager Aggression (0-10)</label><input id="manager_aggr" type="number" step="0.01"></div>
          <div style="flex:1"><label>Defensive Line (0-10)</label><input id="def_line" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Injury Impact Home (0-1)</label><input id="injury_impact_home" type="number" step="0.01"></div>
          <div style="flex:1"><label>Injury Impact Away (0-1)</label><input id="injury_impact_away" type="number" step="0.01"></div>
        </div>

        <div class="row">
          <div style="flex:1"><label>Transition Eff (0-1)</label><input id="transition_eff" type="number" step="0.01"></div>
          <div style="flex:1"><label>Chaos (1-10)</label><input id="chaos" type="number" step="0.01"></div>
        </div>

        <div class="row" style="margin-top:8px">
          <div style="flex:1">
            <label>Park the Bus / Anti-Attack (home)</label>
            <select id="park_home">
              <option value="none">None</option>
              <option value="park">Park the Bus</option>
              <option value="contain">Contain</option>
            </select>
          </div>
          <div style="flex:1">
            <label>Park the Bus / Anti-Attack (away)</label>
            <select id="park_away">
              <option value="none">None</option>
              <option value="park">Park the Bus</option>
              <option value="contain">Contain</option>
            </select>
          </div>
        </div>

        <div class="muted" style="margin-top:8px">SMART AUTO akan mengisi field kosong. Pilih "Park the Bus" untuk tim yang cenderung sangat defensif — ini menurunkan pressing, menurunkan xG, menaikkan defensive line conservativeness.</div>
      </div>

      <div class="section">
        <h3 class="muted">MARKET & SIMULATION</h3>
        <div class="row">
          <div style="flex:1"><label>Market Odds Home</label><input id="market_H" type="number" step="0.01"></div>
          <div style="flex:1"><label>Market Odds Draw</label><input id="market_D" type="number" step="0.01"></div>
        </div>
        <label>Market Odds Away</label><input id="market_A" type="number" step="0.01">

        <label style="margin-top:8px">Simulation Intensity (chunked, default 20000)</label>
        <input id="simIntensity" type="number" value="20000" step="1000">

        <div class="row" style="margin-top:8px">
          <button id="btn_auto_input" class="mini">AUTO INPUT (SMART)</button>
          <button id="btn_run_core" class="mini">RUN CORE (FAST)</button>
          <button id="btn_run_minute" class="mini">RUN MINUTE SIM</button>
        </div>
      </div>

    </div>

    <!-- MAIN RIGHT: Output & Logs -->
    <div class="main">
      <div class="section" style="flex:1;background:#001a19;">
        <label>OUTPUT / LOG</label>
        <textarea id="output" readonly style="width:100%;height:100%;font-family:var(--mono);">=== PARLAY LEVEL 25 REBUILD — READY ===
Paste PART 2 next.</textarea>
      </div>
    </div>
  </div>
<!-- =============================
     PART 2 — CORE UTILITIES
     Rebuild Level 25
     Must be loaded BEFORE Part 3
============================= -->
<script>
window.PSZ = window.PSZ || {};

/* ==========================================
   SAFE NUM + CLAMP
========================================== */
PSZ.safeNum = function(v, def = 0){
  const n = parseFloat(v);
  return Number.isFinite(n) ? n : def;
};

PSZ.clamp = function(v, min, max){
  v = PSZ.safeNum(v, min);
  if(v < min) return min;
  if(v > max) return max;
  return v;
};

/* ==========================================
   RANDOM (Normal Distribution)
========================================== */
PSZ.randNorm = function(mean = 0, sd = 1){
  let u = Math.random(), v = Math.random();
  let z = Math.sqrt(-2*Math.log(u)) * Math.cos(2*Math.PI*v);
  return mean + z * sd;
};

/* ==========================================
   FAST LOG FACTORIAL (CACHE)
========================================== */
PSZ._logFactCache = {0:0,1:0};
PSZ._logFact = function(n){
  n = Math.max(0, Math.floor(n));
  if(PSZ._logFactCache[n] !== undefined)
    return PSZ._logFactCache[n];
  let s = 0;
  for(let i=2;i<=n;i++) s += Math.log(i);
  PSZ._logFactCache[n] = s;
  return s;
};

/* ==========================================
   POISSON FUNCTIONS
========================================== */
PSZ.poissonPMF = function(lambda, k){
  lambda = Math.max(0.000001, PSZ.safeNum(lambda, 1));
  k = Math.max(0, Math.floor(k));
  return Math.exp(-lambda + k*Math.log(lambda) - PSZ._logFact(k));
};

PSZ.poissonCDF = function(lambda, k){
  let sum = 0;
  for(let i=0;i<=k;i++) sum += PSZ.poissonPMF(lambda, i);
  return sum;
};

PSZ.poissonSample = function(lambda){
  lambda = Math.max(0.000001, lambda);
  const L = Math.exp(-lambda);
  let p = 1, k = 0;
  while(p > L){
    k++;
    p *= Math.random();
  }
  return k-1;
};

/* ==========================================
   DIXON–COLES (low-score correlation)
========================================== */
PSZ.dixonColes = function(lamH, lamA, rho = 0){
  rho = PSZ.clamp(rho, -0.3, 0.3);
  return function(h,a){
    if(h < 2 && a < 2){
      const adj =
          (h===0 && a===0)? -1 :
          (h===0 && a===1)?  1 :
          (h===1 && a===0)?  1 :
          (h===1 && a===1)? -1 : 0;
      return 1 + rho * adj;
    }
    return 1;
  };
};

/* ==========================================
   LOGISTIC MODEL
========================================== */
PSZ.logit = x => Math.log(PSZ.clamp(x,1e-12,1-1e-12) / (1 - PSZ.clamp(x,1e-12,1-1e-12)));
PSZ.sigmoid = x => 1 / (1 + Math.exp(-x));

/* ==========================================
   NORMALIZATION
========================================== */
PSZ.normalize3 = function(h,d,a){
  const s = h + d + a;
  if(s <= 0) return {h:1/3, d:1/3, a:1/3};
  return {h:h/s, d:d/s, a:a/s};
};

/* ==========================================
   WEIGHTED FUSION
========================================== */
PSZ.weighted3 = function(x1,x2,x3, w1,w2,w3){
  return (x1*w1 + x2*w2 + x3*w3) / (w1+w2+w3);
};

/* ==========================================
   VALUE / MARKET HELPERS
========================================== */
PSZ.fairOdds = function(p){
  p = PSZ.clamp(p, 0.00001, 0.99999);
  return 1/p;
};

PSZ.kelly = function(p, odds){
  const b = odds - 1;
  if(b <= 0) return 0;
  let f = (p*(b+1) - 1) / b;
  return PSZ.clamp(f, 0, 1);
};

/* ==========================================
   CHAOS + VOLATILITY HELPERS
========================================== */
PSZ.chaosField = function(chaos){
  chaos = PSZ.clamp(chaos,1,10);
  const amp = (chaos - 5)*0.06;
  return PSZ.randNorm(0, amp);
};

PSZ.volatilityIndex = function(scored5, conceded5){
  const diff = Math.abs(PSZ.safeNum(scored5,0) - PSZ.safeNum(conceded5,0));
  return PSZ.clamp(diff/6 + Math.random()*0.15, 0, 2.5);
};

/* ==========================================
   MASTER INIT STRUCTURE
   — used later by engine (Part 4–7)
========================================== */
PSZ.Master = PSZ.Master || {};

PSZ.Master.init = function(ctx){
  const lamH = PSZ.safeNum(ctx.lamH, 1.2);
  const lamA = PSZ.safeNum(ctx.lamA, 1.0);
  const chaos = PSZ.safeNum(ctx.chaos, 5);

  const noise = PSZ.chaosField(chaos);

  return {
    lamH_adj: PSZ.clamp(lamH * (1 + noise), 0.1, 8),
    lamA_adj: PSZ.clamp(lamA * (1 + noise), 0.1, 8),
    chaosAdj: noise,
    volatility: PSZ.volatilityIndex(
      PSZ.safeNum(ctx.scored_last5_home,0),
      PSZ.safeNum(ctx.conceded_last5_home,0)
    )
  };
};

console.log("PART 2 — CORE UTILITIES LOADED (LEVEL 25 REBUILD)");
</script>
<!-- =========================
     PART 3 — AUTO INPUT SUPER ENGINE (SMART MODE)
     — MatchPreset, autoPPDA (pressing-based), inference functions
     — Park the Bus / Contain support
========================= -->
<script>
(function(PSZ){
  PSZ.AutoInput = PSZ.AutoInput || {};

  /* -----------------------
     Match Type Presets
     ----------------------- */
  PSZ.MatchPreset = {
    league: { tempo:5, chaos:5, importance:5, pressBoost:0, xgMultiplier:1.00, volatility:1.0 },
    cup:    { tempo:5.5, chaos:6, importance:7, pressBoost:0.25, xgMultiplier:1.05, volatility:1.1 },
    ucl:    { tempo:6, chaos:6, importance:9, pressBoost:0.5, xgMultiplier:1.12, volatility:1.25 },
    uel:    { tempo:5.5, chaos:5.8, importance:8, pressBoost:0.35, xgMultiplier:1.07, volatility:1.15 },
    uecl:   { tempo:5.3, chaos:6.2, importance:7, pressBoost:0.25, xgMultiplier:1.04, volatility:1.12 },
    supercup:{tempo:5, chaos:6, importance:6, pressBoost:0.2, xgMultiplier:1.03, volatility:1.08 },
    playoff:{ tempo:4.5, chaos:7, importance:10, pressBoost:-0.4, xgMultiplier:0.90, volatility:1.4 },
    intl:   { tempo:4.7, chaos:7.5, importance:9, pressBoost:-0.5, xgMultiplier:0.88, volatility:1.5 },
    friendly:{tempo:5.5, chaos:7.5, importance:2, pressBoost:0, xgMultiplier:1.10, volatility:1.2 }
  };

  PSZ.MatchPreset.apply = function(k){ return PSZ.MatchPreset[k] || PSZ.MatchPreset.league; };

  /* -----------------------
     autoPPDA (pressing style inference)
     - respects manual PPDA when provided
     - else infers from press intensity, tempo, formation, shots
     - returns {ppdaH, ppdaA, source}
  ----------------------- */
  PSZ.Master = PSZ.Master || {};
  PSZ.Master.autoPPDA = function(ctx){
    ctx = ctx || {};
    const manualH = PSZ.safeNum(ctx.ppda_home, 0);
    const manualA = PSZ.safeNum(ctx.ppda_away, 0);
    if(manualH > 0 && manualA > 0) return { ppdaH: manualH, ppdaA: manualA, source: "manual" };

    const pressH = PSZ.safeNum(ctx.home_press, PSZ.safeNum(ctx.press_home, 5));
    const pressA = PSZ.safeNum(ctx.away_press, PSZ.safeNum(ctx.press_away, 5));
    const tempo  = PSZ.safeNum(ctx.tempo, 5);
    const hf = (ctx.homeFormation||"").toLowerCase();
    const af = (ctx.awayFormation||"").toLowerCase();
    const shotsH = PSZ.safeNum(ctx.shots_home, 8);
    const shotsA = PSZ.safeNum(ctx.shots_away, 7);
    const parkH = (ctx.park_home === "park");
    const parkA = (ctx.park_away === "park");
    const containH = (ctx.park_home === "contain");
    const containA = (ctx.park_away === "contain");

    let base = 18;

    // pressing score: higher press intensity -> lower PPDA (more aggressive)
    let pressScoreH = (pressH - 5) * 1.35 + (tempo - 5) * 0.35 + ((shotsH - 8) / 6);
    let pressScoreA = (pressA - 5) * 1.35 + (tempo - 5) * 0.35 + ((shotsA - 7) / 6);

    // formation bias
    const formBiasH = (hf.includes("3-4-3")||hf.includes("4-3-3")||hf.includes("3-5-2")) ? -1.0 : 0;
    const formBiasA = (af.includes("3-4-3")||af.includes("4-3-3")||af.includes("3-5-2")) ? -1.0 : 0;

    // park the bus reduces pressing effect drastically -> higher PPDA (less pressing)
    if(parkH) pressScoreH -= 3.2; // very negative score -> increases returned ppda
    if(parkA) pressScoreA -= 3.2;
    if(containH) pressScoreH -= 1.5;
    if(containA) pressScoreA -= 1.5;

    let ppdaH = base - pressScoreH + formBiasH;
    let ppdaA = base - pressScoreA + formBiasA;

    ppdaH = PSZ.clamp(Math.round(ppdaH * 100) / 100, 4, 60);
    ppdaA = PSZ.clamp(Math.round(ppdaA * 100) / 100, 4, 60);

    // keep ratios realistic
    const ratio = ppdaA / (ppdaH || 1);
    if(ratio > 4) ppdaA = PSZ.clamp(ppdaH * 2.5, 4, 60);
    if(ratio < 0.25) ppdaH = PSZ.clamp(ppdaA * 2.5, 4, 60);

    return { ppdaH, ppdaA, source: "inferred_pressing" };
  };

  /* -----------------------
     Inference helpers — all produce safe bounded values
  ----------------------- */

  PSZ.AutoInput.inferStability = function(opts){
    opts = opts || {};
    const conceded = PSZ.safeNum(opts.conceded_last5, 3);
    const form = PSZ.safeNum(opts.formPts, 6);
    const inj = PSZ.safeNum(opts.injuryImpact, 0);
    let base = 5 + ((6 - conceded) * 0.25) + ((form - 5) * 0.35) - (inj * 3);
    // park bus increases perceived stability (defensive)
    if(opts.park === "park") base += 0.8;
    return PSZ.clamp(base, 1, 10);
  };

  PSZ.AutoInput.inferMomentum = function(opts){
    opts = opts || {};
    const form = PSZ.safeNum(opts.formPts, 6);
    const lam = PSZ.safeNum(opts.lam, 1.1);
    const scored = PSZ.safeNum(opts.scored_last5, 3);
    let base = 5 + (form - 5) * 0.55 + (lam - 1) * 1.5 + ((scored - 3) * 0.3);
    if(opts.park === "park") base -= 1.1; // park bus reduces attacking momentum
    return PSZ.clamp(base, 1, 10);
  };

  PSZ.AutoInput.inferPress = function(opts){
    opts = opts || {};
    const st = PSZ.safeNum(opts.st, 5);
    const tempo = PSZ.safeNum(opts.tempo, 5);
    const shots = PSZ.safeNum(opts.shots, 8);
    const mg = PSZ.safeNum(opts.manager_aggr, 5);
    let base = 4.5 + ((10 - st) * 0.12) + ((tempo - 5) * 0.45) + ((shots - 8) * 0.08) + ((mg - 5) * 0.15);
    if(opts.park === "park") base = PSZ.clamp(base - 3.0, 1, 10);
    if(opts.park === "contain") base = PSZ.clamp(base - 1.3, 1, 10);
    return PSZ.clamp(base, 1, 10);
  };

  PSZ.AutoInput.inferFlex = function(opts){
    opts = opts || {};
    const formation = (opts.formation || "").toLowerCase();
    const tempo = PSZ.safeNum(opts.tempo, 5);
    let base = 0.45 + (tempo - 5) * 0.04 + ((formation.includes("3-4-3")||formation.includes("4-3-3"))?0.08:0);
    if(opts.park === "park") base = PSZ.clamp(base - 0.22, 0.05, 0.95);
    return PSZ.clamp(base, 0.05, 0.95);
  };

  PSZ.AutoInput.inferManagerAggression = function(opts){
    opts = opts || {};
    const tempo = PSZ.safeNum(opts.tempo,5);
    const press = PSZ.safeNum(opts.press,5);
    const formation = (opts.formation||"").toLowerCase();
    let base = 5 + (tempo - 5) * 0.6 + (press - 5) * 0.55;
    if(formation.includes("5-") || opts.park === "park") base -= 1.5;
    return PSZ.clamp(base, 0, 10);
  };

  PSZ.AutoInput.inferDefLine = function(opts){
    opts = opts || {};
    const press = PSZ.safeNum(opts.press,5);
    const mg = PSZ.safeNum(opts.manager_aggr,5);
    let base = 4 + (press - 5) * 0.55 + (mg - 5) * 0.4;
    if(opts.park === "park") base = PSZ.clamp(base - 2.5, 0, 10);
    return PSZ.clamp(base, 0, 10);
  };

  PSZ.AutoInput.inferInjuryImpact = function(opts){
    opts = opts || {};
    const explicit = PSZ.safeNum(opts.explicit, 0);
    if(explicit > 0) return PSZ.clamp(explicit, 0, 0.9);
    const conceded = PSZ.safeNum(opts.conceded_last5, 3);
    if(conceded > 6) return 0.22;
    if(conceded > 4) return 0.12;
    if(conceded > 2) return 0.05;
    return 0.02;
  };

  PSZ.AutoInput.inferTransition = function(opts){
    opts = opts || {};
    const pos = PSZ.safeNum(opts.pos, 50);
    const shots = PSZ.safeNum(opts.shots, 8);
    const ratio = Math.max(0.05, shots / Math.max(1, pos));
    let base = 0.45 + (ratio - 0.12) * 1.2;
    if(opts.park === "park") base = PSZ.clamp(base - 0.12, 0.02, 0.95);
    return PSZ.clamp(base, 0.02, 0.95);
  };

  PSZ.AutoInput.inferChaos = function(ctx, preset){
    // prefer explicit chaos if set
    const userChaos = PSZ.safeNum(ctx.chaos, 0);
    if(userChaos > 0) return PSZ.clamp(userChaos, 1, 10);
    const vol = PSZ.safeNum(preset && preset.volatility, 1.0);
    const scoredDiff = Math.abs( PSZ.safeNum(ctx.scored_last5_home,0) - PSZ.safeNum(ctx.conceded_last5_home,0) );
    const base = 5 + (vol - 1) * 1.3 + (scoredDiff * 0.25) + (PSZ.randNorm(0,0.25));
    return PSZ.clamp(base, 1, 10);
  };

  /* -----------------------
     Main: smartFillFromDOM
     - does NOT override manual source fields (lam/shot/pos/form/etc)
     - fills derived fields only when empty
  ----------------------- */
  PSZ.AutoInput.smartFillFromDOM = function(ctxOverride){
    try{
      function el(id){ return document.getElementById(id); }
      const match_type = (el("match_type") && el("match_type").value) || "league";
      const preset = PSZ.MatchPreset.apply(match_type);

      // read source fields (do not override when not empty)
      const dom = {
        match_type,
        lamH: PSZ.safeNum(el("lamH")?.value, 0),
        lamA: PSZ.safeNum(el("lamA")?.value, 0),
        shots_home: PSZ.safeNum(el("shots_home")?.value, NaN),
        shots_away: PSZ.safeNum(el("shots_away")?.value, NaN),
        sot_home: PSZ.safeNum(el("sot_home")?.value, NaN),
        sot_away: PSZ.safeNum(el("sot_away")?.value, NaN),
        pos_home: PSZ.safeNum(el("pos_home")?.value, NaN),
        pos_away: PSZ.safeNum(el("pos_away")?.value, NaN),
        formPts_home: PSZ.safeNum(el("formPts_home")?.value, NaN),
        formPts_away: PSZ.safeNum(el("formPts_away")?.value, NaN),
        scored_last5_home: PSZ.safeNum(el("scored_last5_home")?.value, NaN),
        scored_last5_away: PSZ.safeNum(el("scored_last5_away")?.value, NaN),
        conceded_last5_home: PSZ.safeNum(el("conceded_last5_home")?.value, NaN),
        conceded_last5_away: PSZ.safeNum(el("conceded_last5_away")?.value, NaN),
        home_st: PSZ.safeNum(el("home_st")?.value, 0),
        away_st: PSZ.safeNum(el("away_st")?.value, 0),
        home_mom: PSZ.safeNum(el("home_mom")?.value, 0),
        away_mom: PSZ.safeNum(el("away_mom")?.value, 0),
        home_press: PSZ.safeNum(el("home_press")?.value, 0),
        away_press: PSZ.safeNum(el("away_press")?.value, 0),
        ppda_home: PSZ.safeNum(el("ppda_home")?.value, 0),
        ppda_away: PSZ.safeNum(el("ppda_away")?.value, 0),
        home_flex: PSZ.safeNum(el("home_flex")?.value, 0),
        away_flex: PSZ.safeNum(el("away_flex")?.value, 0),
        manager_aggr: PSZ.safeNum(el("manager_aggr")?.value, NaN),
        def_line: PSZ.safeNum(el("def_line")?.value, NaN),
        injury_impact_home: PSZ.safeNum(el("injury_impact_home")?.value, NaN),
        injury_impact_away: PSZ.safeNum(el("injury_impact_away")?.value, NaN),
        transition_eff: PSZ.safeNum(el("transition_eff")?.value, NaN),
        chaos: PSZ.safeNum(el("chaos")?.value, 0),
        tempo: PSZ.safeNum(el("tempo")?.value, 0),
        importance: PSZ.safeNum(el("importance")?.value, 0),
        homeFormation: el("homeFormation")?.value || "",
        awayFormation: el("awayFormation")?.value || "",
        park_home: el("park_home")?.value || "none",
        park_away: el("park_away")?.value || "none"
      };

      // apply overrides
      const ctx = Object.assign({}, dom, ctxOverride || {});

      // Apply preset defaults for tempo/chaos/importance ONLY if empty (SMART MODE)
      if(!PSZ.safeNum(ctx.tempo,0)) ctx.tempo = preset.tempo;
      if(!PSZ.safeNum(ctx.chaos,0)) ctx.chaos = preset.chaos;
      if(!PSZ.safeNum(ctx.importance,0)) ctx.importance = preset.importance;

      // xG multiplier: only apply if lam not provided
      let lamH = PSZ.safeNum(ctx.lamH, 0);
      let lamA = PSZ.safeNum(ctx.lamA, 0);
      if(lamH <= 0) lamH = 1.2 * preset.xgMultiplier;
      if(lamA <= 0) lamA = 1.0 * preset.xgMultiplier;

      // Park the Bus adjustments to lam & press
      if(ctx.park_home === "park"){
        lamH = lamH * 0.75; // park reduces scoring expectation
        ctx.home_press = PSZ.clamp(PSZ.safeNum(ctx.home_press,5) - 2.2, 1, 10);
        ctx.home_flex = PSZ.clamp(PSZ.safeNum(ctx.home_flex,0.5) - 0.25, 0.05, 0.95);
      }
      if(ctx.park_away === "park"){
        lamA = lamA * 0.75;
        ctx.away_press = PSZ.clamp(PSZ.safeNum(ctx.away_press,5) - 2.2, 1, 10);
        ctx.away_flex = PSZ.clamp(PSZ.safeNum(ctx.away_flex,0.5) - 0.25, 0.05, 0.95);
      }
      // contain less extreme
      if(ctx.park_home === "contain"){
        lamH = lamH * 0.88;
        ctx.home_press = PSZ.clamp(PSZ.safeNum(ctx.home_press,5) - 1.1, 1, 10);
      }
      if(ctx.park_away === "contain"){
        lamA = lamA * 0.88;
        ctx.away_press = PSZ.clamp(PSZ.safeNum(ctx.away_press,5) - 1.1, 1, 10);
      }

      // Fill Stability
      if(!(PSZ.safeNum(ctx.home_st,0) > 0)){
        const s = PSZ.AutoInput.inferStability({ conceded_last5: PSZ.safeNum(ctx.conceded_last5_home, NaN), formPts: PSZ.safeNum(ctx.formPts_home, NaN), injuryImpact: PSZ.safeNum(ctx.injury_impact_home,0), park: ctx.park_home });
        el("home_st").value = s.toFixed(2);
        ctx.home_st = s;
      }
      if(!(PSZ.safeNum(ctx.away_st,0) > 0)){
        const s = PSZ.AutoInput.inferStability({ conceded_last5: PSZ.safeNum(ctx.conceded_last5_away, NaN), formPts: PSZ.safeNum(ctx.formPts_away, NaN), injuryImpact: PSZ.safeNum(ctx.injury_impact_away,0), park: ctx.park_away });
        el("away_st").value = s.toFixed(2);
        ctx.away_st = s;
      }

      // Fill Momentum
      if(!(PSZ.safeNum(ctx.home_mom,0) > 0)){
        const m = PSZ.AutoInput.inferMomentum({ formPts: PSZ.safeNum(ctx.formPts_home, NaN), lam: lamH, scored_last5: PSZ.safeNum(ctx.scored_last5_home, NaN), park: ctx.park_home });
        el("home_mom").value = m.toFixed(2);
        ctx.home_mom = m;
      }
      if(!(PSZ.safeNum(ctx.away_mom,0) > 0)){
        const m = PSZ.AutoInput.inferMomentum({ formPts: PSZ.safeNum(ctx.formPts_away, NaN), lam: lamA, scored_last5: PSZ.safeNum(ctx.scored_last5_away, NaN), park: ctx.park_away });
        el("away_mom").value = m.toFixed(2);
        ctx.away_mom = m;
      }

      // Fill Press
      if(!(PSZ.safeNum(ctx.home_press,0) > 0)){
        const p = PSZ.AutoInput.inferPress({ st: PSZ.safeNum(ctx.home_st,5), tempo: ctx.tempo, shots: PSZ.safeNum(ctx.shots_home, NaN), manager_aggr: PSZ.safeNum(ctx.manager_aggr, NaN), park: ctx.park_home });
        el("home_press").value = p.toFixed(2);
        ctx.home_press = p;
      }
      if(!(PSZ.safeNum(ctx.away_press,0) > 0)){
        const p = PSZ.AutoInput.inferPress({ st: PSZ.safeNum(ctx.away_st,5), tempo: ctx.tempo, shots: PSZ.safeNum(ctx.shots_away, NaN), manager_aggr: PSZ.safeNum(ctx.manager_aggr, NaN), park: ctx.park_away });
        el("away_press").value = p.toFixed(2);
        ctx.away_press = p;
      }

      // Fill PPDA via Master.autoPPDA (handles park/contain and manual override)
      const pp = PSZ.Master.autoPPDA({ home_press: ctx.home_press, away_press: ctx.away_press, tempo: ctx.tempo, homeFormation: ctx.homeFormation, awayFormation: ctx.awayFormation, shots_home: ctx.shots_home, shots_away: ctx.shots_away, ppda_home: ctx.ppda_home, ppda_away: ctx.ppda_away, park_home: ctx.park_home, park_away: ctx.park_away });
      if(!(PSZ.safeNum(ctx.ppda_home,0) > 0)){ el("ppda_home").value = pp.ppdaH.toFixed(2); ctx.ppda_home = pp.ppdaH; }
      if(!(PSZ.safeNum(ctx.ppda_away,0) > 0)){ el("ppda_away").value = pp.ppdaA.toFixed(2); ctx.ppda_away = pp.ppdaA; }

      // Fill Flex
      if(!(PSZ.safeNum(ctx.home_flex,0) > 0)){
        const f = PSZ.AutoInput.inferFlex({ formation: ctx.homeFormation, tempo: ctx.tempo, park: ctx.park_home });
        el("home_flex").value = f.toFixed(3);
        ctx.home_flex = f;
      }
      if(!(PSZ.safeNum(ctx.away_flex,0) > 0)){
        const f = PSZ.AutoInput.inferFlex({ formation: ctx.awayFormation, tempo: ctx.tempo, park: ctx.park_away });
        el("away_flex").value = f.toFixed(3);
        ctx.away_flex = f;
      }

      // Manager Aggression
      if(!(PSZ.safeNum(ctx.manager_aggr,0) > 0)){
        const mg = PSZ.AutoInput.inferManagerAggression({ tempo: ctx.tempo, press: (ctx.home_press+ctx.away_press)/2, formation: ctx.homeFormation, park: ctx.park_home });
        el("manager_aggr").value = mg.toFixed(2);
        ctx.manager_aggr = mg;
      }

      // Defensive Line
      if(!(PSZ.safeNum(ctx.def_line,0) > 0)){
        const dl = PSZ.AutoInput.inferDefLine({ press: (ctx.home_press+ctx.away_press)/2, manager_aggr: ctx.manager_aggr, park: ctx.park_home });
        el("def_line").value = dl.toFixed(2);
        ctx.def_line = dl;
      }

      // Injury Impact
      if(!(PSZ.safeNum(ctx.injury_impact_home,0) > 0)){
        const injH = PSZ.AutoInput.inferInjuryImpact({ explicit: PSZ.safeNum(ctx.injury_impact_home,0), conceded_last5: PSZ.safeNum(ctx.conceded_last5_home, NaN) });
        el("injury_impact_home").value = injH.toFixed(3);
        ctx.injury_impact_home = injH;
      }
      if(!(PSZ.safeNum(ctx.injury_impact_away,0) > 0)){
        const injA = PSZ.AutoInput.inferInjuryImpact({ explicit: PSZ.safeNum(ctx.injury_impact_away,0), conceded_last5: PSZ.safeNum(ctx.conceded_last5_away, NaN) });
        el("injury_impact_away").value = injA.toFixed(3);
        ctx.injury_impact_away = injA;
      }

      // Transition Efficiency (fill average if both empty)
      if(!(PSZ.safeNum(ctx.transition_eff,0) > 0)){
        const teH = PSZ.AutoInput.inferTransition({ pos: PSZ.safeNum(ctx.pos_home, NaN), shots: PSZ.safeNum(ctx.shots_home, NaN), park: ctx.park_home });
        const teA = PSZ.AutoInput.inferTransition({ pos: PSZ.safeNum(ctx.pos_away, NaN), shots: PSZ.safeNum(ctx.shots_away, NaN), park: ctx.park_away });
        const te = PSZ.clamp((teH + teA)/2, 0.02, 0.95);
        el("transition_eff").value = te.toFixed(3);
        ctx.transition_eff = te;
      }

      // Chaos inference if empty
      if(!(PSZ.safeNum(ctx.chaos,0) > 0)){
        const c = PSZ.AutoInput.inferChaos(ctx, preset);
        el("chaos").value = c.toFixed(2);
        ctx.chaos = c;
      }

      // Ensure tempo/importance DOM reflect values
      if(el("tempo") && (!el("tempo").value || Number(el("tempo").value) === 0)) el("tempo").value = ctx.tempo.toFixed(2);
      if(el("importance") && (!el("importance").value || Number(el("importance").value) === 0)) el("importance").value = ctx.importance.toFixed(2);

      // write lam back only if originally empty (SMART)
      if(PSZ.safeNum(el("lamH")?.value,0) <= 0) el("lamH").value = lamH.toFixed(3);
      if(PSZ.safeNum(el("lamA")?.value,0) <= 0) el("lamA").value = lamA.toFixed(3);

      // log summary
      const out = document.getElementById("output");
      if(out){
        out.value += `\n[AUTO INPUT SMART] Preset:${match_type} tempo:${ctx.tempo} chaos:${ctx.chaos} lamH:${lamH.toFixed(3)} lamA:${lamA.toFixed(3)}`;
        out.scrollTop = out.scrollHeight;
      }

      // return ctx for programmatic usage
      ctx.lamH = lamH; ctx.lamA = lamA;
      return ctx;
    }catch(e){
      console.error("AutoInput error", e);
      return null;
    }
  };

  console.log("PART 3 — AUTO INPUT SUPER ENGINE LOADED (REBUILD LEVEL 25)");
})(window.PSZ);
</script>
<!-- END PART 3 -->
<!-- =========================
     PART 4 — TACTICAL ENGINE 5.0
     - formation matchup
     - xT proxy
     - press/flex interplay
     - late-tactical-shift model (LTSM)
     - shot quality estimation
     - defensive collapse risk
     - Public API: PSZ.Tactics.applyTactics(ctx, master)
========================= -->
<script>
(function(PSZ){
  PSZ.Tactics = PSZ.Tactics || {};

  /* ---------------------------
     formationEffect
     returns adjustments {attackBias, defenceBias, widthBias}
     positive attackBias increases scoring lambda
  --------------------------- */
  PSZ.Tactics.formationEffect = function(formation){
    const f = (formation||"").toLowerCase();
    let attackBias = 0, defenceBias = 0, widthBias = 0;

    if(f.includes("4-3-3") || f.includes("3-4-3") || f.includes("4-2-3-1")){
      attackBias += 0.12; widthBias += 0.08;
    } else if(f.includes("4-4-2") || f.includes("3-5-2")){
      attackBias += 0.06; widthBias += 0.04;
    } else if(f.includes("5-3-2") || f.includes("5-4-1") || f.includes("5-2-3")){
      defenceBias += 0.16; attackBias -= 0.08;
    } else if(f.includes("4-5-1") || f.includes("4-1-4-1")){
      defenceBias += 0.06; attackBias -= 0.04;
    } else {
      // unknown => neutral
      attackBias += 0.00;
    }
    return { attackBias, defenceBias, widthBias };
  };

  /* ---------------------------
     computexTProxy
     Simple expected-threat proxy using SOT, shots, press, transition, possession
     Returns xT-like score (0..1) representing chance to create high-quality chances
  --------------------------- */
  PSZ.Tactics.computexTProxy = function(opts){
    opts = opts || {};
    const sot = PSZ.safeNum(opts.sot, NaN);
    const shots = PSZ.safeNum(opts.shots, NaN);
    const press = PSZ.safeNum(opts.press, 5);
    const trans = PSZ.safeNum(opts.transition, 0.5);
    const pos = PSZ.safeNum(opts.pos, 50);

    // base from shots quality (SOT/shot)
    let shotQuality = 0.12;
    if(Number.isFinite(sot) && Number.isFinite(shots) && shots > 0) shotQuality = PSZ.clamp(sot / shots, 0.05, 0.9);
    else shotQuality = 0.28; // default guess

    // press increases turnover chance -> raises xT up to a point
    const pressEffect = PSZ.clamp((press - 4.5) * 0.06, -0.25, 0.6);

    // transition: efficient transition raises xT
    const transEffect = PSZ.clamp((trans - 0.45) * 0.9, -0.4, 0.8);

    // possession effect (very high possession can lower counter xT)
    const posEffect = (pos > 60) ? -0.06 : (pos < 40 ? 0.04 : 0);

    // combine
    const xT = PSZ.clamp( shotQuality * 0.6 + pressEffect * 0.25 + transEffect * 0.2 + posEffect, 0.02, 1.25 );
    return { xT: xT, shotQuality: shotQuality, pressEffect, transEffect, posEffect };
  };

  /* ---------------------------
     pressFlexInterplay
     Returns modifier object that affects lam and shotQuality
  --------------------------- */
  PSZ.Tactics.pressFlexInterplay = function(home, away){
    // home/away objects: {press, flex, formation, transition, pos, shots, sot}
    const h = home || {}, a = away || {};
    const hPress = PSZ.safeNum(h.press,5), aPress = PSZ.safeNum(a.press,5);
    const hFlex = PSZ.safeNum(h.flex, 0.5), aFlex = PSZ.safeNum(a.flex,0.5);

    // combined pressure differential
    const pressDiff = (hPress - aPress) / 10;
    // flex advantage -> more fluid attacking transitions
    const flexDiff = (hFlex - aFlex);

    // home advantage to xT and lam
    const attackModifier = PSZ.clamp(0.08 * pressDiff + 0.12 * flexDiff, -0.5, 0.5);
    const defenceModifier = PSZ.clamp(-0.06 * pressDiff - 0.08 * flexDiff, -0.5, 0.5);

    // shot quality shift from flex and press
    const shotQualityShift = PSZ.clamp(0.12 * flexDiff + 0.06 * pressDiff, -0.4, 0.4);

    return { attackModifier, defenceModifier, shotQualityShift, pressDiff, flexDiff };
  };

  /* ---------------------------
     lateTacticalShiftModel (LTSM)
     Simulates probability of in-game tactical shifts that change lambda flow
     Input: ctx, minute (optional)
     Returns modifier multiplier for lambda at a given minute (1.0 = no change)
  --------------------------- */
  PSZ.Tactics.lateTacticalShiftMultiplier = function(ctx, minute){
    ctx = ctx || {};
    minute = PSZ.safeNum(minute, 0);
    // triggers: high importance, high fatigue risk, big scoreline, manager_aggr
    const importance = PSZ.safeNum(ctx.importance, 5);
    const managerAgg = PSZ.safeNum(ctx.manager_aggr, 5);
    const injuredHome = PSZ.safeNum(ctx.injury_impact_home, 0);
    const injuredAway = PSZ.safeNum(ctx.injury_impact_away, 0);
    const baseProb = PSZ.clamp((importance - 4)/6 + (managerAgg - 5)/10 + (injuredHome + injuredAway)/4, 0, 0.95);

    // late phases (70+ minute) more likely to shift
    const lateFactor = (minute >= 70) ? 1.6 : (minute >= 55 ? 1.1 : 0.6);

    // random small effect per minute
    const rand = PSZ.randNorm(0, 0.06);

    // multiplier range: 0.7 .. 1.45
    const shift = 1 + (PSZ.clamp(baseProb * 0.5 * lateFactor, 0, 0.9) * rand);
    return PSZ.clamp(shift, 0.7, 1.45);
  };

  /* ---------------------------
     shotQualityEstimation
     Returns expected goal conversion probability per shot (0..1)
  --------------------------- */
  PSZ.Tactics.shotQualityEstimation = function(opts){
    opts = opts || {};
    const baseSQ = 0.09; // average conversion ~9%
    const shotQual = PSZ.safeNum(opts.shotQuality, 0.28); // from computexTProxy
    const press = PSZ.safeNum(opts.press, 5);
    const transition = PSZ.safeNum(opts.transition, 0.45);

    // adjustments
    const pressPenalty = (press > 7) ? -0.015 : (press < 4 ? 0.01 : 0);
    const transBoost = PSZ.clamp((transition - 0.45) * 0.06, -0.02, 0.05);

    const final = PSZ.clamp(baseSQ + (shotQual - 0.28) * 0.22 + pressPenalty + transBoost, 0.02, 0.35);
    return final;
  };

  /* ---------------------------
     defensiveCollapseRisk
     Returns probability (0..1) that defense collapses leading to higher concede risk.
     Inputs: fatigueProxy (minutes played or schedule congestion), injuries, stability diff, fragility
  --------------------------- */
  PSZ.Tactics.defensiveCollapseRisk = function(opts){
    opts = opts || {};
    const fatigue = PSZ.safeNum(opts.fatigue, 0); // 0..1
    const injury = PSZ.safeNum(opts.injuryImpact, 0); // 0..1
    const stability = PSZ.safeNum(opts.stability, 5); // 1..10
    const chaos = PSZ.safeNum(opts.chaos,5);
    const fragility = PSZ.safeNum(opts.fragility, 0);

    // higher fatigue + injuries + low stability + high chaos -> more risk
    const raw = 0.06*fatigue + 0.35*injury + 0.09*(5 - (stability-5)) + 0.06*(chaos-5) + 0.12*fragility;
    return PSZ.clamp(raw, 0, 0.95);
  };

  /* ---------------------------
     applyTactics(ctx, master)
     - ctx: full context from DOM (lam, press, flex, formation, etc)
     - master: PSZ.Master.init(ctx) or PSZ.Master.mergeMaster return
     Returns:
       {
         adjustedLam: { lamH, lamA },
         tactics: { details... },
         notes: "..."
       }
  --------------------------- */
  PSZ.Tactics.applyTactics = function(ctx, master){
    try{
      ctx = ctx || {};
      master = master || PSZ.Master.init(ctx);

      // formation effects
      const feH = PSZ.Tactics.formationEffect(ctx.homeFormation);
      const feA = PSZ.Tactics.formationEffect(ctx.awayFormation);

      // compute xT proxies
      const xTh = PSZ.Tactics.computexTProxy({
        sot: PSZ.safeNum(ctx.sot_home, PSZ.safeNum(ctx.sot_home, NaN)),
        shots: PSZ.safeNum(ctx.shots_home, PSZ.safeNum(ctx.shots_home, NaN)),
        press: PSZ.safeNum(ctx.home_press, 5),
        transition: PSZ.safeNum(ctx.transition_eff, 0.45),
        pos: PSZ.safeNum(ctx.pos_home, 50)
      });
      const xTa = PSZ.Tactics.computexTProxy({
        sot: PSZ.safeNum(ctx.sot_away, PSZ.safeNum(ctx.sot_away, NaN)),
        shots: PSZ.safeNum(ctx.shots_away, PSZ.safeNum(ctx.shots_away, NaN)),
        press: PSZ.safeNum(ctx.away_press, 5),
        transition: PSZ.safeNum(ctx.transition_eff, 0.45),
        pos: PSZ.safeNum(ctx.pos_away, 50)
      });

      // press-flex interplay
      const pf = PSZ.Tactics.pressFlexInterplay(
        { press: PSZ.safeNum(ctx.home_press,5), flex: PSZ.safeNum(ctx.home_flex,0.5) },
        { press: PSZ.safeNum(ctx.away_press,5), flex: PSZ.safeNum(ctx.away_flex,0.5) }
      );

      // baseline adjusted lambda from master (includes chaos)
      let lamH_base = PSZ.safeNum(master.lamH_adj || master.lamH || master.lamH_adj, PSZ.safeNum(ctx.lamH, 1.2));
      let lamA_base = PSZ.safeNum(master.lamA_adj || master.lamA || master.lamA_adj, PSZ.safeNum(ctx.lamA, 1.0));

      // tactical modifiers mapping
      // increase lam per attackBias + xT advantage + press interplay
      const attackAddH = feH.attackBias + (xTh.xT - xTa.xT) * 0.8 + pf.attackModifier;
      const attackAddA = feA.attackBias + (xTa.xT - xTh.xT) * 0.8 - pf.attackModifier;

      // shot quality shifts
      const shotQualityH = PSZ.Tactics.shotQualityEstimation({ shotQuality: xTh.shotQuality, press: ctx.home_press, transition: ctx.transition_eff });
      const shotQualityA = PSZ.Tactics.shotQualityEstimation({ shotQuality: xTa.shotQuality, press: ctx.away_press, transition: ctx.transition_eff });

      // apply park-the-bus and contain effects already partly done in AutoInput; ensure further adjustment
      if(ctx.park_home === "park") { lamH_base *= 0.78; }
      if(ctx.park_away === "park") { lamA_base *= 0.78; }

      // final tactical lam calculation and clamp
      let lamH = PSZ.clamp(lamH_base * (1 + attackAddH), 0.05, 12);
      let lamA = PSZ.clamp(lamA_base * (1 + attackAddA), 0.05, 12);

      // conservative nudge: if shotQuality high but lam low, boost lam slightly
      if(shotQualityH > 0.16 && lamH < 0.9) lamH *= (1 + (shotQualityH - 0.12) * 0.9);
      if(shotQualityA > 0.16 && lamA < 0.9) lamA *= (1 + (shotQualityA - 0.12) * 0.9);

      // compute defensive collapse risk
      const fragilityProxy = PSZ.safeNum(ctx.fragility || 0, 0);
      const collapseH = PSZ.Tactics.defensiveCollapseRisk({ fatigue: PSZ.safeNum(ctx.fatigue, 0), injuryImpact: PSZ.safeNum(ctx.injury_impact_home, 0), stability: PSZ.safeNum(ctx.home_st, 5), chaos: PSZ.safeNum(ctx.chaos,5), fragility: fragilityProxy });
      const collapseA = PSZ.Tactics.defensiveCollapseRisk({ fatigue: PSZ.safeNum(ctx.fatigue, 0), injuryImpact: PSZ.safeNum(ctx.injury_impact_away, 0), stability: PSZ.safeNum(ctx.away_st, 5), chaos: PSZ.safeNum(ctx.chaos,5), fragility: fragilityProxy });

      // margin safety: if collapse risk high, increase opponent lam a bit
      lamH = PSZ.clamp(lamH * (1 + collapseA * 0.18), 0.05, 14);
      lamA = PSZ.clamp(lamA * (1 + collapseH * 0.18), 0.05, 14);

      // produce tactic summary
      const tactics = {
        formationH: ctx.homeFormation, formationA: ctx.awayFormation,
        feH, feA,
        xT: { home: xTh, away: xTa },
        pf, shotQuality: { home: shotQualityH, away: shotQualityA },
        collapseRisk: { home: collapseH, away: collapseA },
        attackAdd: { home: attackAddH, away: attackAddA }
      };

      // notes
      const notes = `Tactics applied: attackAddH=${attackAddH.toFixed(3)}, attackAddA=${attackAddA.toFixed(3)}, xTdiff=${(xTh.xT - xTa.xT).toFixed(3)}`;

      return {
        adjustedLam: { lamH, lamA },
        tactics,
        notes
      };
    }catch(e){
      console.error("Tactics.applyTactics error", e);
      return { adjustedLam: { lamH: PSZ.safeNum(master.lamH_adj,1.2), lamA: PSZ.safeNum(master.lamA_adj,1.0) }, tactics: {}, notes: "error" };
    }
  };

  console.log("PART 4 — TACTICAL ENGINE 5.0 LOADED");
})(window.PSZ);
</script>
<!-- END PART 4 -->
<!-- ============================================
     PART 5 — ENGINE OMEGA E5 (LEVEL 25 REBUILD)
     - deterministic engine (Poisson + DC)
     - tactical engine fusion
     - Monte-Carlo E5 simulator (multi-phase)
     - volatility & chaos integration
     - uncertainty
     - risk & fragility
     - score matrix generator
     - BTTS / O/U lines
============================================ -->
<script>
(function(PSZ){

  PSZ.Engine = PSZ.Engine || {};

  /* ------------------------------
     Deterministic Poisson + Dixon–Coles Model
  ------------------------------ */
  PSZ.Engine.detModel = function(lamH, lamA, rho = 0){
    const dc = PSZ.dixonColes(lamH, lamA, rho);
    let pH = 0, pD = 0, pA = 0;
    let matrix = [];

    for(let h=0; h<=6; h++){
      matrix[h] = [];
      for(let a=0; a<=6; a++){
        let p = PSZ.poissonPMF(lamH, h) * PSZ.poissonPMF(lamA, a) * dc(h,a);
        matrix[h][a] = p;
        if(h > a) pH += p;
        else if(h === a) pD += p;
        else pA += p;
      }
    }

    const norm = pH + pD + pA;
    if(norm <= 0){
      return {pH:1/3,pD:1/3,pA:1/3,matrix};
    }
    return { pH:pH/norm, pD:pD/norm, pA:pA/norm, matrix };
  };

  /* ------------------------------
     Monte-Carlo OMEGA E5
     features:
     - 3-phase match simulation (0–30, 30–60, 60–90)
     - chaos turbulence
     - tactical-shift multiplier (Part 4 LTSM)
     - volatility injection
  ------------------------------ */
  PSZ.Engine.mcE5 = function(ctx, tactics, simCount = 20000){
    const lamH0 = PSZ.safeNum(tactics.lamH, 1.2);
    const lamA0 = PSZ.safeNum(tactics.lamA, 1.0);
    const chaos = PSZ.safeNum(ctx.chaos,5);
    const vol = PSZ.safeNum(ctx.volatility || ctx.vol, 0.5);

    let wH = 0, wD = 0, wA = 0;
    let goalMat = [...Array(8)].map(()=>Array(8).fill(0));
    let totalGoals = 0;

    for(let i=0; i<simCount; i++){
      let gH = 0, gA = 0;

      // phase multipliers
      const ph1 = 1 + PSZ.randNorm(0, (chaos-5)*0.03);
      const ph2 = PSZ.Tactics.lateTacticalShiftMultiplier(ctx, 55) * (1 + vol*0.04);
      const ph3 = PSZ.Tactics.lateTacticalShiftMultiplier(ctx, 75) * (1 + vol*0.07);

      const lamH1 = PSZ.clamp(lamH0 * ph1 * 0.35, 0.01, 8);
      const lamH2 = PSZ.clamp(lamH0 * ph2 * 0.33, 0.01, 8);
      const lamH3 = PSZ.clamp(lamH0 * ph3 * 0.32, 0.01, 8);

      const lamA1 = PSZ.clamp(lamA0 * ph1 * 0.35, 0.01, 8);
      const lamA2 = PSZ.clamp(lamA0 * ph2 * 0.33, 0.01, 8);
      const lamA3 = PSZ.clamp(lamA0 * ph3 * 0.32, 0.01, 8);

      gH += PSZ.poissonSample(lamH1);
      gH += PSZ.poissonSample(lamH2);
      gH += PSZ.poissonSample(lamH3);

      gA += PSZ.poissonSample(lamA1);
      gA += PSZ.poissonSample(lamA2);
      gA += PSZ.poissonSample(lamA3);

      if(gH > gA) wH++;
      else if(gH === gA) wD++;
      else wA++;

      const hh = Math.min(gH,7);
      const aa = Math.min(gA,7);
      goalMat[hh][aa] += 1;

      totalGoals += (gH + gA);
    }

    return {
      pH: wH/simCount,
      pD: wD/simCount,
      pA: wA/simCount,
      avgGoals: totalGoals/simCount,
      matrix: goalMat,
      simCount
    };
  };

  /* ------------------------------
     Fusion Model
     mix detModel + tacticalModel + mcE5
     weights depend on chaos + importance
  ------------------------------ */
  PSZ.Engine.fuse = function(det, tac, mc, ctx){
    const chaos = PSZ.safeNum(ctx.chaos,5);
    const importance = PSZ.safeNum(ctx.importance,5);

    // deterministic gets higher weight in low chaos
    const wDet = PSZ.clamp(1.0 - (chaos-5)*0.07, 0.2, 1.4);
    // tactical weighted by importance
    const wTac = PSZ.clamp(0.8 + (importance-5)*0.1, 0.3, 1.6);
    // mc weighted by chaos
    const wMC  = PSZ.clamp(0.8 + (chaos-5)*0.12, 0.3, 1.8);

    const pH = (det.pH*wDet + tac.pH*wTac + mc.pH*wMC) / (wDet+wTac+wMC);
    const pD = (det.pD*wDet + tac.pD*wTac + mc.pD*wMC) / (wDet+wTac+wMC);
    const pA = (det.pA*wDet + tac.pA*wTac + mc.pA*wMC) / (wDet+wTac+wMC);

    return PSZ.normalize3(pH,pD,pA);
  };

  /* ------------------------------
     O/U LINES, BTTS
  ------------------------------ */
  PSZ.Engine.computeOU = function(matrix, simCount){
    simCount = simCount || 1;
    function pctOver(line){
      let cut = Math.floor(line);
      let over=0, under=0;
      for(let h=0;h< matrix.length;h++){
        for(let a=0;a< matrix[h].length;a++){
          const sum = h + a;
          const ct = matrix[h][a];
          if(sum > cut) over += ct;
          else under += ct;
        }
      }
      return { over:over/simCount, under:under/simCount };
    }
    return {
      "0.5": pctOver(0.5),
      "1.5": pctOver(1.5),
      "2.5": pctOver(2.5),
      "3.5": pctOver(3.5),
      "4.5": pctOver(4.5)
    };
  };

  PSZ.Engine.computeBTTS = function(matrix, simCount){
    simCount = simCount || 1;
    let yes=0;
    for(let h=0;h<matrix.length;h++){
      for(let a=0;a<matrix[h].length;a++){
        if(h>0 && a>0) yes += matrix[h][a];
      }
    }
    return yes/simCount;
  };

  /* ------------------------------
     Risk + Fragility + Uncertainty Index
  ------------------------------ */
  PSZ.Engine.computeRisk = function(ctx){
    const chaos = PSZ.safeNum(ctx.chaos,5);
    const vol = PSZ.safeNum(ctx.volatility||0.5,0.5);
    return PSZ.clamp((chaos-5)*0.08 + vol*0.25, 0, 1);
  };

  PSZ.Engine.computeFragility = function(ctx){
    const stH = PSZ.safeNum(ctx.home_st,5);
    const stA = PSZ.safeNum(ctx.away_st,5);
    const injH = PSZ.safeNum(ctx.injury_impact_home,0);
    const injA = PSZ.safeNum(ctx.injury_impact_away,0);
    const c = PSZ.safeNum(ctx.chaos,5);
    const raw = (injH+injA)*0.4 + (10-stH-stA)*0.03 + (c-5)*0.04;
    return PSZ.clamp(raw, 0, 1);
  };

  PSZ.Engine.computeUncertainty = function(prob){
    // prob = {pH,pD,pA}
    const maxP = Math.max(prob.pH, prob.pD, prob.pA);
    const entropy = -(prob.pH*Math.log(prob.pH+1e-12) + prob.pD*Math.log(prob.pD+1e-12) + prob.pA*Math.log(prob.pA+1e-12));
    const Hmax = Math.log(3);
    return PSZ.clamp(entropy/Hmax, 0, 1); // 0 = pasti, 1 = sangat acak
  };

  /* ------------------------------
     MAIN RUNNER (ENGINE E5)
     returns fullResult = {
        lamH, lamA,
        prob: {pH,pD,pA},
        matrix,
        ou, btts,
        risk, frag, unc,
        avgGoals
     }
  ------------------------------ */
  PSZ.Engine.runE5 = function(ctx, tacObj, masterObj){
    const lamH = tacObj.adjustedLam.lamH;
    const lamA = tacObj.adjustedLam.lamA;

    // deterministic model
    const det = PSZ.Engine.detModel(lamH, lamA, 0.05);

    // tactical pseudo-deterministic model
    const tacDet = PSZ.Engine.detModel(lamH*1.0, lamA*1.0, 0.04);

    // monte carlo
    const mc = PSZ.Engine.mcE5(ctx, tacObj.adjustedLam, PSZ.safeNum(ctx.simIntensity, 20000));

    // fusion
    const prob = PSZ.Engine.fuse(det, tacDet, mc, ctx);

    // OU, BTTS
    const ou = PSZ.Engine.computeOU(mc.matrix, mc.simCount);
    const btts = PSZ.Engine.computeBTTS(mc.matrix, mc.simCount);

    // risk, frag, unc
    const risk = PSZ.Engine.computeRisk(ctx);
    const frag = PSZ.Engine.computeFragility(ctx);
    const unc = PSZ.Engine.computeUncertainty(prob);

    return {
      lamH, lamA,
      prob,
      matrix: mc.matrix,
      avgGoals: mc.avgGoals,
      ou,
      btts,
      risk,
      frag,
      unc
    };
  };

  console.log("PART 5 — ENGINE LEVEL 25 (OMEGA E5) LOADED");

})(window.PSZ);
</script>
<!-- END PART 5 -->
<!-- =========================
     PART 6 — WIN PATH MODEL & MOMENTUM ENGINE
     - Momentum Swing Index (MSI)
     - Win-Path Score & Pattern Classifier
     - Short-run comeback sim (chunked)
     - Public API:
         PSZ.Momentum.analyze(ctx, engineResult)
         PSZ.Momentum.simulateShortRuns(ctx, adjustedLam, sims)
========================= -->
<script>
(function(PSZ){
  PSZ.Momentum = PSZ.Momentum || {};

  /* ===========================
     Helper: smoothScore (0..1)
     maps arbitrary predictor into 0..1
  ============================ */
  PSZ.Momentum.smoothScore = function(x, center=0, scale=1){
    return PSZ.clamp( (1/(1+Math.exp(-(x-center)/Math.max(1e-6,scale)))), 0, 1 );
  };

  /* ===========================
     Momentum Swing Index (MSI)
     - uses momentum, stability, recent scoring, fragility, chaos
     - returns value -1..1 (negative -> away momentum, positive -> home momentum)
  ============================ */
  PSZ.Momentum.computeMSI = function(ctx){
    const homeMom = PSZ.safeNum(ctx.home_mom, 5);
    const awayMom = PSZ.safeNum(ctx.away_mom, 5);
    const homeSt = PSZ.safeNum(ctx.home_st, 5);
    const awaySt = PSZ.safeNum(ctx.away_st, 5);
    const scoredH = PSZ.safeNum(ctx.scored_last5_home, 2);
    const scoredA = PSZ.safeNum(ctx.scored_last5_away, 2);
    const concededH = PSZ.safeNum(ctx.conceded_last5_home, 2);
    const concededA = PSZ.safeNum(ctx.conceded_last5_away, 2);
    const frag = PSZ.safeNum(ctx.fragility, 0);
    const chaos = PSZ.safeNum(ctx.chaos, 5);

    // signal components
    const momDiff = (homeMom - awayMom) / 10; // -0.9..0.9
    const formDiff = ((scoredH - concededH) - (scoredA - concededA)) / 10;
    const stabilityDiff = (homeSt - awaySt) / 10;
    const fragEffect = -frag * 0.6; // fragility reduces persistence
    const chaosEffect = (5 - chaos) * 0.02; // more chaos reduces determinism

    const raw = momDiff*0.45 + formDiff*0.25 + stabilityDiff*0.2 + fragEffect + chaosEffect;
    // clamp -1..1
    return PSZ.clamp(raw, -1, 1);
  };

  /* ===========================
     Win-Path Score (WPS)
     - Combines MSI, current prob distribution, and volatility to estimate "path" tendency
     - returns object with pattern: 'control','swing','stalled','comeback-prone','chaotic'
  ============================ */
  PSZ.Momentum.computeWinPath = function(ctx, prob){
    // prob: {pH,pD,pA}
    const msi = PSZ.Momentum.computeMSI(ctx);
    const maxP = Math.max(prob.pH, prob.pD, prob.pA);
    const spread = Math.abs(prob.pH - prob.pA);
    const uncertainty = PSZ.Engine ? PSZ.Engine.computeUncertainty(prob) : PSZ.clamp(1 - maxP, 0, 1);
    const frag = PSZ.safeNum(ctx.fragility, 0);
    const chaos = PSZ.safeNum(ctx.chaos, 5);

    // heuristic scoring
    const controlScore = (maxP > 0.55 && spread > 0.18 && uncertainty < 0.35 && Math.abs(msi) > 0.25) ? 1 : 0;
    const swingScore = (uncertainty > 0.45 && Math.abs(msi) > 0.35 && spread < 0.12) ? 1 : 0;
    const stalledScore = (maxP < 0.42 && uncertainty < 0.4 && Math.abs(msi) < 0.2) ? 1 : 0;
    const comebackScore = (frag > 0.25 && uncertainty > 0.3 && Math.abs(msi) > 0.2) ? 1 : 0;
    const chaoticScore = (chaos > 6.2 && uncertainty > 0.55) ? 1 : 0;

    // choose highest priority label by simple ranking
    const scores = [
      {k:"control", v:controlScore},
      {k:"swing", v:swingScore},
      {k:"stalled", v:stalledScore},
      {k:"comeback", v:comebackScore},
      {k:"chaotic", v:chaoticScore}
    ];
    // fallback: if none triggered, pick based on MSI
    let picked = scores.reduce((a,b)=> a.v > b.v ? a : b, {k:"none",v:-1}).k;
    if(picked === "none"){
      if(Math.abs(msi) > 0.35) picked = "control";
      else if(uncertainty > 0.5) picked = "swing";
      else picked = "stalled";
    }

    // produce numeric indicators for downstream weighting
    const indicators = {
      msi,
      uncertainty,
      fragility: frag,
      chaos
    };

    return { pattern: picked, indicators, rawScores: scores };
  };

  /* ===========================
     Short-run comeback simulation (fast chunked)
     - Simulates many short 90-min matches but only tracks comeback events / lead changes
     - returns { comebackRate, avgLeadChanges, topScorelines }
     - Uses PSZ.Engine.mcE5 internals for speed but with lower detail
  ============================ */
  PSZ.Momentum.simulateShortRuns = function(ctx, adjustedLam, sims){
    sims = Math.max(100, PSZ.safeNum(sims, 3000));
    adjustedLam = adjustedLam || { lamH: PSZ.safeNum(ctx.lamH,1.2), lamA: PSZ.safeNum(ctx.lamA,1.0) };

    const chunk = 500;
    let i = 0;
    let comebacks = 0, leadChanges = 0, homeWins = 0, awayWins = 0, draws = 0;
    const topMap = {};

    return new Promise((resolve,reject)=>{
      function runChunk(){
        const end = Math.min(i + chunk, sims);
        try{
          for(; i<end; i++){
            // simplified minute sim but random-phase
            const baseH = PSZ.safeNum(adjustedLam.lamH,1.2);
            const baseA = PSZ.safeNum(adjustedLam.lamA,1.0);
            // inject small chaos
            const noiseH = Math.max(0.05, baseH * (1 + PSZ.randNorm(0, PSZ.safeNum(ctx.chaos,5)*0.02)));
            const noiseA = Math.max(0.05, baseA * (1 + PSZ.randNorm(0, PSZ.safeNum(ctx.chaos,5)*0.02)));
            // sample 3 phases
            let gH = PSZ.poissonSample(noiseH*0.4) + PSZ.poissonSample(noiseH*0.35) + PSZ.poissonSample(noiseH*0.25);
            let gA = PSZ.poissonSample(noiseA*0.4) + PSZ.poissonSample(noiseA*0.35) + PSZ.poissonSample(noiseA*0.25);

            // apply minor late comeback chance influenced by MSI
            const msi = PSZ.Momentum.computeMSI(ctx);
            if(Math.random() < Math.abs(msi)*0.02){
              if(msi > 0) gH += (Math.random() < 0.25 ? 1 : 0);
              else gA += (Math.random() < 0.25 ? 1 : 0);
            }

            // calculate lead changes proxy
            const lc = Math.floor(Math.random() * 2) * ( (gH+gA) > 0 ? 1 : 0 );
            leadChanges += lc;

            if(gH > gA) homeWins++;
            else if(gA > gH) awayWins++;
            else draws++;

            if((gH > gA && gA > 0) || (gA > gH && gH > 0)) comebacks++;

            const key = `${Math.min(gH,7)}-${Math.min(gA,7)}`;
            topMap[key] = (topMap[key]||0) + 1;
          }
        }catch(e){
          reject(e); return;
        }

        if(i < sims) setTimeout(runChunk, 0);
        else {
          const top = Object.keys(topMap).map(k=>({score:k,count:topMap[k],p:topMap[k]/sims})).sort((a,b)=>b.count-a.count).slice(0,12);
          resolve({
            sims,
            comebackRate: comebacks/sims,
            avgLeadChanges: leadChanges/sims,
            homeWinPct: homeWins/sims,
            awayWinPct: awayWins/sims,
            drawPct: draws/sims,
            top
          });
        }
      }
      setTimeout(runChunk, 0);
    });
  };

  /* ===========================
     analyze(ctx, engineResult)
     - engineResult should include prob and other engine outputs
     - returns combined momentum analysis used by Ensemble/Output
  ============================ */
  PSZ.Momentum.analyze = function(ctx, engineResult){
    try{
      const prob = engineResult && engineResult.prob ? engineResult.prob : {pH:0.33,pD:0.33,pA:0.34};
      // compute MSI
      const msi = PSZ.Momentum.computeMSI(ctx);
      // compute win path pattern
      const wp = PSZ.Momentum.computeWinPath(ctx, prob);
      // short-run sim (fast, lower sims) to estimate comeback risk
      // NOTE: this returns a Promise — but for synchronous callers we provide an immediate stub and attach promise to result
      const shortSimPromise = PSZ.Momentum.simulateShortRuns(ctx, { lamH: engineResult.lamH, lamA: engineResult.lamA }, 1200);

      const out = {
        msi,
        pattern: wp.pattern,
        indicators: wp.indicators,
        shortSim: { promise: shortSimPromise }
      };
      return out;
    }catch(e){
      console.error("Momentum.analyze error", e);
      return { msi:0, pattern:"stalled", indicators:{}, shortSim: { promise: Promise.resolve(null) } };
    }
  };

  console.log("PART 6 — WIN PATH & MOMENTUM ENGINE LOADED (LEVEL 25 REBUILD)");
})(window.PSZ);
</script>
<!-- END PART 6 -->
<!-- =========================
     PART 7 — ML ENSEMBLE & CALIBRATION (LEVEL 25)
     - meta-fusion
     - probability calibration (Platt)
     - adaptive weights
     - recommendation generator (HDP/OU/BTTS/CS)
========================= -->
<script>
(function(PSZ){
  PSZ.ML = PSZ.ML || {};

  /* -----------------------------
     Small utility: plattSigmoid
     - simple Platt scaling: sigmoid(a*x + b)
     - if no calibration data, use a/b default conservative values
  ----------------------------- */
  PSZ.ML.plattSigmoid = function(x, a=0.8, b=0.0){
    // x is logit or raw probability depending use; we standardize expecting x in [-6..6] roughly
    return PSZ.sigmoid(a * x + b);
  };

  /* -----------------------------
     calibrateProbs(prob, method, meta)
     - prob: {pH,pD,pA}
     - method: "platt" | "softmax-temp"
     - meta: {uncertainty, pattern, vol}
     - returns calibrated {pH,pD,pA} (normalized)
     - We use lightweight adaptive calibration:
         - if uncertainty high -> raise temperature (soften)
         - if market correction needed -> shift via platt on logits
  ----------------------------- */
  PSZ.ML.calibrateProbs = function(prob, method, meta){
    method = method || "adaptive";
    meta = meta || {};
    const uncertainty = PSZ.safeNum(meta.uncertainty, 0.35);
    const pattern = meta.pattern || "control";
    const vol = PSZ.safeNum(meta.volatility, 0.5);

    // defensive copy and clamp
    let pH = PSZ.clamp(prob.pH, 1e-6, 1-1e-6);
    let pD = PSZ.clamp(prob.pD, 1e-6, 1-1e-6);
    let pA = PSZ.clamp(prob.pA, 1e-6, 1-1e-6);

    // temperature scaling for softmax
    if(method === "softmax-temp" || method === "adaptive"){
      // temperature increases with uncertainty & volatility -> soften distribution
      const temp = PSZ.clamp(1 + uncertainty*1.2 + vol*0.25, 0.6, 2.4);
      // convert to logits
      const lH = Math.log(pH), lD = Math.log(pD), lA = Math.log(pA);
      const sH = Math.exp(lH / temp), sD = Math.exp(lD / temp), sA = Math.exp(lA / temp);
      const sum = sH + sD + sA;
      pH = sH / sum; pD = sD / sum; pA = sA / sum;
    }

    // platt-like tweak if pattern indicates bias (control -> sharpen slightly)
    if(pattern === "control"){
      // amplify winner slightly
      const winner = (pH > pA) ? "H" : (pA > pH ? "A" : "D");
      const boost = 0.04 * (1 - uncertainty);
      if(winner === "H"){ pH = PSZ.clamp(pH + boost, 0, 0.98); }
      if(winner === "A"){ pA = PSZ.clamp(pA + boost, 0, 0.98); }
    } else if(pattern === "swing"){
      // soften extremes
      pH = pH*(1-0.06) + 0.06/3;
      pD = pD*(1-0.06) + 0.06/3;
      pA = pA*(1-0.06) + 0.06/3;
    }

    return PSZ.normalize3(pH,pD,pA);
  };

  /* -----------------------------
     adaptiveEnsembleWeights(engineResult, momentum)
     - decide weights for det/tac/mc models depending on:
         chaos, importance, momentum pattern, uncertainty
  ----------------------------- */
  PSZ.ML.adaptiveEnsembleWeights = function(ctx, momentum){
    const chaos = PSZ.safeNum(ctx.chaos,5);
    const importance = PSZ.safeNum(ctx.importance,5);
    const uncertainty = PSZ.safeNum(momentum && momentum.indicators && momentum.indicators.uncertainty, 0.4);

    // base weights
    let wDet = PSZ.clamp(1.0 - (chaos-5)*0.08, 0.2, 1.4);
    let wTac = PSZ.clamp(0.9 + (importance-5)*0.12, 0.3, 1.8);
    let wMC  = PSZ.clamp(0.9 + (chaos-5)*0.14 + uncertainty*0.6, 0.3, 2.2);

    // pattern adjustments
    if(momentum && momentum.pattern === "control") { wDet *= 1.1; wTac *= 1.05; }
    if(momentum && momentum.pattern === "swing")   { wMC *= 1.25; wDet *= 0.9; }
    if(momentum && momentum.pattern === "comeback"){ wMC *= 1.4; wTac *= 0.95; }

    return { wDet, wTac, wMC };
  };

  /* -----------------------------
     applyEnsemble
     - engineResult: from PSZ.Engine.runE5
     - ctx: dom ctx
     - momentum: PSZ.Momentum.analyze(...) result
     - returns: final { pH,pD,pA } calibrated + meta
  ----------------------------- */
  PSZ.ML.applyEnsemble = function(ctx, engineResult, momentum){
    try{
      const rawProb = engineResult.prob || {pH:0.33,pD:0.33,pA:0.34};
      const detProb = engineResult.detProb || rawProb; // optional
      const tacProb = engineResult.tacProb || rawProb;
      const mcProb  = engineResult.mcProb  || rawProb;

      // decide weights adaptively
      const weights = PSZ.ML.adaptiveEnsembleWeights(ctx, momentum);
      const pH = ( (rawProb.pH * weights.wDet) + (tacProb.pH * weights.wTac) + (mcProb.pH * weights.wMC) ) / (weights.wDet + weights.wTac + weights.wMC);
      const pD = ( (rawProb.pD * weights.wDet) + (tacProb.pD * weights.wTac) + (mcProb.pD * weights.wMC) ) / (weights.wDet + weights.wTac + weights.wMC);
      const pA = ( (rawProb.pA * weights.wDet) + (tacProb.pA * weights.wTac) + (mcProb.pA * weights.wMC) ) / (weights.wDet + weights.wTac + weights.wMC);

      let fused = PSZ.normalize3(pH,pD,pA);

      // calibration step
      const cal = PSZ.ML.calibrateProbs(fused, "adaptive", { uncertainty: engineResult.unc || 0.35, pattern: momentum ? momentum.pattern : "stalled", volatility: PSZ.safeNum(engineResult.volatility, 0.5) });

      // compute meta indicators
      const maxP = Math.max(cal.pH, cal.pD, cal.pA);
      const fav = (cal.pH === maxP) ? "H" : (cal.pA === maxP ? "A" : "D");

      return {
        prob: cal,
        meta: {
          weights,
          fav,
          maxProb: maxP,
          uncertainty: PSZ.safeNum(engineResult.unc, 0.5),
          pattern: momentum ? momentum.pattern : "stalled"
        }
      };
    }catch(e){
      console.error("ML.applyEnsemble error", e);
      return { prob: {pH:0.33,pD:0.33,pA:0.34}, meta: {} };
    }
  };

  /* -----------------------------
     Recommendation Engine
     - inputs: finalResult (from applyEnsemble + engine), ctx, marketOdds {H,D,A}
     - outputs: array of recommendations with EV and Kelly stake
     - types: "1X2","HDP","OU","BTTS","CORRECT_SCORE"
  ----------------------------- */
  window.PSZ.Recommender = window.PSZ.Recommender || {};

  PSZ.Recommender.generateRecommendations = function(finalResult, ctx, marketOdds){
    marketOdds = marketOdds || {H: PSZ.safeNum(ctx.market_H, null), D: PSZ.safeNum(ctx.market_D, null), A: PSZ.safeNum(ctx.market_A, null)};
    const prob = finalResult.prob || {pH:0.33,pD:0.33,pA:0.34};
    const recommendations = [];

    // 1X2 value scanner
    if(marketOdds.H && marketOdds.D && marketOdds.A){
      const fairH = PSZ.fairOdds(prob.pH);
      const fairD = PSZ.fairOdds(prob.pD);
      const fairA = PSZ.fairOdds(prob.pA);

      // compute EV = (p*(odds-1) - (1-p)) but simpler: EV% = p*odds - 1
      const evH = prob.pH * marketOdds.H - 1;
      const evD = prob.pD * marketOdds.D - 1;
      const evA = prob.pA * marketOdds.A - 1;

      // Kelly stake
      const kH = PSZ.kelly(prob.pH, marketOdds.H);
      const kD = PSZ.kelly(prob.pD, marketOdds.D);
      const kA = PSZ.kelly(prob.pA, marketOdds.A);

      // add recommendations if EV positive and kelly > 0 minimal threshold
      if(evH > 0.02 && kH > 0.02) recommendations.push({ type:"1X2", pick:"Home", prob:prob.pH, odds:marketOdds.H, ev:evH, kelly:kH, tag:"value" });
      if(evD > 0.02 && kD > 0.02) recommendations.push({ type:"1X2", pick:"Draw", prob:prob.pD, odds:marketOdds.D, ev:evD, kelly:kD, tag:"value" });
      if(evA > 0.02 && kA > 0.02) recommendations.push({ type:"1X2", pick:"Away", prob:prob.pA, odds:marketOdds.A, ev:evA, kelly:kA, tag:"value" });
    }

    // OU recommendations (use engine OU lines from finalResult.ou if present)
    if(finalResult.ou){
      // check 2.5 line
      const ou25 = finalResult.ou["2.5"];
      if(ou25){
        // implied prob over = 1 - under
        const marketOverProb = ou25.over || 0;
        // our model over probability using final matrix (approx from engine avgGoals)
        // approximate via poisson of avgGoals? Use mc matrix if present
        let modelOver = 0.5;
        if(finalResult.matrix){
          // compute actual over from matrix
          let overCt = 0, totalCt = finalResult.matrix.reduce((s,r)=>s+r.reduce((x,y)=>x+y,0),0);
          for(let h=0; h< finalResult.matrix.length; h++){
            for(let a=0; a< finalResult.matrix[h].length; a++){
              if(h+a > 2) overCt += finalResult.matrix[h][a];
            }
          }
          modelOver = totalCt > 0 ? (overCt/ totalCt) : (finalResult.avgGoals>2.5?0.7:0.45);
        } else {
          modelOver = finalResult.avgGoals > 2.5 ? 0.62 : 0.38;
        }
        // if model sees > market by margin -> value
        if(modelOver - marketOverProb > 0.06){
          recommendations.push({ type:"OU", pick:"Over 2.5", modelProb:modelOver, marketProb:marketOverProb, note:"value over 2.5" });
        }
        if(marketOverProb - modelOver > 0.06){
          recommendations.push({ type:"OU", pick:"Under 2.5", modelProb:modelOver, marketProb:marketOverProb, note:"value under 2.5" });
        }
      }
    }

    // BTTS
    if(finalResult.btts !== undefined && marketOdds.BTTS !== undefined){
      const modelBTTS = finalResult.btts;
      const marketBTTS = marketOdds.BTTS;
      if(modelBTTS - marketBTTS > 0.07){
        recommendations.push({ type:"BTTS", pick:"Yes", modelProb:modelBTTS, marketProb:marketBTTS, note:"value btts yes" });
      }
      if(marketBTTS - modelBTTS > 0.07){
        recommendations.push({ type:"BTTS", pick:"No", modelProb:modelBTTS, marketProb:marketBTTS, note:"value btts no" });
      }
    }

    // Correct Score shortlist (top N by model probability)
    if(finalResult.matrix){
      const flat = [];
      for(let h=0; h< finalResult.matrix.length; h++){
        for(let a=0; a< finalResult.matrix[h].length; a++){
          flat.push({score:`${h}-${a}`, p: finalResult.matrix[h][a]});
        }
      }
      flat.sort((x,y)=>y.p - x.p);
      const topCS = flat.slice(0,10).filter(x=>x.p > 0.005).map(x=>({ type:"CORRECT_SCORE", score:x.score, prob:x.p }));
      recommendations.push(...topCS);
    }

    // final sort: prefer positive EV, then OU/BTTS value, then CS
    recommendations.sort((a,b)=>{
      const scoreA = (a.ev||0) + (a.modelProb? a.modelProb*0.1:0) + (a.prob? a.prob*0.05:0);
      const scoreB = (b.ev||0) + (b.modelProb? b.modelProb*0.1:0) + (b.prob? b.prob*0.05:0);
      return scoreB - scoreA;
    });

    return recommendations;
  };

  console.log("PART 7 — ML ENSEMBLE & RECOMMENDER LOADED (LEVEL 25)");
})(window.PSZ);
</script>
<!-- END PART 7 -->
<!-- =========================
     PART 8 — OUTPUT O5 & UI HOOKS FINAL (LEVEL 25 REBUILD)
     - Buttons wiring: AUTO INPUT, RUN CORE (async), RUN MINUTE, EXPORT JSON
     - Chunked Monte-Carlo runner wrapper
     - Final output formatting, recommendations display
========================= -->
<script>
(function(PSZ){
  // safety: ensure namespaces exist
  PSZ.Engine = PSZ.Engine || {};
  PSZ.Tactics = PSZ.Tactics || {};
  PSZ.AutoInput = PSZ.AutoInput || {};
  PSZ.Momentum = PSZ.Momentum || {};
  PSZ.ML = PSZ.ML || {};
  PSZ.Recommender = PSZ.Recommender || {};

  /* ======= helper: safe read DOM -> ctx ======= */
  function readCtxFromDOM(){
    const el = id => document.getElementById(id);
    return {
      match_id: (el("match_id")?.value) || ("M_AUTO_"+Date.now()),
      home_team: (el("home_team")?.value) || "Home",
      away_team: (el("away_team")?.value) || "Away",
      match_type: (el("match_type")?.value) || "league",
      lamH: PSZ.safeNum(el("lamH")?.value, 0),
      lamA: PSZ.safeNum(el("lamA")?.value, 0),
      shots_home: PSZ.safeNum(el("shots_home")?.value, NaN),
      shots_away: PSZ.safeNum(el("shots_away")?.value, NaN),
      sot_home: PSZ.safeNum(el("sot_home")?.value, NaN),
      sot_away: PSZ.safeNum(el("sot_away")?.value, NaN),
      pos_home: PSZ.safeNum(el("pos_home")?.value, NaN),
      pos_away: PSZ.safeNum(el("pos_away")?.value, NaN),
      formPts_home: PSZ.safeNum(el("formPts_home")?.value, NaN),
      formPts_away: PSZ.safeNum(el("formPts_away")?.value, NaN),
      scored_last5_home: PSZ.safeNum(el("scored_last5_home")?.value, NaN),
      scored_last5_away: PSZ.safeNum(el("scored_last5_away")?.value, NaN),
      conceded_last5_home: PSZ.safeNum(el("conceded_last5_home")?.value, NaN),
      conceded_last5_away: PSZ.safeNum(el("conceded_last5_away")?.value, NaN),
      home_st: PSZ.safeNum(el("home_st")?.value, 0),
      away_st: PSZ.safeNum(el("away_st")?.value, 0),
      home_mom: PSZ.safeNum(el("home_mom")?.value, 0),
      away_mom: PSZ.safeNum(el("away_mom")?.value, 0),
      home_press: PSZ.safeNum(el("home_press")?.value, 0),
      away_press: PSZ.safeNum(el("away_press")?.value, 0),
      ppda_home: PSZ.safeNum(el("ppda_home")?.value, 0),
      ppda_away: PSZ.safeNum(el("ppda_away")?.value, 0),
      home_flex: PSZ.safeNum(el("home_flex")?.value, 0),
      away_flex: PSZ.safeNum(el("away_flex")?.value, 0),
      manager_aggr: PSZ.safeNum(el("manager_aggr")?.value, NaN),
      def_line: PSZ.safeNum(el("def_line")?.value, NaN),
      injury_impact_home: PSZ.safeNum(el("injury_impact_home")?.value, NaN),
      injury_impact_away: PSZ.safeNum(el("injury_impact_away")?.value, NaN),
      transition_eff: PSZ.safeNum(el("transition_eff")?.value, NaN),
      chaos: PSZ.safeNum(el("chaos")?.value, 0),
      tempo: PSZ.safeNum(el("tempo")?.value, 0),
      importance: PSZ.safeNum(el("importance")?.value, 0),
      homeFormation: (el("homeFormation")?.value) || "",
      awayFormation: (el("awayFormation")?.value) || "",
      park_home: (el("park_home")?.value) || "none",
      park_away: (el("park_away")?.value) || "none",
      market_H: PSZ.safeNum(el("market_H")?.value, null),
      market_D: PSZ.safeNum(el("market_D")?.value, null),
      market_A: PSZ.safeNum(el("market_A")?.value, null),
      simIntensity: PSZ.safeNum(el("simIntensity")?.value, 20000)
    };
  }

  /* ======= helper: append log ======= */
  function appendLog(msg, replace=false){
    const out = document.getElementById("output");
    if(!out) return;
    if(replace) out.value = msg;
    else out.value += "\n" + msg;
    out.scrollTop = out.scrollHeight;
  }

  /* ======= Chunked Monte-Carlo wrapper
     - Calls PSZ.Engine.mcE5 repeatedly with chunkSize and accumulates matrix
     - Returns Promise resolving to aggregated mc result
     - Prevents long single-block loops
  ======= */
  PSZ.Engine.mcE5Chunked = function(ctx, tacticsAdjustedLam, totalSim){
    totalSim = PSZ.safeNum(totalSim, 20000);
    const chunk = Math.min(4000, Math.max(500, Math.floor(totalSim/6))); // balance
    let completed = 0;
    const size = chunk;
    // aggregator
    const maxGoal = 8;
    const aggMatrix = [...Array(maxGoal)].map(()=>Array(maxGoal).fill(0));
    let wH = 0, wD = 0, wA = 0, totalGoals=0;

    return new Promise((resolve,reject)=>{
      function runChunk(){
        const toRun = Math.min(size, totalSim - completed);
        try{
          // call existing mcE5 with toRun
          const partial = PSZ.Engine.mcE5( (ctx||{}), { lamH: tacticsAdjustedLam.lamH, lamA: tacticsAdjustedLam.lamA }, toRun );
          // partial.matrix assumed size 8x8 in mcE5 implementation
          for(let h=0; h< partial.matrix.length && h<maxGoal; h++){
            for(let a=0; a< partial.matrix[h].length && a<maxGoal; a++){
              aggMatrix[h][a] += PSZ.safeNum(partial.matrix[h][a],0);
            }
          }
          wH += partial.pH * partial.simCount;
          wD += partial.pD * partial.simCount;
          wA += partial.pA * partial.simCount;
          totalGoals += partial.avgGoals * partial.simCount;
          completed += partial.simCount;

          appendLog(`[MC CHUNK] completed ${completed}/${totalSim}`, false);

          if(completed < totalSim){
            // schedule next chunk
            setTimeout(runChunk, 20);
          } else {
            // finalize normalization
            const simCount = completed;
            const finalPH = wH / simCount;
            const finalPD = wD / simCount;
            const finalPA = wA / simCount;
            const finalAvgGoals = totalGoals / simCount;
            // normalize matrix to probabilities (divide by simCount)
            for(let h=0; h<maxGoal; h++){
              for(let a=0; a<maxGoal; a++){
                aggMatrix[h][a] = aggMatrix[h][a] / simCount;
              }
            }
            resolve({ pH: finalPH, pD: finalPD, pA: finalPA, matrix: aggMatrix, avgGoals: finalAvgGoals, simCount });
          }
        }catch(e){
          reject(e);
        }
      }
      setTimeout(runChunk, 0);
    });
  };

  /* ======= Runner: full pipeline async ======= */
  PSZ.Runner = PSZ.Runner || {};
  PSZ.Runner.runFullAsync = async function(options){
    options = options || {};
    appendLog("[RUNNER] Starting full pipeline (async)...");

    try{
      // 1. read ctx and smart-fill
      const domCtx = readCtxFromDOM();
      appendLog(`[RUN] Reading inputs for ${domCtx.home_team} vs ${domCtx.away_team}`);
      const filled = PSZ.AutoInput.smartFillFromDOM(); // updates DOM & returns ctx
      if(!filled) throw new Error("AutoInput failed");

      // merge ctx with domCtx for full data
      const ctx = Object.assign({}, domCtx, filled);
      // ensure simIntensity safe
      ctx.simIntensity = PSZ.safeNum(ctx.simIntensity, domCtx.simIntensity || 20000);
      appendLog(`[RUN] simIntensity = ${ctx.simIntensity}`);

      // 2. master init
      const master = PSZ.Master.init(ctx);
      appendLog(`[RUN] Master init lamH_adj=${master.lamH_adj.toFixed(3)} lamA_adj=${master.lamA_adj.toFixed(3)} chaosAdj=${master.chaosAdj.toFixed(3)}`);

      // 3. tactical apply (returns adjusted lam)
      const tacticsRes = PSZ.Tactics.applyTactics(ctx, master);
      appendLog(`[RUN] Tactics applied -> lamH=${tacticsRes.adjustedLam.lamH.toFixed(3)} lamA=${tacticsRes.adjustedLam.lamA.toFixed(3)} | ${tacticsRes.notes}`);

      // 4. engine chunked MC
      appendLog("[RUN] Running chunked Monte-Carlo (E5) — this may take a while but won't freeze UI...");
      const mcResult = await PSZ.Engine.mcE5Chunked(ctx, tacticsRes.adjustedLam, ctx.simIntensity);
      appendLog(`[RUN] MC Done. simCount=${mcResult.simCount} avgGoals=${mcResult.avgGoals.toFixed(3)}`);

      // 5. deterministic & tactical det
      const det = PSZ.Engine.detModel(tacticsRes.adjustedLam.lamH, tacticsRes.adjustedLam.lamA, 0.04);
      const tacDet = PSZ.Engine.detModel(tacticsRes.adjustedLam.lamH, tacticsRes.adjustedLam.lamA, 0.03);

      // 6. fusion (using earlier fuse function adaptation)
      const fused = PSZ.Engine.fuse(det, tacDet, mcResult, ctx);
      appendLog(`[RUN] Fused probabilities -> H:${(fused.h*100||fused.pH*100).toFixed? (fused.pH*100).toFixed(2): (fused.pH*100).toFixed(2)}% ...`);

      // ensure consistent object naming for downstream
      const engineResult = {
        lamH: tacticsRes.adjustedLam.lamH,
        lamA: tacticsRes.adjustedLam.lamA,
        det, tacDet, mc: mcResult,
        prob: fused,
        matrix: mcResult.matrix,
        avgGoals: mcResult.avgGoals,
        ou: PSZ.Engine.computeOU(mcResult.matrix, mcResult.simCount),
        btts: PSZ.Engine.computeBTTS(mcResult.matrix, mcResult.simCount),
        risk: PSZ.Engine.computeRisk(ctx),
        frag: PSZ.Engine.computeFragility(ctx)
      };

      engineResult.unc = PSZ.Engine.computeUncertainty(engineResult.prob);

      // 7. momentum analyze
      const momentum = PSZ.Momentum.analyze(ctx, engineResult);
      appendLog(`[RUN] Momentum pattern: ${momentum.pattern} | MSI:${momentum.msi.toFixed(3)}`);

      // 8. ML ensemble & calibration
      const mlOut = PSZ.ML.applyEnsemble(ctx, engineResult, { pattern: momentum.pattern, indicators: momentum.indicators, volatility: PSZ.safeNum(ctx.volatility,0.5), unc: engineResult.unc });
      appendLog(`[RUN] ML ensemble done. Fav: ${mlOut.meta.fav} MaxProb:${(mlOut.meta.maxProb*100).toFixed(1)}%`);

      // 9. recommendations
      const recs = PSZ.Recommender.generateRecommendations(Object.assign({}, engineResult, { prob: mlOut.prob, ou: engineResult.ou, btts: engineResult.btts, matrix: engineResult.matrix, avgGoals: engineResult.avgGoals }), ctx, { H: ctx.market_H, D: ctx.market_D, A: ctx.market_A, BTTS: ctx.market_BTTS });
      appendLog(`[RUN] Recommendations generated: ${recs.length} items.`);

      // 10. final output build
      const final = {
        meta: { match_id: ctx.match_id, home: ctx.home_team, away: ctx.away_team, timestamp: (new Date()).toISOString() },
        ctx, master, tactics: tacticsRes, engine: engineResult, momentum, ml: mlOut, recs
      };

      // write readable output to textarea
      const outLines = [];
      outLines.push("=== PARLAY LEVEL 25 — ANALYSIS OUTPUT ===");
      outLines.push(`Match: ${final.meta.home} vs ${final.meta.away} (${final.meta.match_id})`);
      outLines.push(`Engine status: sim=${engineResult.mc.simCount} avgGoals=${engineResult.avgGoals.toFixed(3)}`);
      outLines.push("");
      outLines.push("[PROBABILITIES — FINAL]");
      outLines.push(`Home Win: ${(mlOut.prob.pH*100).toFixed(1)}%`);
      outLines.push(`Draw    : ${(mlOut.prob.pD*100).toFixed(1)}%`);
      outLines.push(`Away Win: ${(mlOut.prob.pA*100).toFixed(1)}%`);
      outLines.push("");
      outLines.push(`[RISK/FRAGILITY] risk:${(engineResult.risk*100).toFixed(1)}% frag:${(engineResult.frag*100).toFixed(1)}% unc:${(engineResult.unc*100).toFixed(1)}%`);
      outLines.push(`BTTS: ${(engineResult.btts*100).toFixed(1)}%`);
      outLines.push("");
      outLines.push("[OVER/UNDER — MC]");
      Object.keys(engineResult.ou).forEach(line=>{
        outLines.push(`O/U ${line} -> Over:${(engineResult.ou[line].over*100).toFixed(1)}% | Under:${(engineResult.ou[line].under*100).toFixed(1)}%`);
      });
      outLines.push("");
      outLines.push("[MOMENTUM]");
      outLines.push(`Pattern: ${momentum.pattern} | MSI: ${momentum.msi.toFixed(3)}`);
      outLines.push("");
      outLines.push("[RECOMMENDATIONS]");
      if(recs.length === 0) outLines.push("No positive value found.");
      else recs.forEach(r => {
        if(r.type === "1X2") outLines.push(`- 1X2 VALUE: ${r.pick} | prob:${(r.prob*100).toFixed(1)}% | odds:${r.odds} | EV:${(r.ev*100).toFixed(1)}% | Kelly:${(r.kelly*100).toFixed(1)}%`);
        else if(r.type === "OU") outLines.push(`- OU VALUE: ${r.pick} | model:${(r.modelProb*100).toFixed(1)}% market:${(r.marketProb*100 || 0).toFixed(1)}% | ${r.note}`);
        else if(r.type === "BTTS") outLines.push(`- BTTS: ${r.pick} | model:${(r.modelProb*100).toFixed(1)}% market:${(r.marketProb*100 || 0).toFixed(1)}%`);
        else if(r.type === "CORRECT_SCORE") outLines.push(`- CS: ${r.score} | prob:${(r.prob*100).toFixed(2)}%`);
      });

      // present final object and recommendations
      appendLog(outLines.join("\n"), true);

      // store last run for export
      PSZ.LAST_RUN = final;

      return final;

    }catch(err){
      appendLog("[RUNNER ERROR] " + (err && err.message ? err.message : String(err)));
      console.error(err);
      throw err;
    }
  };

  /* ======= Button wiring ======= */
  function wireButtons(){
    const btnAuto = document.getElementById("btn_auto_input");
    const btnRun = document.getElementById("btn_run_core");
    const btnMinute = document.getElementById("btn_run_minute");

    if(btnAuto){
      btnAuto.addEventListener("click", function(){
        try{
          appendLog("[UI] AUTO INPUT pressed.");
          PSZ.AutoInput.smartFillFromDOM();
          appendLog("[UI] AUTO INPUT complete.");
        }catch(e){
          appendLog("[UI ERROR] Auto Input failed: " + e.message);
        }
      });
    }

    if(btnRun){
      btnRun.addEventListener("click", async function(){
        try{
          btnRun.disabled = true;
          appendLog("[UI] RUN pressed.");
          await PSZ.Runner.runFullAsync();
        }catch(e){
          appendLog("[UI ERROR] Run failed: " + (e && e.message ? e.message : e));
        }finally{
          btnRun.disabled = false;
        }
      });
    }

    if(btnMinute){
      btnMinute.addEventListener("click", function(){
        appendLog("[UI] Running minute-sim (fast)...");
        // simple wrapper to run a light short-run sim and append results
        const ctx = readCtxFromDOM();
        const master = PSZ.Master.init(ctx);
        const tactics = PSZ.Tactics.applyTactics(ctx, master);
        PSZ.Momentum.simulateShortRuns(ctx, { lamH: tactics.adjustedLam.lamH, lamA: tactics.adjustedLam.lamA }, 1200)
        .then(res=>{
          appendLog("[MINUTE SIM] Done: " + JSON.stringify({ comebackRate: res.comebackRate.toFixed(3), avgLeadChanges: res.avgLeadChanges.toFixed(3), homeWinPct: (res.homeWinPct*100).toFixed(1) }));
        }).catch(e=>{
          appendLog("[MINUTE SIM ERROR] " + e.message);
        });
      });
    }

    // Export button (create if not present)
    if(!document.getElementById("btn_export_json")){
      const b = document.createElement("button");
      b.id = "btn_export_json";
      b.className = "alt mini";
      b.textContent = "EXPORT LAST RUN JSON";
      b.style.marginTop = "8px";
      b.addEventListener("click", function(){
        const last = PSZ.LAST_RUN || null;
        if(!last) { appendLog("[EXPORT] No last run to export."); return; }
        const text = JSON.stringify(last, null, 2);
        // copy to clipboard if possible
        if(navigator.clipboard){
          navigator.clipboard.writeText(text).then(()=> appendLog("[EXPORT] JSON copied to clipboard."), ()=> appendLog("[EXPORT] Clipboard write failed — showing prompt."));
        } else {
          prompt("Copy JSON:", text);
        }
      });
      // append to leftPanel
      const lp = document.getElementById("leftPanel");
      if(lp) lp.appendChild(b);
    }
  }

  // wire on DOM ready
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", wireButtons);
  } else {
    wireButtons();
  }

  appendLog("PART 8 — UI HOOKS LOADED. Ready.");
  console.log("PART 8 — OUTPUT & HOOKS LOADED");

})(window.PSZ);
</script>
<!-- END PART 8 -->
</body>
</html>
